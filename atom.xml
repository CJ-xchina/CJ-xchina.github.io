<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ther的小站</title>
  
  
  <link href="http://cjx_0723.gitee.io/atom.xml" rel="self"/>
  
  <link href="http://cjx_0723.gitee.io/"/>
  <updated>2023-10-30T14:04:29.121Z</updated>
  <id>http://cjx_0723.gitee.io/</id>
  
  <author>
    <name>Ther</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高级软件工程</title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%AB%98%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%AB%98%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</id>
    <published>2023-10-30T14:04:29.121Z</published>
    <updated>2023-10-30T14:04:29.121Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="一、软件工程概述"><a href="#一、软件工程概述" class="headerlink" title="一、软件工程概述"></a>一、软件工程概述</h1><p>软件工程的难点：</p><ol><li>适合的解决方式来解决用户需求</li><li>高质量代码</li><li>时间与金钱成本必须是可预测且可控的</li></ol><p>好的软件如何度量：好的软件需要传递用户需要的功能性和表现，应该是可维护、可靠和可用的。</p><p>敏捷编程的用户故事：让用户参与到故事之中，即用户与机器的交互的场景，根据交互来进行编程。</p><h2 id="1-1-软件工程"><a href="#1-1-软件工程" class="headerlink" title="1.1 软件工程"></a>1.1 软件工程</h2><p>追求开发高质量软件</p><h2 id="1-2-SaaS"><a href="#1-2-SaaS" class="headerlink" title="1.2 SaaS"></a>1.2 SaaS</h2><p>Software as a Service<br>SaaS通过运行在客户端上的瘦程序（即程序本身没有多少功能，其功能调用API获取），访问在Internet上的服务形式提供的软件。</p><p>SaaS的优势：</p><ol><li>无需安装，不需要担心硬件和OS差异</li><li>无需担心数据丢失</li><li>便于数据的分享</li><li>软件单一拷贝，单一部署硬件&#x2F;软件环境</li></ol><p>SaaS开发的框架&#x2F;语言：Spring&#x2F;Java，Django&#x2F;Python，Rails&#x2F;Ruby，Ruby是一种现代动态脚本编程语言 ，拥有面向对象、函数式、自动内存管理等</p><p>SaaS依赖的基础设施：</p><ol><li>通讯：允许客户与服务交互</li><li>可扩展性：需求波动可以满足 + 新服务快速引入</li><li>可靠性：服务和通性 7 x 24 小时可用</li></ol><h2 id="1-3-面向服务的架构"><a href="#1-3-面向服务的架构" class="headerlink" title="1.3 面向服务的架构"></a>1.3 面向服务的架构</h2><p>面向服务的架构（Service Oriented Architecture），称SOA即所有组件都设计为服务，且服务可用组合的软件架构。每一个子系统都是独立的，就像独立的数据中心中一样。<br>竖井式架构（Silo Architecture）：内部子系统可用直接共享数据，所有子系统都在单一的API中。</p><p>SOA主要通过重用来提高开发人员的生产力，任何SOA服务器都不能直接调用其他服务器中的数据，只能够调用其他服务器系统中提供的API来实现功能的交互。SOA提高了系统分解的能力，使得系统开发更为规范化、结构化。<br>相较于Silo模式，SOA模式服务之间的调用经过网络调用，其性能会受到网络波动的影响，二Silo模式数据调用直接在进程间执行，性能更好。SOA与Silo性能的差距，可以使用缓存来缩小。</p><h2 id="1-4-云计算（Cloud-Computation）"><a href="#1-4-云计算（Cloud-Computation）" class="headerlink" title="1.4 云计算（Cloud Computation）"></a>1.4 云计算（Cloud Computation）</h2><p>集群：由普通以太网联结的普通交换机，其具有下面特点：</p><ol><li>具有更好的可伸缩性</li><li>使用冗余来实现可靠性</li></ol><h2 id="1-5-软件质量"><a href="#1-5-软件质量" class="headerlink" title="1.5 软件质量"></a>1.5 软件质量</h2><p>验证（Verification）：你构建的东西正确吗？是否符合规范？<br>校验（Validation）：你构建的是对的东西吗？是客户想要的吗？</p><h1 id="二、软件过程"><a href="#二、软件过程" class="headerlink" title="二、软件过程"></a>二、软件过程</h1><h2 id="2-1-P-amp-D软件过程"><a href="#2-1-P-amp-D软件过程" class="headerlink" title="2.1 P&amp;D软件过程"></a>2.1 P&amp;D软件过程</h2><p>计划与文档（P&amp;D）：<br>– 编码前，项目经理制定计划<br>– 撰写计划各阶段的详细文档<br>– 根据计划来度量进展<br>– 项目的变更必须反映在文档中，并可能反映在计<br>划中<br>瀑布式开发模型<br>螺旋模型<br>瀑布模型 + 原型<br>Rational统一软件开发过程</p><p>RUP有下面四个阶段：</p><ol><li>初始阶段</li><li>精化阶段</li><li>构建阶段</li><li>迁移阶段<br>P&amp;D项目经理<br>P&amp;D依赖于项目经理<br>P&amp;D</li></ol><h1 id="三、Ruby程序设计语言"><a href="#三、Ruby程序设计语言" class="headerlink" title="三、Ruby程序设计语言"></a>三、Ruby程序设计语言</h1><h2 id="3-1-初识Ruby"><a href="#3-1-初识Ruby" class="headerlink" title="3.1 初识Ruby"></a>3.1 初识Ruby</h2><p><strong>Ruby</strong>的特性：</p><ul><li><p>Ruby是一种高级程序设计语言</p></li><li><p>Ruby是一种面向对象的语言</p></li><li><p>Ruby是一种解释型语言（例如Python），通过解释器边解释边执行。</p></li><li><p>Ruby是一种动态类型、强类型语言。</p></li><li><ul><li>静态类型与动态类型：变量是否可以引用所有变量类型，是则是动态类型。</li><li>强类型与弱类型：是否存在不同类型变量进行隐式转换，允许则是弱类型。</li></ul></li><li><p>Ruby允许元编程。</p></li></ul><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://cache.ruby-lang.org/pub/ruby/2.4/ruby-2.4.5.tar.gz</span><br><span class="line">tar -xzvf ruby2.4.5</span><br><span class="line"><span class="built_in">cd</span> ruby2.4.5</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="3-2-Ruby基础"><a href="#3-2-Ruby基础" class="headerlink" title="3.2 Ruby基础"></a>3.2 Ruby基础</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>在 Ruby 中，您可以使用以下方式添加注释：</p><ol><li>单行注释：使用 <code>#</code> 符号在一行的开头添加注释。该行后的任何内容都将被视为注释。</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个单行注释</span></span><br><span class="line">puts <span class="string">&quot;Hello, World!&quot;</span> <span class="comment"># 这是另一个单行注释</span></span><br></pre></td></tr></table></figure><ol start="2"><li>多行注释：使用 <code>=begin</code> 和 <code>=end</code> 来包围多行注释。</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">=begin</span></span><br><span class="line"><span class="comment">这是一个多行注释</span></span><br><span class="line"><span class="comment">这里可以写多行注释内容</span></span><br><span class="line"><span class="comment">=end</span></span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br></pre></td></tr></table></figure><p>请注意，Ruby 中的注释只是在代码执行过程中被忽略的文本，用于提供代码的解释、说明和文档。它们不会被编译或执行。注释对于帮助其他开发人员理解您的代码以及对代码进行调试和维护非常有用。</p><hr><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>在 Ruby 中，可以使用以下方式定义变量：</p><ol><li><strong>局部变量</strong>（Local Variables）：局部变量以小写字母或下划线开头。它们的作用域限制在当前的代码块或方法中。</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line">_count = <span class="number">10</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>实例变量</strong>（Instance Variables）：实例变量以 <code>@</code> 符号开头。它们的作用域限制在当前对象的实例中。</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@name</span> = <span class="string">&quot;Alice&quot;</span></span><br><span class="line"><span class="variable">@age</span> = <span class="number">25</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>类变量</strong>（Class Variables）：类变量以 <code>@@</code> 符号开头。它们的作用域限制在当前类及其子类中。</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@@count</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>全局变量</strong>（Global Variables）：全局变量以 <code>$</code> 符号开头。它们的作用域在整个 Ruby 程序中都是可见的。</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$global_variable</span> = <span class="string">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure><ol start="5"><li><strong>常量</strong>（Constants）：常量以大写字母开头。它们的值在定义后不能被改变，常量不能在方法（函数）中定义。</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">PI</span> = <span class="number">3.14159</span></span><br><span class="line"><span class="variable constant_">MAX_VALUE</span> = <span class="number">100</span></span><br></pre></td></tr></table></figure><ol start="6"><li><strong>伪变量</strong>：伪变量不是真正的变量，其无法被重新赋值，但是可以获取当前某些属性。</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="variable language_">self</span>：表示当前对象的引用。在类定义中，<span class="variable language_">self</span>指的是类本身；在实例方法中，<span class="variable language_">self</span>指的是调用该方法的对象；在类方法中，<span class="variable language_">self</span>指的是类本身。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. <span class="literal">true</span>、<span class="literal">false</span>和<span class="literal">nil</span>：表示布尔值和空值。<span class="literal">true</span>表示真，<span class="literal">false</span>表示假，<span class="literal">nil</span>表示空值。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. <span class="variable constant_">__FILE__</span>：表示当前文件的文件名。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. <span class="variable constant_">__LINE__</span>：表示当前代码所在的行号。</span><br></pre></td></tr></table></figure><p>请注意，变量在使用之前需要先进行初始化，可以直接赋值或通过其他方式进行赋值。变量名应具有描述性且易于理解，以提高代码的可读性。</p><hr><h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><p>在 Ruby 中，你可以使用 <code>def</code> 关键字来定义方法。以下是定义方法的基本语法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def 方法名(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)</span><br><span class="line">  <span class="comment"># 方法体</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在上面的语法中，<code>def</code> 关键字用于声明方法的开始，后面紧跟方法名和参数列表。参数列表是可选的，你可以根据需要在括号中列出方法的参数。方法体是方法的实际代码，它包含在 <code>def</code> 和 <code>end</code> 关键字之间。</p><p>下面是一个简单的示例，展示如何定义一个接受参数并打印输出的方法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>)</span><br><span class="line">  puts <span class="string">&quot;Hello, <span class="subst">#&#123;name&#125;</span>!&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>你可以调用定义的方法，方法调用将执行方法体中的代码。调用方法时，你需要提供方法所需的参数。例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">greet(<span class="string">&quot;Alice&quot;</span>)</span><br></pre></td></tr></table></figure><p>上述代码将调用 <code>greet</code> 方法，并将字符串 “Alice” 作为参数传递给它。方法将输出 “Hello, Alice!”。</p><p>Ruby方法可以返回参数值使用关键字<code>return</code>，后跟要返回的值。以下是一个示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_numbers</span>(<span class="params">a, b</span>)</span><br><span class="line">  sum = a + b</span><br><span class="line">  <span class="keyword">return</span> sum</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">result = add_numbers(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">puts result <span class="comment"># 输出：7</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>Ruby方法的最后一个表达式的值将被默认作为返回值</strong>，因此在上面的例子中，可以省略<code>return</code>关键字，直接使用<code>sum</code>作为返回值：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_numbers</span>(<span class="params">a, b</span>)</span><br><span class="line">  sum = a + b</span><br><span class="line">  sum</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>当定义方法时，你可以为<strong>参数提供默认值</strong>，这样在调用方法时，如果没有提供相应的参数值，就会使用默认值。你可以使用以下语法来指定默认参数：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def 方法名(参数<span class="number">1</span> = 默认值<span class="number">1</span>, 参数<span class="number">2</span> = 默认值<span class="number">2</span>, ...)</span><br><span class="line">  <span class="comment"># 方法体</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>默认参数的定义放在参数列表中，使用等号 <code>=</code> 后跟默认值。如果调用方法时没有为参数提供值，那么默认值将被使用。以下是一个使用默认参数的示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name = <span class="string">&quot;Guest&quot;</span></span>)</span><br><span class="line">  puts <span class="string">&quot;Hello, <span class="subst">#&#123;name&#125;</span>!&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>greet</code> 方法的 <code>name</code> 参数有一个默认值 “Guest”。如果调用方法时没有传递参数，将使用默认值 “Guest”。例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greet(<span class="string">&quot;Alice&quot;</span>)  <span class="comment"># 输出 &quot;Hello, Alice!&quot;</span></span><br><span class="line">greet          <span class="comment"># 输出 &quot;Hello, Guest!&quot;</span></span><br></pre></td></tr></table></figure><p>另外，Ruby 还支持<strong>可变参数</strong>，这意味着你可以在方法定义中接受不确定数量的参数。你可以在参数名前加上 <code>*</code> 来指定可变参数。在方法体内，可变参数将作为数组进行处理。以下是一个使用可变参数的示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">*numbers</span>)</span><br><span class="line">  total = <span class="number">0</span></span><br><span class="line">  numbers.each <span class="keyword">do</span> |<span class="params">num</span>|</span><br><span class="line">    total += num</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  total</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>sum</code> 方法接受任意数量的参数，并将它们相加得到总和。你可以传递任意数量的参数给方法，它们将作为数组 <code>numbers</code> 在方法体内使用。例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">puts sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 输出 6</span></span><br><span class="line">puts sum(<span class="number">4</span>, <span class="number">5</span>)     <span class="comment"># 输出 9</span></span><br><span class="line">puts sum(<span class="number">6</span>)        <span class="comment"># 输出 6</span></span><br><span class="line">puts sum           <span class="comment"># 输出 0</span></span><br></pre></td></tr></table></figure><p>此外，Ruby 还提供了块（Block）的概念，它是一种用于传递代码的结构。你可以使用块来扩展方法的功能，使其更加灵活。在方法定义中，可以使用 <code>yield</code> 关键字来调用块。以下是一个使用块的示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process</span></span><br><span class="line">  puts <span class="string">&quot;Start&quot;</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">if</span> block_given?</span><br><span class="line">  puts <span class="string">&quot;End&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>process</code> 方法在执行时，会先输出 “Start”，然后调用块（如果有提供块），最后输出 “End”。你可以在调用方法时传递一个块，块中的代码将在 <code>yield</code> 处执行。例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process <span class="keyword">do</span></span><br><span class="line">  puts <span class="string">&quot;Processing...&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上述代码将输出：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Start</span></span><br><span class="line"><span class="title class_">Processing</span>...</span><br><span class="line"><span class="title class_">End</span></span><br></pre></td></tr></table></figure><hr><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>Ruby和大多数语言一样，常用的循环结构有<code>while</code>, <code>do...while</code>, <code>until</code>和<code>for</code>循环四种。</p><p>下面，我们一一讲述这四种循环结构的使用方法。</p><h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a><code>while</code>语句</h4><p>Ruby中的循环用于执行相同的代码块若干次。当我们在开发中需要重复的做某个事情的时候，你就要想到循环了，接下来我们就来看看<code>while</code>循环是怎么使用的吧！</p><p><code>while</code>的基本语法是：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> conditional [<span class="keyword">do</span> \ <span class="symbol">:</span>]</span><br><span class="line">  code</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>当 <code>conditional</code> 为<code>True</code>时，执行 <code>code</code>。</p><p>语法中 <code>do</code> 或 <code>:</code> 可以省略不写。但若要在<strong>一行内</strong>写出 <code>while</code> 式，则必须以 <code>do</code> 或 <code>:</code> 隔开条件式或程序区块。</p><p>其流程图如下：</p><p><img src="https://data.educoder.net/api/attachments/191802" alt="img"></p><p>下面我们给出一个实例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">num = <span class="number">5</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= num  <span class="keyword">do</span></span><br><span class="line">  puts(<span class="string">&quot;我们爬了<span class="subst">#&#123;i&#125;</span>层楼&quot;</span> )</span><br><span class="line">  i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们爬了<span class="number">1</span>层楼</span><br><span class="line">我们爬了<span class="number">2</span>层楼</span><br><span class="line">我们爬了<span class="number">3</span>层楼</span><br><span class="line">我们爬了<span class="number">4</span>层楼</span><br><span class="line">我们爬了<span class="number">5</span>层楼</span><br></pre></td></tr></table></figure><p>当条件<code>i &lt;= num</code>为<code>True</code>时，代码块一直被执行，直到第6次循环时，<code>i = 6</code>不满足条件<code>i &lt;= num</code>，程序跳出循环，停止执行。</p><p>接下来我们了解<code>do...while</code>循环和<code>while</code>循环有什么不同。</p><h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do...while循环"></a><code>do...while</code>循环</h4><p>Ruby <code>do...while</code>循环遍历程序。它与<code>while</code>循环语法非常相似，唯一的区别是<code>do...while</code>循环将<strong>至少执行一次</strong>。 这是因为在<code>do...while</code>循环中，条件写在代码的末尾。</p><p><code>do...while</code>语法如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">  code</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span> conditional</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">code <span class="keyword">while</span> condition</span><br></pre></td></tr></table></figure><p>其流程图为：</p><p><img src="https://data.educoder.net/api/attachments/191804" alt="do...while循环流程图"></p><p>可以看出，<code>code</code>代码段先执行一次后，转入<code>conditional</code>代码判断条件是否为<code>True</code>。给出一段<code>do...while</code>循环结构的实例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  puts(<span class="string">&quot;在循环语句中 i = <span class="subst">#&#123;i&#125;</span>&quot;</span> )</span><br><span class="line">  i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span> i &lt; num</span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在循环语句中 i = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>通过上述两个实例，你应该能够很好的理解<code>while</code>循环和<code>do...while</code>循环之间的区别了。接下来，我们了解<code>for</code>循环结构。</p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><code>for</code>循环</h4><p>Ruby <code>for</code> 循环遍历特定的数字范围。 因此，如果程序具有固定次数的迭代，则使用 <code>for</code> 循环。 Ruby <code>for</code> 循环将在表达式中的每个元素执行一次。</p><p>其语法如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> variable [, variable ...] <span class="keyword">in</span> expression [<span class="keyword">do</span>]</span><br><span class="line">  code</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>for</code>循环针对 <code>expression</code> 中的每个元素分别执行一次 <code>code</code>。</p><p>下面我们提供一个使用<code>for</code>循环遍历数组的实例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="string">&quot;红&quot;</span>, <span class="string">&quot;绿&quot;</span>, <span class="string">&quot;蓝&quot;</span>, <span class="string">&quot;黄&quot;</span>, <span class="string">&#x27;五颜六色&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x <span class="keyword">do</span></span><br><span class="line">  puts i</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>该实例的输出结果为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">红<span class="string">` `</span>绿<span class="string">` `</span>蓝<span class="string">` `</span>黄<span class="string">` `</span>五颜六色</span><br></pre></td></tr></table></figure><p>最后我们来了解<code>until</code>循环结构。</p><h4 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a><code>until</code>循环</h4><p>在Ruby中，<code>until</code>循环和<code>while</code>循环很相似又很不相似，他们就像一对欢喜冤家，<code>while</code>循环是当<code>conditional</code>为<code>True</code>时进入循环，而<code>untile</code>循环是当<code>conditional</code>为<code>False</code>时进入循环。</p><p>其语法为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">until</span> conditional [<span class="keyword">do</span>]</span><br><span class="line">  code</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>当 <code>conditional</code> 为<code>False</code>时，执行 <code>code</code>。</p><p>语法中 <code>do</code> 可以省略不写。但若要在一行内写出 <code>until</code> 式，则必须以 <code>do</code> 隔开条件式或程序区块。</p><p>我们也提供一个实例，以供你查看其与<code>while</code>循环的不同之处：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">num = <span class="number">5</span></span><br><span class="line"><span class="keyword">until</span> i &gt; num  <span class="keyword">do</span></span><br><span class="line">  puts(<span class="string">&quot;我们爬了<span class="subst">#&#123;i&#125;</span>层楼&quot;</span> )</span><br><span class="line">  i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>该实例的输出结果为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们爬了<span class="number">1</span>层楼</span><br><span class="line">我们爬了<span class="number">2</span>层楼</span><br><span class="line">我们爬了<span class="number">3</span>层楼</span><br><span class="line">我们爬了<span class="number">4</span>层楼</span><br><span class="line">我们爬了<span class="number">5</span>层楼</span><br></pre></td></tr></table></figure><p>我们可以看出，当我们将<code>conditional</code>改为<code>i &gt; num</code>，与<code>i &lt;= num</code>刚好相反时，程序给出了同样的输出，这样也证明了<code>while</code>循环和<code>until</code>循环是一对刚好相反的循环结构。</p><p>在下一小节讲述完Ruby中的条件判断语句后，我们继续了解三种在循环中经常使用的语句，<code>break</code>语句，<code>next</code>语句和<code>redo</code>语句。</p><hr><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a><code>if</code>语句</h4><p><code>if</code>语句的语法为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">  code</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>if</code>语句测试条件<code>condition</code>。如果<code>condition</code>为<code>true</code>，则执行<code>code</code>。</p><p>其流程图如下：</p><p><img src="https://data.educoder.net/api/attachments/191810" alt="if语句流程图"></p><p>我们提供一个实例来具体讲解<code>if</code>语句：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">0</span></span><br><span class="line">condition = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> num == condition</span><br><span class="line">  puts <span class="string">&quot;In Condition&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">puts <span class="string">&quot;Out Condition&quot;</span></span><br></pre></td></tr></table></figure><p>该实例的输出结果为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Out</span> <span class="title class_">Condition</span></span><br></pre></td></tr></table></figure><p>从实例中我们很明显的看出<code>if</code>语句的条件不满足，所以直接执行<code>after_if_code</code>，输出一条语句。</p><h4 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a><code>if-else</code>语句</h4><p>非黑即白，这句话在Ruby中也适用，我们可以使用<code>if-else</code>语句来实现非黑即白的功能，其语法如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1 [<span class="keyword">then</span>]</span><br><span class="line">  code1</span><br><span class="line">[<span class="keyword">elsif</span> condition2 [<span class="keyword">then</span>]</span><br><span class="line">  code2]...</span><br><span class="line">[<span class="keyword">else</span></span><br><span class="line">  code3]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>if</code>表达式用于条件执行。值 <code>false</code> 和 <code>nil</code> 为<strong>假</strong>，其他值都为<strong>真</strong>。请注意，</p><blockquote><p>Ruby 使用 <code>elsif</code>，不是使用 <code>else if</code> 和 <code>elif</code>。</p></blockquote><p>如果 <code>condition</code> 为真，则执行 <code>code</code>。如果 <code>condition</code>不为真，则执行 <code>else</code> 子句中指定的 <code>code</code>。</p><p>通常我们省略保留字 <code>then</code> 。若想在<strong>一行内</strong>写出完整的 <code>if</code> 式，则<strong>必须</strong>以 <code>then</code> 隔开条件式和程序区块。如下所示:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a == <span class="number">1</span> <span class="keyword">then</span> a = <span class="number">0</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>说了这么多，我们来一个实例了解一下<code>if-else</code>语句吧！</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">2</span></span><br><span class="line">  puts <span class="string">&quot;x 大于 2&quot;</span></span><br><span class="line"><span class="keyword">elsif</span> x &lt;= <span class="number">2</span> <span class="keyword">and</span> x != <span class="number">0</span></span><br><span class="line">  puts <span class="string">&quot;x 是 1&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  puts <span class="string">&quot;无法得知 x 的值&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>以上实例的输出结果为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x 是 <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们来解读一下这段代码的执行过程：</p><ul><li><code>x = 1</code>不满足<code>x &gt; 2</code>的条件，<code>if</code>条件判断失败，进入<code>else</code>对应的<code>code</code></li><li>由于具有<code>if</code>嵌套，故继续判断<code>elsif</code>条件是否满足，<code>x = 1</code>满足<code>x &lt;= 2 and x != 0</code>，进入对应的<code>code</code>段，输出<code>x 是 1</code></li><li>程序跳出<code>if</code>语句，程序结束</li></ul><h4 id="unless语句"><a href="#unless语句" class="headerlink" title="unless语句"></a><code>unless</code>语句</h4><p>与<code>while</code>循环和<code>until</code>循环一样，在条件判断语句中，也有这样一对“死对头”，这就是<code>if</code>语句和<code>unless</code>语句。<code>unless</code>语句的基本语法是：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unless</span> condition [<span class="keyword">then</span>]</span><br><span class="line">  code1</span><br><span class="line">[<span class="keyword">else</span></span><br><span class="line">  code2 ]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果 <code>condition</code> 为假，则执行 <code>code1</code>。如果 <code>condition</code> 为真，则执行 <code>else</code> 子句中对应的 <code>code2</code>。</p><p>其流程图如下：</p><p><img src="https://data.educoder.net/api/attachments/191819" alt="unless语句流程图"></p><p>你可以在<code>irb</code>中亲自尝试这一语句，但我们<strong>不推荐</strong>使用这一语句，因为使用<code>unless</code>语句会<strong>大大降低程序的可读性</strong>，如果不是业务需要，请尽量使用<code>if</code>语句替代<code>unless</code>语句。</p><h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a><code>case</code>语句</h4><p>最后我们还要介绍一种强大的条件判断语句，<code>case</code>语句。其基本语法为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> expression</span><br><span class="line">[<span class="keyword">when</span> condition [, condition ...] [<span class="keyword">then</span>]</span><br><span class="line">   code1 ]...</span><br><span class="line">[<span class="keyword">else</span></span><br><span class="line">   code2 ]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><code>case</code> 语句先对一个 <code>expression</code> 进行匹配判断，然后根据匹配结果进行分支选择。</p><p>它使用 <code>===</code> 运算符比较 <code>when</code> 指定的 <code>condition</code>，若一致的话就执行 <code>when</code> 部分的内容。</p><p>通常我们省略保留字 <code>then</code> 。若想在<strong>一行内</strong>写出完整的 <code>when</code> 式，则<strong>必须</strong>以 <code>then</code> 隔开条件式和程序区块。如下所示:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> a == <span class="number">1</span> <span class="keyword">then</span> a = <span class="number">0</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>因此一段<code>case</code>代码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> expr0</span><br><span class="line"><span class="keyword">when</span> cond1, cond2</span><br><span class="line">   code1</span><br><span class="line"><span class="keyword">when</span> cond3, cond4</span><br><span class="line">   code2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   code3</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_tmp = expr0</span><br><span class="line"><span class="keyword">if</span> cond1 === _tmp |<span class="params"></span>| cond2 === _tmp</span><br><span class="line">   code1</span><br><span class="line"><span class="keyword">elsif</span> cond3 === _tmp |<span class="params"></span>| cond4 === _tmp</span><br><span class="line">   code2</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   code3</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>我们通过一段判断商品价格的程序来深入了解<code>case</code>语句：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">price = <span class="number">85</span></span><br><span class="line"><span class="keyword">case</span> price</span><br><span class="line"><span class="keyword">when</span> <span class="number">0</span>..<span class="number">10</span></span><br><span class="line">  puts <span class="string">&quot;便宜&quot;</span></span><br><span class="line"><span class="keyword">when</span> <span class="number">11</span>..<span class="number">50</span></span><br><span class="line">  puts <span class="string">&quot;普通&quot;</span></span><br><span class="line"><span class="keyword">when</span> <span class="number">51</span>..<span class="number">100</span></span><br><span class="line">  puts <span class="string">&quot;稍贵&quot;</span></span><br><span class="line"><span class="keyword">when</span> <span class="number">101</span>...<span class="number">1000</span></span><br><span class="line">  puts <span class="string">&quot;贵&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  puts <span class="string">&quot;很贵&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>以上实例的输出结果为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">稍贵</span><br></pre></td></tr></table></figure><p>通常来说，如果我们需要使用到多个判断语句或者细分判断逻辑，我们<strong>推荐使用</strong><code>case</code>语句，使用<code>case</code>语句有助于美化代码结构，加快代码执行。</p><p>到这里我们就已经介绍完了常见的条件判断语句了，接下来我们补充一下上一小节我们提到的三种常见的控制语句。</p><ul><li><code>break</code> 语句 该语句用来终止最内层的循环。通常配合<code>if</code>语句使用，在某一条件下跳出循环，进行外层操作。</li><li><code>next</code> 语句 该语句用来跳到循环的下一个迭代。通常配合<code>if</code>语句使用，在某一条件下跳过本次迭代的剩余部分，直接执行下一迭代。</li><li><code>redo</code> 语句 该语句用来重新开始最内部循环的该次迭代，并不予检查循环条件。相当于重新执行一遍本次迭代。</li></ul><hr><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>在Ruby中，异常处理是一种用于处理错误和异常情况的机制。当程序发生错误或遇到无法处理的情况时，会引发异常。以下是Ruby中异常处理的基本概念和用法。</p><ol><li><strong>抛出异常</strong>（Raise Exception）：<br>   在Ruby中，可以使用<code>raise</code>关键字抛出异常。<code>raise</code>语句通常包含一个异常类（可以是内置的异常类或自定义的异常类）和一个可选的错误消息。</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> <span class="title class_">ExceptionClass</span>, <span class="string">&quot;Error message&quot;</span></span><br></pre></td></tr></table></figure><p>例如，下面的代码抛出一个<code>RuntimeError</code>异常：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> <span class="title class_">RuntimeError</span>, <span class="string">&quot;Something went wrong&quot;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>捕获异常</strong>（Catch Exception）：<br>可以使用<code>begin</code>和<code>rescue</code>关键字来捕获异常。<code>begin</code>块中的代码被监视，如果发生异常，会跳转到<code>rescue</code>块，并执行相关的处理代码。</li></ol><p><code>rescue</code> 块可以捕获特定类型的异常，也可以使用<code>Exception</code>来捕获所有类型的异常。</p><p>例如，下面的代码捕获<code>RuntimeError</code>异常并进行处理：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">     <span class="comment"># 可能会引发异常的代码</span></span><br><span class="line"><span class="keyword">rescue</span> <span class="title class_">RuntimeError</span> =&gt; e</span><br><span class="line">     puts <span class="string">&quot;Error occurred: <span class="subst">#&#123;e.message&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>处理多个异常</strong>：<br>可以在<code>rescue</code>块中处理多个异常，每个异常使用不同的<code>rescue</code>子句。</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">     <span class="comment"># 可能会引发异常的代码</span></span><br><span class="line"><span class="keyword">rescue</span> <span class="title class_">ExceptionClass1</span></span><br><span class="line">     <span class="comment"># 处理异常的代码</span></span><br><span class="line"><span class="keyword">rescue</span> <span class="title class_">ExceptionClass2</span></span><br><span class="line">     <span class="comment"># 处理异常的代码</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p> 例如，下面的代码捕获<code>RuntimeError</code>和<code>ArgumentError</code>两种异常：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">     <span class="comment"># 可能会引发异常的代码</span></span><br><span class="line"><span class="keyword">rescue</span> <span class="title class_">RuntimeError</span></span><br><span class="line">     <span class="comment"># 处理 Runtime Error 的代码</span></span><br><span class="line"><span class="keyword">rescue</span> <span class="title class_">ArgumentError</span></span><br><span class="line">     <span class="comment"># 处理 Argument Error 的代码</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>最终处理</strong>（Ensure）：<br>可以使用<code>ensure</code>关键字定义一个最终处理块，其中的代码无论是否发生异常都会执行。</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">     <span class="comment"># 可能会引发异常的代码</span></span><br><span class="line"><span class="keyword">rescue</span> <span class="title class_">ExceptionClass</span></span><br><span class="line">     <span class="comment"># 处理异常的代码</span></span><br><span class="line">     <span class="keyword">ensure</span></span><br><span class="line">     <span class="comment"># 最终处理的代码</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p> 例如，下面的代码无论是否发生异常，都会执行最终处理块中的代码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">     <span class="comment"># 可能会引发异常的代码</span></span><br><span class="line"><span class="keyword">rescue</span> <span class="title class_">RuntimeError</span> =&gt; e</span><br><span class="line">     puts <span class="string">&quot;Error occurred: <span class="subst">#&#123;e.message&#125;</span>&quot;</span></span><br><span class="line">     <span class="keyword">ensure</span></span><br><span class="line">     puts <span class="string">&quot;Final processing&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这些是Ruby中异常处理的基本概念和用法。通过使用<code>raise</code>抛出异常，<code>begin</code>、<code>rescue</code>和<code>ensure</code>来捕获和处理异常，可以有效地处理错误和异常情况，提高程序的健壮性和可靠性.</p><hr><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>在讲述迭代器概念前，我们先讲述另一个概念，块（<code>block</code>）。</p><h4 id="块（block）"><a href="#块（block）" class="headerlink" title="块（block）"></a>块（<code>block</code>）</h4><p>块就是指一块代码，在这个块中我们可以实现若干功能，当块不传入参数时，其就是执行一段代码，而当这个块传入了参数时可以将它看作一个方法调用。块是一个非常强大的模块。您可以使用块来实现回调（但它们比Java匿名内部类更简单），并实现迭代器。</p><p>块只是括号 <code>&#123;&#125;</code> 之间或<code>do</code>和<code>end</code>之间的代码块。</p><p>例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; puts <span class="string">&quot;Hello&quot;</span> &#125; <span class="comment"># 块的一种方式</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  club.enroll(person) <span class="comment"># 块的另一种方式</span></span><br><span class="line">  person.socialize</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>按照Ruby的代码规范，如果块中只包含一行代码，则我们使用大括号 <code>&#123;&#125;</code>将其包住，如果块中包含多行代码，我们则使用<code>do\end</code>块来实现。</p><p>一旦你创建了一个块之后，你就可以将其视为一个方法调用。你可以通过将块放在你需要调用块的代码行末尾来实现。</p><p>除此之外，通过使用<code>yield</code>声明，块还可以被多次调用，你可以将<code>yield</code>声明看作一个方法调用，调用在这个块外的一段代码。例如下面这段代码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">call_block</span></span><br><span class="line">  puts <span class="string">&quot;Start of method&quot;</span></span><br><span class="line">  <span class="keyword">yield</span></span><br><span class="line">  <span class="keyword">yield</span></span><br><span class="line">  puts <span class="string">&quot;End of method&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">call_block &#123; puts <span class="string">&quot;In the block&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>执行<code>call_block</code>方法的输出结果为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Start</span> of method</span><br><span class="line"><span class="title class_">In</span> the block</span><br><span class="line"><span class="title class_">In</span> the block</span><br><span class="line"><span class="title class_">End</span> of method</span><br></pre></td></tr></table></figure><p>每一个<code>yield</code>都调用了一次块外的代码块，你还可以给<code>yield</code>传输参数，来实现不同的功能，语法如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">call_block</span></span><br><span class="line">  <span class="keyword">yield</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">99</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">call_block &#123;|<span class="params">str, num</span>| ... &#125;</span><br></pre></td></tr></table></figure><h4 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（<code>Iterator</code>）</h4><p>不断重复的工作我们叫做迭代，在Ruby中用来执行重复多次相同的事的就是迭代器（<code>Iterator</code>）！</p><ul><li>一个Ruby迭代器就是一个简单的能接收代码块的方法（比如<code>each</code>这个方法就是一个迭代器）。特征：如果一个方法里包含了<code>yield</code>调用，那这个方法肯定是迭代器</li><li>迭代器方法和块之间有如下传递关系：块被当成一个特殊参数传给迭代器方法，而迭代器方法内部在使用<code>yield</code>调用代码块时可将参数值传入块</li><li>Ruby中的<strong>容器对象</strong>（如上一实训中我们介绍的<code>Array</code>、<code>Range</code>和<code>Hash</code>对象等）都包含了两个简单的迭代器:<ul><li><code>each</code>：最简单的迭代器，它会对<strong>容器对象</strong>的每个元素调用<strong>块</strong></li><li><code>collect</code>：将<strong>容器对象</strong>中的元素传递给<strong>块</strong>，在<strong>块</strong>中处理后返回一个包含处理结果的<strong>新</strong>数组（<code>Array</code>）</li></ul></li></ul><p><strong><code>each</code>迭代器</strong></p><p>下面我们先从数组（<code>Array</code>）迭代器开始，这是一段遍历数组中所有元素并将其输出的代码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.each &#123; |<span class="params">num</span>| puts num &#125;</span><br><span class="line"> <span class="comment"># num 是一个局部变量，each迭代器每一次迭代将数组中的一个元素赋值给 num</span></span><br></pre></td></tr></table></figure><p>行后，输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>以上这段代码我们使用到了最简单的迭代器<code>each</code>，我们下面介绍一个与<code>each</code>很相似的迭代器<code>each_with_index</code>。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">languages = [<span class="string">&#x27;Ruby&#x27;</span>, <span class="string">&#x27;Javascript&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>]</span><br><span class="line">languages.each_with_index <span class="keyword">do</span> |<span class="params">lang, index</span>|</span><br><span class="line">    puts <span class="string">&quot;<span class="subst">#&#123;index&#125;</span>, I love <span class="subst">#&#123;lang&#125;</span>!&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>执行后，输出为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>, I love <span class="title class_">Ruby</span>!</span><br><span class="line"><span class="number">1</span>, I love <span class="title class_">Javascript</span>!</span><br><span class="line"><span class="number">2</span>, I love <span class="title class_">Java</span>!</span><br></pre></td></tr></table></figure><p>我们可以发现新的迭代器<code>each_with_index</code>使用了两个参数<code>lang</code>和<code>index</code>，其中，<code>lang</code> 就是一个局部变量，其值为数组中的一个元素，<code>index</code>就是元素在数组中的下标。</p><p><strong><code>collect</code>迭代器</strong></p><p>介绍完<code>each</code>迭代器，我们来介绍一下<code>collect</code>迭代器的用法和作用。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">b = a.collect&#123; |<span class="params">x</span>| x * <span class="number">2</span> &#125;</span><br><span class="line">puts b.join(<span class="string">&#x27;,&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出为：<code>2,4,6,8,10</code></p><p>上述代码中，<code>collect</code>迭代器进行了如下操作：</p><ul><li>将数组<code>a</code>中的每一个元素都传递给了<strong>块</strong>（<code>&#123; |x| x * 2 &#125;</code>）</li><li>在<strong>块</strong>中进行了翻倍（<code>x * 2</code>）操作</li><li>在所有元素都处理完后，返回新数组<code>[2, 4, 6, 8, 10]</code></li></ul><p>Ruby中的迭代器千变万化，不同的数据类型有着不同的迭代器，不同数据类型的<code>each</code>和<code>collect</code>迭代器也有着不同的特性，了解他们的最好办法就是阅读<code>Ruby Doc</code>官方文档，并且在实践中去试验他们有着怎样的功能。</p><h2 id="3-3-Ruby数据类型"><a href="#3-3-Ruby数据类型" class="headerlink" title="3.3 Ruby数据类型"></a>3.3 Ruby数据类型</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a><strong>创建字符串</strong></h4><p>创建字符串的一种方法是在Ruby程序中使用<code>&#39;</code>或<code>&quot;</code>来创建所谓的字符串文字。我们已经在我们的<code>Hello World</code>程序中体验了这种方法。以下代码显示了<code>&#39;</code>和<code>&quot;</code>的用法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">puts <span class="string">&#x27;Hello world&#x27;</span></span><br><span class="line">puts <span class="string">&quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure><p>类似于Perl，Ruby中可以用<code>&#39;</code>或<code>&quot;</code>来创建字符串，但与C和Java语言不一样，他们使用<code>&quot;</code>来创建字符串，<code>&#39;</code>来创建单字符。</p><p>那么Ruby中使用<code>&#39;</code>和<code>&quot;</code>之间有什么区别呢？在上面的代码中是没有区别的。但是，请看下面的代码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">puts <span class="string">&quot;Betty&#x27;s pie shop&quot;</span></span><br><span class="line">puts <span class="string">&#x27;Betty\&#x27;s pie shop&#x27;</span></span><br></pre></td></tr></table></figure><p>因为<code>Betty&#39;s</code>中包含撇号，其符号和单引号一样，第二行需要使用反斜杠来转义撇号，使Ruby明白撇号是字符串而不是字符串结束标志。反斜杠后面的单引号被称为<strong>转义字符</strong>。</p><p>接下来，我们将讲述更多<code>&#39;</code>和<code>&quot;</code>创建字符串时的区别。</p><p>单引号<code>&#39;</code>只支持以下两种转义字符：</p><ul><li><code>\&#39;</code> – 一个单引号</li><li><code>\\</code> – 一个反斜杠</li></ul><p>除了这两种转义字符之外，单引号之间的所有内容都是按其字面意思进行处理的。</p><p>而双引号<code>&quot;</code>允许更多的转义字符。甚至<code>&quot;</code>还允许你在字符串文字中嵌入变量或Ruby代码 —— 这通常称为内插：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;Educoder&#x27;</span></span><br><span class="line">puts <span class="string">&quot;Hello, <span class="subst">#&#123;name&#125;</span>!&quot;</span></span><br></pre></td></tr></table></figure><hr><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a><strong>转义字符</strong></h4><p>上面引入了转义字符这个概念，接下来，我们列出一些可以使用在<code>&quot;</code>创建的字符串中的转义字符。</p><ul><li><code>\&quot;</code> – 一个双引号</li><li><code>\\</code> – 一个反斜杠</li><li><code>\a</code> – 蜂鸣声</li><li><code>\b</code> – 退格</li><li><code>\r</code> – 回车符</li><li><code>\n</code> – 换行符</li><li><code>\s</code> – 空格</li><li><code>\t</code> – tab</li></ul><hr><h4 id="字符串的常用方法"><a href="#字符串的常用方法" class="headerlink" title="字符串的常用方法"></a>字符串的常用方法</h4><p>按照上面的方法创建的字符串都是<code>String</code>的一个对象，有了这个对象，我们就可以使用字符串庞大的方法集来做我们想要的操作了！</p><p>下表列出了字符串的一些常用方法，包括方法的调用方式，方法的返回值类型以及方法的描述。(假设已创建名为<code>str</code>的字符串)</p><table><thead><tr><th>方法调用方式</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>str.length</code></td><td><code>Integer</code></td><td>字符串的长度，空字符串返回 0</td></tr><tr><td><code>str.include?(other_str)</code></td><td><code>True</code> 或 <code>False</code></td><td>字符串包含，传入的参数为另一个字符串，如果该字符串中包含该子串，则返回<code>True</code>，否则返回<code>False</code></td></tr><tr><td><code>str.insert(index, other_str)</code></td><td><code>new_str</code></td><td>字符串插入，参数<code>index</code>是待插入的下标，<code>other_str</code>是另一个字符串，返回的是插入后新的字符串，下标从 0 开始计算</td></tr><tr><td><code>str.split(pattern=$;, [limit])</code></td><td><code>Array</code></td><td>字符串分割，将字符串按照<code>pattern</code>进行分割，默认分割符为空格，返回值是一个包含若干字符串的数组</td></tr><tr><td><code>str.gsub(pattern, replacement)</code></td><td><code>new_str</code></td><td>字符串替换，将字符串按照<code>pattern</code>匹配的字符更换为<code>replacement</code>，返回替换后的字符串</td></tr><tr><td><code>str.replace(other_str)</code></td><td><code>other_str</code></td><td>字符串整体替换，将字符串整体替换成新的字符串</td></tr><tr><td><code>str.delete([other_str]+)</code></td><td><code>new_str</code></td><td>字符串删除，传入参数<code>[other_str]+</code>可包含多个字符，该方法匹配到<code>str</code>中的所有字符并删除，返回新的字符串</td></tr><tr><td><code>str.strip</code></td><td><code>new_str</code></td><td>清除空格，清除掉<code>str</code>中字符串前后的所有空格，换行符，回车符。不包含字符间的空格，返回新的字符串</td></tr><tr><td><code>str.reverse</code></td><td><code>reverse_str</code></td><td>字符串翻转，将字符串顺序翻转，返回翻转后的字符串</td></tr><tr><td><code>str.to_i</code></td><td><code>Integer</code></td><td>字符串转换为数字， 如果字符串以数字开头，则转换为开头数字的整型值，如果字符串不以数字开头，则返回 0</td></tr><tr><td><code>str.chomp</code></td><td><code>new_str</code></td><td>去掉字符串末尾的<code>\n</code>或<code>\r</code></td></tr><tr><td><code>str.chop</code></td><td><code>new_str</code></td><td>去掉字符串末尾的最后一个字符,不管是<code>\n</code>，<code>\r</code>还是普通字符</td></tr><tr><td><code>str.downcase</code></td><td><code>new_str</code></td><td>将字符串转换为全小写</td></tr><tr><td><code>str.upcase</code></td><td><code>new_str</code></td><td>将字符串转换为全大写</td></tr></tbody></table><p>接下来我们通过一小段程序来大致的了解一下这些方法的使用：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/ruby</span></span><br><span class="line">str1 = <span class="string">&quot;Edu Coder&quot;</span></span><br><span class="line">puts str1.downcase</span><br><span class="line">puts str1.upcase</span><br><span class="line">puts str1.length</span><br><span class="line">puts str1.<span class="keyword">include</span>?(<span class="string">&quot;Coder&quot;</span>)</span><br><span class="line">puts str1.split</span><br><span class="line">str2 = <span class="string">&quot;    Hello, Educoder!\n&quot;</span></span><br><span class="line">puts str2</span><br><span class="line">puts str2.strip</span><br><span class="line">new_str= str2.chomp</span><br><span class="line">puts new_str</span><br><span class="line">puts new_str.chop</span><br><span class="line">str3 = <span class="string">&quot;2018, New Year!&quot;</span></span><br><span class="line">puts str3.to_i</span><br><span class="line">puts str3.reverse</span><br><span class="line">puts str3.insert(<span class="number">5</span>, <span class="string">&quot;Happy&quot;</span>)</span><br><span class="line">puts str3.gsub(<span class="regexp">/[A-Za-z, ]/</span>, <span class="string">&quot;!&quot;</span>)</span><br><span class="line">puts str2.replace(<span class="string">&quot;Goodbye, 2017&quot;</span>)</span><br><span class="line">puts str3.delete(<span class="string">&quot;aeiou&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">edu coder                <span class="comment">#转换为全小写</span></span><br><span class="line"><span class="variable constant_">EDU</span> <span class="variable constant_">CODER</span>                <span class="comment">#转换为全大写</span></span><br><span class="line"><span class="number">9</span>                        <span class="comment">#字符长度为9</span></span><br><span class="line"><span class="literal">true</span>                     <span class="comment">#包含子串&quot;Coder&quot;</span></span><br><span class="line"><span class="title class_">Edu</span></span><br><span class="line"><span class="title class_">Coder</span>                    <span class="comment">#分割成两个字符，按序输出</span></span><br><span class="line">    <span class="title class_">Hello</span>, <span class="title class_">Educoder</span>!     <span class="comment">#原字符串</span></span><br><span class="line"><span class="title class_">Hello</span>, <span class="title class_">Educoder</span>!         <span class="comment">#去除掉前后所有空格，换行符，回车符</span></span><br><span class="line">    <span class="title class_">Hello</span>, <span class="title class_">Educoder</span>!     <span class="comment">#去除掉行尾换行符</span></span><br><span class="line">    <span class="title class_">Hello</span>, <span class="title class_">Educoder</span>      <span class="comment">#去除掉行尾一个字符</span></span><br><span class="line"><span class="number">2018</span>                     <span class="comment">#转换为字符串开头的数字</span></span><br><span class="line">!raeY weN ,<span class="number">8102</span>          <span class="comment">#字符串翻转</span></span><br><span class="line"><span class="number">2018</span>,<span class="title class_">Happy</span> <span class="title class_">New</span> <span class="title class_">Year</span>!     <span class="comment">#在第5个字符处插入 Happy</span></span><br><span class="line"><span class="number">2018</span>!!!!!!!!!!!!!!!!     <span class="comment">#将所有英文字符，空格，英文半角感叹号替换为英文半角感叹号</span></span><br><span class="line"><span class="title class_">Goodbye</span>, <span class="number">2017</span>            <span class="comment">#字符串整体替换</span></span><br><span class="line"><span class="number">2018</span>,<span class="title class_">Hppy</span> <span class="title class_">Nw</span> <span class="title class_">Yr</span>!         <span class="comment">#删除掉字符串中所有元音字母</span></span><br></pre></td></tr></table></figure><p>Tips: <code>chomp</code>方法针对<code>\r</code>，<code>\n</code>，<code>\r\n</code>，<code>\n\r</code>这四种字符有着不同的处理，在实训右侧的命令行窗口打开<code>irb</code>体验一下吧！</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>Ruby数组（<code>Array</code>）可存储诸如<code>String</code>、<code>Integer</code>、<code>Fixnum</code>、<code>Hash</code>、<code>Symbol</code> 等对象，甚至可以是其他<code>Array</code>对象，从而构建二维甚至多维数组。Ruby数组不像其他语言中的数组那么刚性，当向数组添加元素时，Ruby数组会自动增长。</p><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><p>有多种方式创建或初始化数组。一种方式是通过 <code>new</code> 方法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = <span class="title class_">Array</span>.new</span><br></pre></td></tr></table></figure><p>由于Ruby中数组的长度会随着元素的增加而增加，所以你不需要传递一个长度参数给<code>new</code>方法，<code>Ruby</code>也能创建一个空数组，当然你也可以加上长度参数，例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = <span class="title class_">Array</span>.new(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>上面这条语句将会创建出一个长度为5，内容值全为<code>nil</code>的数组，<code>[nil, nil, nil, nil, nil]</code>，记住<code>nil</code>也是一个值哦！</p><p>如果我们在创建数组时就想初始化数组的值，我们该怎么做呢？别担心，万能的Ruby也有办法帮你解决！</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = <span class="title class_">Array</span>.new(<span class="number">5</span>, <span class="string">&#x27;Educoder&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这样我们就能将数组内的值全部变为你传入的第二个参数<code>Educoder</code>了，就像这样<code>[&quot;Educoder&quot;, &quot;Educoder&quot;, &quot;Educoder&quot;, &quot;Educoder&quot;, &quot;Educoder&quot;]</code>。</p><p>相似的，还有两种方式，也是通过<code>Array</code>类来创建数组：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.[]( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ) <span class="comment">#=&gt; [1, 2, 3]Array[ 1, 2, 3 ]    #=&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>当然，我们还有更简便的方法来创建一个数组，那就是直接写出一个数组！</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">#=&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>一般的，我们都使用最后一种方式来创建数组。</p><p>通过<code>Range</code>对象，我们能够初始化一定范围的数组，例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Range 创建起始数字到结束数字的范围</span></span><br><span class="line">range = (<span class="number">1</span>..<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将范围转换为数组</span></span><br><span class="line"><span class="comment"># arr = [1,2,3,4]</span></span><br><span class="line">arr = range.to_a</span><br></pre></td></tr></table></figure><hr><h4 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h4><p>Ruby数组中的每个元素都与一个索引（<code>index</code>）相关，并可通过索引（<code>index</code>）进行获取。</p><p>数组的索引从 0 开始，这与C或Java中一样。一个负数的索引时相对于<strong>数组的末尾</strong>计数的，也就是说，索引为 -1 表示数组的最后一个元素，-2 表示数组中的倒数第二个元素，依此类推。</p><p>下面我们展示以下如何访问数组的元素：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">arr[<span class="number">2</span>]       <span class="comment">#=&gt; 3</span></span><br><span class="line">arr[<span class="number">100</span>]     <span class="comment">#=&gt; nil</span></span><br><span class="line">arr[-<span class="number">3</span>]      <span class="comment">#=&gt; 4</span></span><br><span class="line">arr[<span class="number">2</span>, <span class="number">3</span>]    <span class="comment">#=&gt; [3, 4]</span></span><br><span class="line">arr[<span class="number">1</span>..<span class="number">4</span>]    <span class="comment">#=&gt; [2, 3, 4, 5]</span></span><br><span class="line">arr[<span class="number">1</span>..-<span class="number">3</span>]   <span class="comment">#=&gt; [2, 3, 4]</span></span><br><span class="line">arr.at(<span class="number">0</span>)    <span class="comment">#=&gt; 1</span></span><br></pre></td></tr></table></figure><p>我们展示了4种访问数组元素的方式：</p><ul><li><p>直接输入索引法，<code>arr[index]</code>，如果该索引（<code>index</code>）存在，则返回数组在该索引（<code>index</code>）处的值，若不存在，则返回<code>nil</code>。</p></li><li><p>索引区间法，<code>arr[start, end]</code>，返回数组从索引<code>start</code>到<code>end</code>之间的所有元素，如果这个索引区间内不包含任何元素，则返回<code>nil</code>。</p></li><li><p>范围（<code>Range</code>）法，这个方法与第二种方法相似，只是将索引区间变为了<code>Ruby</code>中的范围类型<code>Range</code>.</p><blockquote><p>范围（<code>Range</code>） 范围（<code>Range</code>）是由有顺序、有规律的元素对象组成，任何有顺序，有规律的一组对象，都可以用Range对象来定义，如数字、字母、字符串、甚至时间.</p></blockquote><blockquote><p>上面的 <code>1..3</code>返回的就是由1， 2， 3构成的一个范围。</p></blockquote></li><li><p><code>at</code>法，<code>arr.at(index)</code>，使用了<code>Array</code>的一个类方法，返回数组在传入索引（<code>index</code>）处的值。</p></li></ul><p>说完常规的访问数组元素的方法，我们就要来说一些突出Ruby易读性的方法了，这些方法可谓见名知意。例如下面：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.first    <span class="comment">#=&gt; 1</span></span><br><span class="line">arr.last     <span class="comment">#=&gt; 6</span></span><br><span class="line">arr.take(<span class="number">3</span>)  <span class="comment">#=&gt; [1, 2, 3]</span></span><br><span class="line">arr.drop(<span class="number">3</span>)  <span class="comment">#=&gt; [4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>我们可以看出，<code>first</code>方法是访问数组第一个元素的方法，<code>last</code>方法是访问数组最后一个元素的方法，<code>take(n)</code>方法返回数组前<code>n</code>个元素，<code>drop(n)</code>方法返回数组在<code>n</code>索引后的所有元素。</p><hr><h4 id="数组的常用方法"><a href="#数组的常用方法" class="headerlink" title="数组的常用方法"></a>数组的常用方法</h4><p>下表列出了一些数组的常用方法，更加详细和全面的方法指南可以在<a href="http://ruby-doc.org/core-2.3.1/Array.html">http://ruby-doc.org/core-2.3.1/Array.html</a> 中找到。(假设已创建名为<code>arr</code>的数组)</p><table><thead><tr><th>方法调用方式</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>arr.empty?</code></td><td><code>true</code> 或 <code>false</code></td><td>判段数组是否为空</td></tr><tr><td><code>arr.push(element)</code></td><td><code>new_array</code></td><td>在数组的最后加入元素<code>element</code>，返回加入元素后的新数组</td></tr><tr><td><code>arr &lt;&lt; 6</code></td><td><code>new_array</code></td><td>同上</td></tr><tr><td><code>arr.insert (index, elements)</code></td><td><code>new_array</code></td><td>在指定位置<code>index</code>塞进元素<code>elements</code>，可以塞多个元素 <code>arr.insert (3, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</code></td></tr><tr><td><code>arr.delete(element)</code></td><td><code>element</code></td><td>删除数组中所有为<code>element</code>的元素</td></tr><tr><td><code>arr.compact</code></td><td><code>new_array</code></td><td>删除数组中所有空元素<code> nil</code>，返回删除空元素后的新数组</td></tr><tr><td><code>arr.uniq</code></td><td><code>new_array</code></td><td>清除数组中的重复元素，返回去除重复后的新数组</td></tr><tr><td><code>arr.reverse</code></td><td><code>new_array</code></td><td>翻转<code>arr</code>，返回翻转后的新数组</td></tr><tr><td><code>arr.clear</code></td><td><code>[ ]</code></td><td>删除数组中的所有元素，返回空数组</td></tr><tr><td><code>arr.count</code></td><td><code>Integer</code></td><td>没有参数时，返回数组的大小，带有参数时，返回数组中与参数相同元素的个数</td></tr><tr><td><code>arr.includes?(element)</code></td><td><code>true</code> 或 <code>false</code></td><td>判断数组<code>arr</code>中是否包含元素<code>element</code></td></tr><tr><td><code>arr.sort</code></td><td><code>new_array</code></td><td>将数组按照首字母进行排序，也可定制排序规则</td></tr><tr><td><code>arr.sample</code></td><td><code>element</code></td><td>从数组中随机取样，带参数取样个数，则可取多个样本</td></tr><tr><td><code>arr.flatten</code></td><td><code>new_array</code></td><td>将多维数组转换成一维数组</td></tr><tr><td><code>arr.join(&#39;,&#39;)</code></td><td><code>String</code></td><td>将数组使用连接符<code>,</code>连接成一个字符串</td></tr></tbody></table><p>接下来，我们通过一段小程序来看看这些方法是如何工作的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="string">&#x27;2018&#x27;</span>, <span class="literal">nil</span>, <span class="string">&#x27;Happy&#x27;</span>, <span class="string">&#x27;New&#x27;</span>, <span class="string">&#x27;Year&#x27;</span>]</span><br><span class="line">puts arr.empty?           <span class="comment">#=&gt; false</span></span><br><span class="line">puts arr.<span class="keyword">include</span>?(<span class="string">&#x27;New&#x27;</span>)  <span class="comment">#=&gt; true</span></span><br><span class="line">arr.push(<span class="string">&#x27;!&#x27;</span>)             <span class="comment">#=&gt; 在数组末尾添加 !</span></span><br><span class="line">arr = arr.compact         <span class="comment">#=&gt; 去除数组中的 nil 值</span></span><br><span class="line">puts arr.join(<span class="string">&#x27; &#x27;</span>)        <span class="comment">#=&gt; 2018 Happy New Year !</span></span><br><span class="line">arr.insert(<span class="number">1</span>, <span class="string">&#x27;!&#x27;</span>)        <span class="comment">#=&gt; 在索引 1 处增加 !</span></span><br><span class="line">puts arr.join(<span class="string">&#x27; &#x27;</span>)        <span class="comment">#=&gt; 2018 ! Happy New Year !</span></span><br><span class="line">puts arr.count(<span class="string">&#x27;!&#x27;</span>)       <span class="comment">#=&gt; 2</span></span><br><span class="line">arr.delete(<span class="string">&#x27;!&#x27;</span>)           <span class="comment">#=&gt; 删除掉所有 !</span></span><br><span class="line">puts arr.count(<span class="string">&#x27;!&#x27;</span>)       <span class="comment">#=&gt; 0</span></span><br><span class="line">arr.clear                 <span class="comment">#=&gt; 清空数组</span></span><br><span class="line">puts arr.empty?           <span class="comment">#=&gt; true</span></span><br><span class="line">puts <span class="string">&quot;----------&quot;</span>         <span class="comment">#输出间隔</span></span><br><span class="line">arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">arr2 = arr2.uniq          <span class="comment">#=&gt; 数组去重</span></span><br><span class="line">puts arr2.join(<span class="string">&#x27;,&#x27;</span>)       <span class="comment">#=&gt; 1,2,3,4,5,6</span></span><br><span class="line">arr2 = arr2.reverse       <span class="comment">#=&gt; 数组元素翻转</span></span><br><span class="line">puts arr2.join(<span class="string">&#x27;,&#x27;</span>)       <span class="comment">#=&gt; 6,5,4,3,2,1</span></span><br><span class="line">arr2 = arr2.sort          <span class="comment">#=&gt; 数组按照首字母排序</span></span><br><span class="line">puts arr2.join(<span class="string">&#x27;,&#x27;</span>)       <span class="comment">#=&gt; 1,2,3,4,5,6</span></span><br><span class="line">puts arr2.sample          <span class="comment">#=&gt; 5</span></span><br><span class="line">puts <span class="string">&quot;----------&quot;</span>         <span class="comment">#输出间隔</span></span><br><span class="line">arr3 = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">puts arr3.count           <span class="comment">#=&gt; 2</span></span><br><span class="line">arr3 = arr3.flatten       <span class="comment">#=&gt; 将二维数组转换为一维数组</span></span><br><span class="line">puts arr3.count           <span class="comment">#=&gt; 4</span></span><br></pre></td></tr></table></figure><p>在上面的程序中，每行的注释标明了操作的作用或输出的内容。最后的<code>flatten</code>方法，我们通过处理前后的数组结构来更直观的了解他的作用。</p><ul><li>处理前： <code>[[1, 2], [3, 4]]</code></li><li>处理后： <code>[1, 2, 3, 4]</code></li></ul><p>可以看出，<code>flatten</code>将一个二维数组打开，按序变成一个一维数组。</p><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>哈希（<code>Hash</code>）是类似 <code>&quot;book&quot; =&gt; &quot;comment&quot;</code> 这样的<strong>键值对</strong>的集合。哈希的索引是通过任何对象类型的任意键来完成的，而不是一个整数索引，其他与数组相似。记住，哈希不会维持键值对的顺序，那不是他们的工作。它只会在两个对象之间配对：一个键和一个值。</p><p>如果你尝试通过一个不存在的键访问哈希，则方法会返回<code>nil</code>。</p><h4 id="创建哈希"><a href="#创建哈希" class="headerlink" title="创建哈希"></a>创建哈希</h4><p>与数组一样，Ruby有不同的方式来创建哈希（<code>Hash</code>）。您可以通过<code>new</code>方法创建一个空的哈希（<code>Hash</code>）：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = <span class="title class_">Hash</span>.new</span><br></pre></td></tr></table></figure><p>上面的<code>new</code>方法还可以带上参数<code>default_value</code>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hash = <span class="title class_">Hash</span>.new(<span class="number">0</span>)</span><br><span class="line">hash[<span class="number">0</span>]            <span class="comment">#=&gt; 0</span></span><br><span class="line">hash[<span class="number">100</span>]        <span class="comment">#=&gt; 0</span></span><br></pre></td></tr></table></figure><p>这样我们就能创建一个带有默认值的哈希，这时通过一个不存在的键访问哈希，就会返回<code>0</code>了！</p><p>最常用的创建哈希（<code>Hash</code>）的方式如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">language = &#123;&#125;</span><br><span class="line">language[<span class="string">&#x27;Ruby&#x27;</span>]   = <span class="string">&#x27;Wonderful&#x27;</span></span><br><span class="line">language[<span class="string">&#x27;Python&#x27;</span>] = <span class="string">&#x27;Excellent&#x27;</span></span><br><span class="line">language  <span class="comment">#=&gt; &#123;&quot;Ruby&quot;=&gt;&quot;Wonderful&quot;, &quot;Python&quot;=&gt;&quot;Excellent&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>通过将一个空哈希直接赋值给变量，然后我们将哈希的键Ruby放在<code>[]</code>内，哈希的值<code>&#39;Wonderful&#39;</code>放在<code>=</code>后，我们就可以构建一个我们想要的哈希了！</p><p>同理我们也可以直接将上面的哈希赋值给一个变量：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">language = &#123; <span class="string">&quot;Ruby&quot;</span> =&gt; <span class="string">&quot;Wonderful&quot;</span>,</span><br><span class="line">             <span class="string">&quot;Python&quot;</span> =&gt; <span class="string">&quot;Excellent&quot;</span> &#125;</span><br><span class="line">language = &#123; <span class="title class_">Ruby</span>: <span class="string">&quot;Wonderful&quot;</span>, <span class="title class_">Python</span>: <span class="string">&quot;Excellent&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>上面两种方式都可以完成这一功能，但在<code>Ruby-2.3.1</code>中，我们<strong>推荐使用</strong>下面的方式</p><hr><h4 id="访问哈希"><a href="#访问哈希" class="headerlink" title="访问哈希"></a>访问哈希</h4><p>上面我们已经构建了一个有意义的哈希<code>language</code>，如果我们想要查看我们对于编程语言的评价，我们该怎么做呢？就把我们的键再放在<code>[]</code>里，但是，这次不要再用<code>=</code>了，因为你没有给<code>language</code>分配任何新的信息，你只是在查找它。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language[<span class="string">&#x27;Ruby&#x27;</span>]      <span class="comment">#=&gt; &#x27;Wonderful&#x27;</span></span><br></pre></td></tr></table></figure><p>当数据量大起来的时候，我们可能也记不住我们使用过什么键名了，这个时候，我们可以使用<code>keys</code>方法来查看当前哈希的所有键名。例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">language = &#123; <span class="title class_">Ruby</span>: <span class="string">&quot;Wonderful&quot;</span>,</span><br><span class="line">             <span class="title class_">Python</span>: <span class="string">&quot;Excellent&quot;</span>,</span><br><span class="line">             <span class="variable constant_">PHP</span>: <span class="string">&quot;Best&quot;</span> &#125;</span><br><span class="line">language.keys     <span class="comment">#=&gt; [:Ruby, :Python, :PHP]</span></span><br></pre></td></tr></table></figure><p><code>keys</code>方法会将哈希的所有键名用数组的方式返回，因为哈希是键值对的集合，那我们有了<code>keys</code>肯定也就有<code>values</code>，<code>values</code>方法返回当前哈希的所有值，在这里我们就不做演示了，你可以在右侧的命令行中自行尝试</p><hr><h4 id="常用的哈希方法"><a href="#常用的哈希方法" class="headerlink" title="常用的哈希方法"></a>常用的哈希方法</h4><p>下表列出了一些哈希的常用方法，更加详细和全面的方法指南可以在<a href="http://ruby-doc.org/core-2.3.1/Hash.html">http://ruby-doc.org/core-2.3.1/Hash.html</a> 中找到。(假设已创建名为<code>hsh</code>的哈希)</p><table><thead><tr><th>方法调用方式</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td><code>hsh == other_hash</code></td><td><code>true</code> 或 <code>false</code></td><td>判断两个哈希是否相等。键相等，值相等，键值对应关系均相等才返回<code>true</code></td></tr><tr><td><code>hsh.clear</code></td><td><code>&#123;&#125;</code></td><td>清空当前哈希</td></tr><tr><td><code>hsh.delete(key)</code></td><td><code>value</code></td><td>从哈希中删除匹配<code>key</code>的键值对，并返回对应的值<code>value</code></td></tr><tr><td><code>hsh.has_key?(key)</code></td><td><code>true</code> 或 <code>false</code></td><td>判断哈希中是否包含键<code>key</code></td></tr><tr><td><code>hsh.has_value?(value)</code></td><td><code>true</code> 或 <code>false</code></td><td>判断哈希中是否包含值<code>value</code></td></tr><tr><td><code>hsh.to_s</code></td><td><code>String</code></td><td>将哈希的内容转换为字符串输出</td></tr><tr><td><code>hsh.invert</code></td><td><code>new_hsh</code></td><td>将哈希的键值对颠倒，键变值，值变键，构成新的哈希返回</td></tr><tr><td><code>hsh.key(value)</code></td><td><code>key</code></td><td>返回给定值对应的键。如果找不到该值，则返回0</td></tr><tr><td><code>hsh.length</code></td><td><code>Integer</code></td><td>返回哈希的大小</td></tr><tr><td><code>hsh.merge(other_hash)</code></td><td><code>new_hsh</code></td><td>将<code>hsh</code>和<code>other_hash</code>合并成一个新的哈希。重复键的项值采用<code>other_hash</code>。</td></tr><tr><td><code>hsh.store(key, value)</code></td><td><code>value</code></td><td>在哈希中加入新的键值对</td></tr><tr><td><code>hsh.to_a</code></td><td><code>Array</code></td><td>将哈希转换为数组，格式为： <code>[[ key1, value1 ], [ key2, value2 ]]</code></td></tr><tr><td><code>hsh.values</code></td><td><code>Array</code></td><td>将哈希中的全部转换为数组，格式为：<code>[value1,value2...,valuen]</code></td></tr></tbody></table><p>我们通过一小段程序来着重了解上面的几个方法，所有方法你都可以在右侧的命令行中打开<code>irb</code>试一试。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hash = &#123; <span class="title class_">Ruby</span>: <span class="string">&quot;Wonderful&quot;</span>,</span><br><span class="line">         <span class="title class_">Python</span>: <span class="string">&quot;Excellent&quot;</span>,</span><br><span class="line">         <span class="variable constant_">PHP</span>: <span class="string">&quot;Best&quot;</span> &#125;</span><br><span class="line">hash.has_key?(<span class="string">&quot;Ruby&quot;</span>)      <span class="comment">#=&gt; false</span></span><br></pre></td></tr></table></figure><p>我们发现，我们创建的哈希中竟然没有我们输入的键<code>Ruby</code>，接下来我们做更多的测试。（为了节省篇幅，本小节以下程序均使用已创建的<code>hash</code>变量）</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hash_with_string = &#123; <span class="string">&quot;Ruby&quot;</span> =&gt; <span class="string">&quot;Wonderful&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;Python&quot;</span> =&gt; <span class="string">&quot;Excellent&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;PHP&quot;</span> =&gt; <span class="string">&quot;Best&quot;</span> &#125;</span><br><span class="line">hash_with_string.has_key?(<span class="string">&quot;Ruby&quot;</span>)   <span class="comment">#=&gt; true</span></span><br><span class="line">hash == hash_with_string            <span class="comment">#=&gt; false</span></span><br><span class="line">hash.key(<span class="string">&quot;Wonderful&quot;</span>)               <span class="comment">#=&gt; :Ruby</span></span><br><span class="line">hash_with_string.key(<span class="string">&quot;Wonderful&quot;</span>)   <span class="comment">#=&gt; &quot;Ruby&quot;</span></span><br><span class="line"><span class="comment"># 判断两个对象是否相等，可以通过 obj1 == obj2来判断</span></span><br><span class="line"><span class="comment"># 若相等，则返回 true， 否则为 false</span></span><br><span class="line"><span class="symbol">:Ruby</span> == <span class="string">&quot;Ruby&quot;</span>                     <span class="comment">#=&gt; false</span></span><br></pre></td></tr></table></figure><p>通过上面我们知道了，两种创建<code>Hash</code>的方式是有区别的，那我们为什么推荐使用<code>hash</code>的生成方式呢？细心的读者可能已经发现，代码中<code>:Ruby</code>和<code>&quot;Ruby&quot;</code>是不一样的对象，我们知道后者是字符串，那前者是什么呢？答案是：符号<code>Symbol</code></p><blockquote><p><code>Symbol</code> 符号<code>Symbol</code>的形式是<code>:symbol_name</code>，它也是对象，一般作为名称标签来使用，用来表示方法等对象的名称。</p></blockquote><blockquote><p>符号能实现的功能大部分字符串<code>String</code>也能实现，但是想哈希键这样只是判断是否相等的处理，符号<code>Symbol</code>会比字符串<code>String</code>更高效。 另外符号<code>Symbol</code>可以与字符串<code>String</code>相互转化。</p></blockquote><blockquote><p>而高效的原因就在于，对一个<code>Symbol</code>的多次引用用的是同一个<code>Object</code>，<code>Symbol</code>会节省内存，也是使用的同一个<code>Object</code>来进行比对，所以他的速度会更快。</p></blockquote><h2 id="3-4-Ruby-面向对象"><a href="#3-4-Ruby-面向对象" class="headerlink" title="3.4 Ruby 面向对象"></a>3.4 Ruby 面向对象</h2><h3 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h3><p>在Ruby中，可以通过定义类来创建对象。类是对象的蓝图，它定义了对象的属性和行为。以下是在Ruby中定义对象的步骤：</p><ol><li>使用关键字<code>class</code>定义一个类，后面跟着类的名称。类名的首字母通常大写。例如：</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">  <span class="comment"># 对象定义</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>在类中定义实例变量作为对象的属性。实例变量以<code>@</code>符号开头，可以在类的任何方法中使用。例如：</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">name, age</span>)</span><br><span class="line">    <span class="variable">@name</span> = name</span><br><span class="line">    <span class="variable">@age</span> = age</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>在类中定义方法作为对象的行为。方法是类中的函数，可以执行特定的操作。例如：</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">name, age</span>)</span><br><span class="line">    <span class="variable">@name</span> = name</span><br><span class="line">    <span class="variable">@age</span> = age</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">introduce</span></span><br><span class="line">    puts <span class="string">&quot;My name is <span class="subst">#&#123;<span class="variable">@name</span>&#125;</span> and I am <span class="subst">#&#123;<span class="variable">@age</span>&#125;</span> years old.&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上述例子中，<code>initialize</code>方法可以看作构造函数，构造函数使用<code>@</code> 关键字修饰的变量可以看作类的属性；同时也可以显式定义类的属性，使用关键字<code>@@</code>修饰，例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">  <span class="variable">@@class_var</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">puts <span class="title class_">MyClass</span>.class_variables</span><br></pre></td></tr></table></figure><p>运行上述代码会输出<code>@@class_var</code>的值，它是<code>MyClass</code>类的一个类变量。</p><ol><li>使用类的<code>new</code>方法创建对象。<code>new</code>方法是类的构造函数，用于实例化对象并调用<code>initialize</code>方法进行初始化。例如：</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person = <span class="title class_">Person</span>.new(<span class="string">&quot;John&quot;</span>, <span class="number">25</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>可以通过对象调用类中定义的方法。例如：</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.introduce</span><br></pre></td></tr></table></figure><p>这将输出：<code>My name is John and I am 25 years old.</code></p><hr><h3 id="封装对象"><a href="#封装对象" class="headerlink" title="封装对象"></a>封装对象</h3><p>在Ruby中，类的封装是通过访问控制符（Access Control）来实现的。Ruby提供了三种访问控制符，分别是<code>public</code>、<code>private</code>和<code>protected</code>，用于控制类中方法和属性的可见性。</p><ul><li><code>public</code>：公共方法可以从类的内部和外部访问。默认情况下，所有的方法都是公共的。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">public_method</span></span><br><span class="line">    puts <span class="string">&quot;This is a public method&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = <span class="title class_">MyClass</span>.new</span><br><span class="line">obj.public_method <span class="comment"># 调用公共方法</span></span><br></pre></td></tr></table></figure><ul><li><code>private</code>：私有方法只能从类的内部调用，无法从外部直接访问。私有方法不能被类的实例直接调用，只能通过类的内部方法来间接调用。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">public_method</span></span><br><span class="line">    puts <span class="string">&quot;This is a public method&quot;</span></span><br><span class="line">    private_method <span class="comment"># 可以在类的内部调用私有方法</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">private_method</span></span><br><span class="line">    puts <span class="string">&quot;This is a private method&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = <span class="title class_">MyClass</span>.new</span><br><span class="line">obj.public_method <span class="comment"># 调用公共方法，会间接调用私有方法</span></span><br><span class="line"><span class="comment"># obj.private_method # 错误！无法直接调用私有方法</span></span><br></pre></td></tr></table></figure><ul><li><code>protected</code>：受保护方法可以从类的内部以及该类的实例的上下文中访问。受保护方法可以被类的实例直接调用，也可以在同一个类的其他实例方法中调用。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">public_method</span></span><br><span class="line">    puts <span class="string">&quot;This is a public method&quot;</span></span><br><span class="line">    protected_method <span class="comment"># 可以在类的内部调用受保护方法</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">protected_method</span></span><br><span class="line">    puts <span class="string">&quot;This is a protected method&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = <span class="title class_">MyClass</span>.new</span><br><span class="line">obj.public_method <span class="comment"># 调用公共方法，会直接调用受保护方法</span></span><br><span class="line"><span class="comment"># obj.protected_method # 错误！不能直接调用受保护方法</span></span><br></pre></td></tr></table></figure><p>通过使用这些访问控制符，可以控制类中方法和属性的可见性，实现封装的概念。这样可以隐藏内部实现细节，防止外部直接访问和修改类的内部状态，提供了更好的封装性和安全性。               </p><h3 id="对象继承"><a href="#对象继承" class="headerlink" title="对象继承"></a>对象继承</h3><p>父类也称基类，其声明方法与一般的类的声明方法一样。父类中存在着一些公共的属性和方法，子类继承于父类。</p><p>子类继承于父类，拥有父类中的属性和方法，它自己也可根据实际情况声明一些属于自己的属性和方法。</p><p>子类声明方法:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span> &lt; <span class="title class_ inherited__">FatherClass</span></span><br></pre></td></tr></table></figure><p>符号<code>&lt;</code>后跟的类名就是父类名称。在Ruby中，继承语法只支持单继承，如果要实现多重继承，必须要使用<code>Mix-In</code>扩展功能，这一功能，我们将在下一个实训，模块中为大家讲解。</p><p>下面，我们给出一段代码来实际观察类的继承：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">self</span>.says</span><br><span class="line">    puts <span class="string">&quot;I am father&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">self</span>.father_info</span><br><span class="line">    puts <span class="string">&quot;father info&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> &lt; <span class="title class_ inherited__">Father</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">self</span>.says</span><br><span class="line">    puts <span class="string">&quot;I am son&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">self</span>.son_info</span><br><span class="line">    puts <span class="string">&quot;son info&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="title class_">Father</span>.says         <span class="comment">#=&gt; I am father</span></span><br><span class="line"><span class="title class_">Father</span>.father_info  <span class="comment">#=&gt; father info</span></span><br><span class="line"><span class="title class_">Son</span>.says            <span class="comment">#=&gt; I am son</span></span><br><span class="line"><span class="title class_">Son</span>.son_info        <span class="comment">#=&gt; son info</span></span><br><span class="line"><span class="title class_">Son</span>.father_info     <span class="comment">#=&gt; father info</span></span><br></pre></td></tr></table></figure><p>在这里我们发现，子类和父类中定义了一些同名方法，而只要子类与父类定义的方法名称相同，子类的方法就会<strong>覆盖</strong>掉父类的方法，调用时也就会调用子类的方法，而忽略掉父类的方法。</p><p>除此之外，子类也可以直接调用父类的构造方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">name</span>)</span><br><span class="line">    <span class="variable">@name</span> = name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">says</span></span><br><span class="line">    puts <span class="string">&quot;I am father&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> &lt; <span class="title class_ inherited__">Father</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">says</span></span><br><span class="line">    puts <span class="string">&quot;I am son. name: <span class="subst">#&#123;<span class="variable">@name</span>&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">son = <span class="title class_">Son</span>.new(<span class="string">&quot;Jack&quot;</span>)</span><br><span class="line">son.says       <span class="comment">#=&gt; I am son. name: Jack</span></span><br></pre></td></tr></table></figure><p>上述代码中，<code>initialize</code>方法就相当于类的构造函数，也叫做初始化函数，该方法在<strong>类实例化</strong>时<strong>自动</strong>调用。子类<code>Son</code>未定义<code>initialize</code>方法，故其直接调用父类的<code>initialize</code>方法。</p><p>同时，我们发现了一个新的语法，<code>son = Son.new(&quot;Jack&quot;)</code>，这一句代码实现了<strong>类实例化</strong>，创建了一个类的实例，<strong>对象</strong>。我们将在下一小节中详细的论述<strong>对象</strong>这一概念</p><p>那如果，子类自己也定义了<code>initialize</code>方法，会怎么样呢？我们来试试。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">name</span>)</span><br><span class="line">    <span class="variable">@name</span> = name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">says</span></span><br><span class="line">    puts <span class="string">&quot;I am father&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> &lt; <span class="title class_ inherited__">Father</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">name</span>)</span><br><span class="line">    <span class="variable">@name</span> = <span class="string">&quot;son_<span class="subst">#&#123;name&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">says</span></span><br><span class="line">    puts <span class="string">&quot;I am son. name: <span class="subst">#&#123;<span class="variable">@name</span>&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">son = <span class="title class_">Son</span>.new(<span class="string">&quot;Jack&quot;</span>)</span><br><span class="line">son.says       <span class="comment">#=&gt; I am son. name: son_Jack</span></span><br></pre></td></tr></table></figure><p>结果就是，子类的<code>initialize</code>方法<strong>覆盖</strong>了父类的<code>initialize</code>方法，<strong>覆盖</strong>不仅仅适用与初始化方法，也适用于类方法和实例方法，只要子类与父类定义的方法名称相同，子类的方法就会<strong>覆盖</strong>掉父类的方法。</p><h2 id="3-5-Ruby文件操作"><a href="#3-5-Ruby文件操作" class="headerlink" title="3.5 Ruby文件操作"></a>3.5 Ruby文件操作</h2><h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><p><strong>进阶<code>gets</code>方法</strong></p><p>先简单的回顾一下我们常用的 <code>gets</code> 语句，<code>gets</code> 语句可用于获取来自名为 <code>STDIN</code> 的<strong>标准屏幕的用户输入</strong>。例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = gets</span><br></pre></td></tr></table></figure><p><code>gets</code> 方法从键盘输入的字符串，会带有最后输入的 <code>\n</code> 字符，这和 C&#x2F;C++ 是一样的。如果想去掉 <code>\n</code>，在 Ruby 中可以在<code>gets</code> 的结果上级联调用 <code>chomp</code> 方法，即 <code>gets.chomp</code>。</p><blockquote><p><code>chomp</code> 是一个字符串方法，它只从您的键盘中检索字符串。从字符串的末尾删除回车字符(即它将删除<code>\n</code>、<code>\r</code> 和 <code>\r\n</code>)。</p></blockquote><p><code>gets</code> 方法除了无参数调用方式外，还有传参调用，其调用语法如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gets(sep, limit)</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>sep</code> 是分隔符，键盘输入字符中若包含该分隔符，则将输入字符以分隔符为界分为多段，依次输入</li><li><code>limit</code> 是输入上限字符数，若键盘输入字符数超过该上限数，则分为多段，每段包含上限数个字符。</li></ul><p>除了 <code>gets</code> 方法可以获取键盘输入之外，Ruby 还提供 <code>ARGV</code> 从命令行接收参数，例如文件 <code>test.rb</code> 中有如下代码：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.rb</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">name</span>)</span><br><span class="line">  puts <span class="string">&quot;Hello, <span class="subst">#&#123;name&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">hello(<span class="variable constant_">ARGV</span>[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>当在命令行输入 <code>ruby test.rb Educoder</code> 时，系统将会在屏幕打印 <code>Hello, Educoder</code>。<code>ARGV[0]</code> 从命令行中获取命令的参数，并传送给 Ruby 文件，并可以按照命令参数的下标 <code>0</code> 来获取到<strong>第一个</strong>参数。</p><p><strong>输出</strong></p><p>除了我们之前常用的 <code>puts</code> 和 <code>p</code> 方法，我们还有很多标准化输出方法，接下来我们一一介绍这些方法。在开始之前，我们先介绍 Ruby 标准输出流。</p><p><strong>STDOUT</strong> 是 IO 对象的实例，它是程序的实际标准输出流。除非额外设置，STDOUT 总是指向屏幕显示的。可以直接使用 STDOUT 输出，例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$stdout</span> &lt;&lt; <span class="string">&quot;Hello &quot;</span> &lt;&lt; <span class="string">&quot;world!\n&quot;</span></span><br></pre></td></tr></table></figure><p>其输出为： <code>Hello world!</code></p><p><strong><code>printf</code>方法</strong></p><p><code>printf</code> 方法按照格式序列将字符串输出，常见的格式序列如下：</p><table><thead><tr><th>格式域</th><th>作用</th></tr></thead><tbody><tr><td>b</td><td>作为二进制输出</td></tr><tr><td>c</td><td>作为字符表示输出（ASCII码表）</td></tr><tr><td>d</td><td>作为整数输出</td></tr><tr><td>f</td><td>作为浮点数输出</td></tr><tr><td>o</td><td>作为八进制数输出</td></tr><tr><td>s</td><td>作为字符串输出</td></tr><tr><td>u</td><td>作为无符号小数输出</td></tr><tr><td>x</td><td>作为十六进制数输出，a-f为小写字母</td></tr><tr><td>X</td><td>作为十六进制数输出，A-F为大写字母</td></tr><tr><td>\n</td><td>换行输出</td></tr></tbody></table><p>下面我们来看看它们的作用，<strong>代码中 <code>#=&gt;</code> 符号后的字符为该行代码输出值</strong>：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加符号在数字前</span></span><br><span class="line">printf(<span class="string">&quot;%d&quot;</span>, <span class="number">123</span>)  <span class="comment">#=&gt; &quot;123&quot;</span></span><br><span class="line">printf(<span class="string">&quot;%+d&quot;</span>, <span class="number">123</span>) <span class="comment">#=&gt; &quot;+123&quot;</span></span><br><span class="line"><span class="comment"># `#&#x27; 号在输出八进制数时使其前面带上八进制数标志 `0`</span></span><br><span class="line"><span class="comment"># `+&#x27; 号改变负数的输出格式</span></span><br><span class="line">printf(<span class="string">&quot;%o&quot;</span>, <span class="number">123</span>)   <span class="comment">#=&gt; &quot;173&quot;</span></span><br><span class="line">printf(<span class="string">&quot;%#o&quot;</span>, <span class="number">123</span>)  <span class="comment">#=&gt; &quot;0173&quot;</span></span><br><span class="line">printf(<span class="string">&quot;%+o&quot;</span>, -<span class="number">123</span>) <span class="comment">#=&gt; &quot;-173&quot;</span></span><br><span class="line">printf(<span class="string">&quot;%o&quot;</span>, -<span class="number">123</span>)  <span class="comment">#=&gt; &quot;..7605&quot;</span></span><br><span class="line"><span class="comment"># `#&#x27; 号在输出 非0 十六进制数时使其前面带上十六进制数标志 `0x`</span></span><br><span class="line"><span class="comment"># `+&#x27; 号改变负数的输出格式</span></span><br><span class="line">printf(<span class="string">&quot;%x&quot;</span>, <span class="number">123</span>)   <span class="comment">#=&gt; &quot;7b&quot;</span></span><br><span class="line">printf(<span class="string">&quot;%#x&quot;</span>, <span class="number">123</span>)  <span class="comment">#=&gt; &quot;0x7b&quot;</span></span><br><span class="line">printf(<span class="string">&quot;%#x&quot;</span>, <span class="number">0</span>)    <span class="comment">#=&gt; &quot;0&quot;</span></span><br><span class="line"><span class="comment"># `#&#x27; 号使输出 非0 二进制数带上前缀 `0b&#x27;</span></span><br><span class="line"><span class="comment"># `+&#x27; 号改变负数的输出格式</span></span><br><span class="line">printf(<span class="string">&quot;%b&quot;</span>, <span class="number">123</span>)   <span class="comment">#=&gt; &quot;1111011&quot;</span></span><br><span class="line">printf(<span class="string">&quot;%#b&quot;</span>, <span class="number">123</span>)  <span class="comment">#=&gt; &quot;0b1111011&quot;</span></span><br><span class="line"><span class="comment"># `#&#x27; 号使输出浮点数带上小数点</span></span><br><span class="line">printf(<span class="string">&quot;%.0f&quot;</span>, <span class="number">1234</span>)  <span class="comment">#=&gt; &quot;1234&quot;</span></span><br><span class="line">printf(<span class="string">&quot;%#.0f&quot;</span>, <span class="number">1234</span>) <span class="comment">#=&gt; &quot;1234.&quot;</span></span><br></pre></td></tr></table></figure><p><strong><code>putc</code>方法</strong></p><p>与 <code>puts</code> 方法不同，<code>puts</code> 方法输出整个字符串到屏幕上，而 <code>putc</code> 方法输出一个字符到屏幕上。</p><p>该方法的语法为： <code>putc(obj)</code></p><ul><li><code>obj</code> 是个数字时，将其转换为字符输出（ASCII码表）</li><li><code>obj</code> 是个字符串时，选择其的第一个字符进行输出。</li><li>该方法<strong>仅</strong>用于单个字符的输出，不用于字符串输出，因为他会截断字符串，造成输出的不准确。</li></ul><p>通过一个实例来加强对其的理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putc &#x27;Hello&#x27;</span><br></pre></td></tr></table></figure><p>其输出为： <code>H</code></p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="文件对象化"><a href="#文件对象化" class="headerlink" title="文件对象化"></a>文件对象化</h4><p>Ruby 中一切皆是对象，要对文件做操作，我们首先也需要创建出一个文件对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File.new(filename, mode=&quot;r&quot; [, opt])</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>filename</code> 为需要操作的文件名（可带路径）</li><li><code>mode</code> 为打开方式，将在下表中罗列出所有支持的打开方式</li><li><code>opt</code> 为其它可选参数，用来做文件操作的控制。</li></ul><table><thead><tr><th>mode_type</th><th>作用描述</th></tr></thead><tbody><tr><td><code>&quot;r&quot;</code></td><td>只读，起始位置为文件开头（默认方式）</td></tr><tr><td><code>&quot;r+&quot;</code></td><td>可读可写，起始位置为文件开头</td></tr><tr><td><code>&quot;w&quot;</code></td><td>只写，复写已有文件&#x2F;创建新的文件</td></tr><tr><td><code>&quot;w+&quot;</code></td><td>可读可写，复写已有文件&#x2F;创建新的文件</td></tr><tr><td><code>&quot;a&quot;</code></td><td>只写，在文件的末尾写&#x2F;创建新的文件</td></tr><tr><td><code>&quot;a+&quot;</code></td><td>可读可写，在文件的末尾读写&#x2F;创建新的文件</td></tr><tr><td><code>&quot;b&quot;</code></td><td>仅用于二进制文件</td></tr><tr><td><code>&quot;t&quot;</code></td><td>仅用于文本文件</td></tr></tbody></table><p><code>opt</code> 可选参数包括：</p><ul><li><code>:mode</code>，与上述打开方式相同</li><li><code>:encoding</code>，通过 <code>&quot;extern:intern&quot;</code> 指定文件的内部编码和外部编码模式</li><li><code>:autoclose</code>，当值为 <code>false</code> 时，则在此 IO 实例完成后，文件将保持打开状态</li></ul><h4 id="文件的打开"><a href="#文件的打开" class="headerlink" title="文件的打开"></a>文件的打开</h4><p>当我们需要持续的使用文件对象时，我们采用上面的方式来创建文件对象，之后在对它读取&#x2F;进行其它操作，假如我们只需要读取这个文件，我们可以通过 <code>File.open</code> 方法结合前面块的知识，将打开的文件对象作为参数传递给代码块，当这个块终止时，文件也将自动关闭。语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File.open(&quot;filename&quot;, &quot;mode&quot;) do |file|  # ... process the fileend</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>filename</code> 和 <code>mode</code> 均和上面创建文件对象时的参数一致</li><li><code>file</code> 局部变量则是打开的文件对象传递给代码块的形式参数</li></ul><blockquote><p>Notice: 当没有相关的块时，<code>File.open</code> 与 <code>File.new</code> 功能一致</p></blockquote><h4 id="文件的读取和写入"><a href="#文件的读取和写入" class="headerlink" title="文件的读取和写入"></a>文件的读取和写入</h4><p>用于简单 I&#x2F;O 的方法也可用于所有的文件对象。所以，<code>gets</code> 方法从标准输入读取一行，<code>file.gets</code> 从文件对象 <code>file</code> 中读取一行。</p><p>除此之外，<code>File</code>类也有自己的方法用来读取&#x2F;写入文件数据。</p><h4 id="文件的读取"><a href="#文件的读取" class="headerlink" title="文件的读取"></a>文件的读取</h4><p><code>read</code>方法可以从文件对象中读出指定个数的字符，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.read([length])</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>当 <code>length</code> 为正整数时，其从文件对象 <code>file</code> 中以二进制模式读出 <code>length</code> 个字节</li><li>当 <code>length</code> 值为 <code>nil</code> 或<strong>省略该参数</strong>时，其读取文件对象直至遇到 <code>EOF</code> 符</li><li>当 <code>length = 0</code> 时，其返回空字符串（<code>&quot;&quot;</code>）。</li></ul><blockquote><p><code>EOF</code>符</p></blockquote><blockquote><p>全称是 <code>End-of-File</code>， 其存在于文件末尾处，读取到 <code>EOF</code>符意味着该文件已读取完毕。</p></blockquote><p>我们通过一个实例来了解 <code>read</code> 方法是如何工作的：</p><p>假设<code>testfile</code> 文件中存放的数据如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is line oneThis is line twothis is line three</span><br></pre></td></tr></table></figure><p>以下是执行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = File.new(&quot;testfile&quot;)puts f.read(16)# 读取整个文件File.open(&quot;testfile&quot;) do |f|  data = f.read  p dataend</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is line one` `This is line one\nThis is line two\nThis is line three\n</span><br></pre></td></tr></table></figure><p>从结果上我们可以很直观的观察到使用 <code>File.new</code> 和 <code>File.open</code> 方法打开的文件对象在读取时的反应是一致的，无差别的。</p><p>除了 <code>read</code> 方法外，还有类似的 <code>readline</code> 和 <code>readlines</code> 方法：</p><ul><li><code>readline</code> 方法与 <code>gets</code> 方法一致，读取出文件的一行，并置文件指针于下一行开头处，直到取到读取完毕时。</li><li><code>readlines</code> 方法则是将整个文件读取出来，并按照行号依次存放在一个数组中返回。</li></ul><p>在上段代码和文件的基础上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># testfile 文件保持与上述一致f = File.new(&quot;testfile&quot;)puts f.readlinelines = f.readlinesp linesputs lines[0]</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is line one` `[&quot;This is line two\n&quot;, &quot;This is line three\n&quot;, &quot;This is new line&quot;]` `This is line two</span><br></pre></td></tr></table></figure><h4 id="文件的写入"><a href="#文件的写入" class="headerlink" title="文件的写入"></a>文件的写入</h4><p>与 <code>read</code> 方法相对应，<code>File</code>类也有 <code>write</code> 方法来进行文件写入。语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.write(string)</span><br></pre></td></tr></table></figure><p>该方法按照文件对象 <code>file</code> 打开方式的不同，按规则写入新字符串 <code>string</code>，并保存。我们也通过一个实例来加强对方法的理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># testfile 文件保持与上述一致f = File.new(&quot;testfile&quot;, &quot;a+&quot;)f.write(&quot;This is new line!&quot;)</span><br></pre></td></tr></table></figure><p>此时文件 <code>testfile</code> 的内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is line oneThis is line twoThis is line threeThis is new line!</span><br></pre></td></tr></table></figure><p>我们可以很直观的看出新增了最后一行，与我们写入的行一致！</p><h4 id="文件的关闭"><a href="#文件的关闭" class="headerlink" title="文件的关闭"></a>文件的关闭</h4><p>在进行外文件的读取&#x2F;写入后，我们不能一直保持文件的打开状态，因为文件打开后会存在放内存中，而内存的资源是紧张而宝贵的，所以在我们使用完文件对象后，我们应该及时关闭文件，以高效的运用内存资源。Ruby 中文件关闭的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.close</span><br></pre></td></tr></table></figure><p><code>close</code> 方法将会：</p><ul><li>将所有挂起的写入操作传送到操作系统</li><li>关闭掉文件对象 <code>file</code> 相关的文件</li><li>不允许任何数据操作，关闭 I&#x2F;O 流</li><li>将文件对象 <code>file</code> 状态置为已关闭。</li></ul><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>类似于文件对象化，目录也可以对象化，目录对象化只需要一个参数，目录名称 <code>dir_name</code>，语法如下：<code>Dir.new(dir_name)</code>，这将创建出一个目录对象。</p><h4 id="浏览目录"><a href="#浏览目录" class="headerlink" title="浏览目录"></a>浏览目录</h4><p>浏览目录中基本操作包括：</p><ul><li><p>使用 <code>Dir.chdir</code> 方法切换目录。下面的实例将当前目录切换为 <code>/usr/bin</code>:</p><p><code>Dir.chdir(&quot;/usr/bin&quot;)</code></p></li><li><p>查看当前目录，我们可以通过 <code>Dir.pwd</code> 查看当前目录：<code>puts Dir.pwd</code>，输出为当前目录，例如: <code>/usr/bin</code>。</p></li><li><p>使用 <code>Dir.entries</code> 获取指定目录内的文件和目录列表：</p><p>假设当前目录下包含的文件和目录有 <code>file.rb</code> 和 <code>testfile</code>，那么这个程序：</p><p><code>puts Dir.entries(&quot;./&quot;).join(&quot; &quot;)</code></p><p>的返回值将会是：  <code>&quot;.. file.rb . testfile&quot;</code>。</p><p>返回值说明：</p><ul><li><code>.</code> 表示当前目录</li><li><code>..</code> 表示上一级目录</li></ul><p>我们注意到 <code>Dir.entries</code> 返回一个数组，包含指定目录内的所有项。我们使用数组方法 <code>join</code> 来将其连接起来，连接符为<code>&quot; &quot;</code>。</p></li><li><p><code>Dir.foreach</code> 提供了相同的获取指定目录内的文件和目录列表功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dir.foreach(&quot;/usr/bin&quot;) do |entry|puts entryend</span><br></pre></td></tr></table></figure></li></ul><p> <code>Dir.foreach</code> 方法将目录 <code>/usr/bin</code> 内的所有项依次传递给局部变量 <code>entry</code>，块内语句 <code>puts entry</code> 将其输出。</p><ul><li><p>获取目录列表的一个更简洁的方式是通过使用 <code>Dir</code> 的类数组的方法： <code>Dir[&quot;/usr/bin/*&quot;]</code></p><p>该方法将扫描所有位于目录 <code>/usr/bin</code> 下的文件和目录。</p></li></ul><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>有些程序需要将文件存放在一个新的目录中，这时我们可以通过 <code>Dir.mkdir</code> 方法创建目录，例如：<code>Dir.mkdir(&quot;new_dir&quot;)</code> 将会在系统当前目录下创建名为 <code>new_dir</code> 的目录。</p><p>如果我们需要给目录增添权限，我们也可以通过传递第二个参数，例如 <code>Dir.mkdir( &quot;mynewdir&quot;, 755 )</code> 来给<strong>新创建的目录</strong>增添权限掩码为 <code>755</code> 的权限。</p><blockquote><p>Tips：掩码 <code>755</code> 设置所有者（owner）、所属组（group）、每个人（world [anyone]）的权限为 <code>rwxr-xr-x</code>，其中</p></blockquote><blockquote><ul><li>读取: <code>r</code> &#x3D; read &#x3D; <code>4</code></li><li>写入: <code>w</code> &#x3D; write &#x3D; <code>2</code></li><li>执行: <code>x</code> &#x3D; execute &#x3D; <code>1</code></li></ul></blockquote><p>临时文件目录</p><p>除了正式目录外，系统中还有临时目录，专门用于存储临时文件。临时文件是那些在程序执行过程中被创建，但不会永久性存储的信息。</p><p><code>Dir.tmpdir</code> 提供了<strong>当前系统上临时目录的路径</strong>，但是该方法默认情况下是不可用的。要调用 <code>Dir.tmpdir</code> 方法，必须要引入 <code>&#39;tmpdir&#39;</code> 文件。</p><p>您可以把 <code>Dir.tmpdir</code> 和 <code>File.join</code> 一起使用，来创建一个临时文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">require &#x27;tmpdir&#x27;</span><br><span class="line">tempfilename = File.join(Dir.tmpdir, &quot;test_temp_file&quot;)</span><br><span class="line"> #=&gt; tempfilename 的值为 &quot;/tmp/test_temp_file&quot;</span><br><span class="line">tempfile = File.new(tempfilename, &quot;w&quot;)</span><br><span class="line">tempfile.puts(&quot;This is a temporary file&quot;)</span><br><span class="line">tempfile.close</span><br></pre></td></tr></table></figure><p>上述代码中的 <code>File.join</code> 方法是 <code>File</code> 类提供用来拼接文件名，该方法将参数传入的字符串通过连接符 <code>/</code> 来连接成一个大的字符串。</p><h4 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h4><p><code>Dir.delete</code> 方法可用于删除目录。除此之外，<code>Dir.unlink</code> 和 <code>Dir.rmdir</code> 也有同样的功能。这三个方法删除掉指定目录，当目录<strong>非空</strong>时，该方法将会报错。以下是这三个方法创建新目录 <code>testdir</code> 的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dir.delete(&quot;testdir&quot;)Dir.unlink(&quot;testdir&quot;)Dir.rmdir(&quot;testdir&quot;)</span><br></pre></td></tr></table></figure><h1 id="四、Sass架构"><a href="#四、Sass架构" class="headerlink" title="四、Sass架构"></a>四、Sass架构</h1><h2 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h2><h3 id="MVC介绍"><a href="#MVC介绍" class="headerlink" title="MVC介绍"></a>MVC介绍</h3><p>Model-View-Controller（MVC）框架是常见的一种应用服务器框架，服务器中通过控制器（Controller）将数据（Model）与UI表示（View）分离：</p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231020102203226.png" alt="image-20231020102203226" style="zoom:67%;" /><p><strong>一个实体（Entity）由：一个模型 + 一个控制器 + 一组视图组成：</strong></p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231020102310031.png" alt="image-20231020102310031" style="zoom:67%;" /><blockquote><p>“所有MVC应用都包括一个‘客户端’                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    部分(如Web浏览器) 和一个“云”部分(如云上的Rails应用程序)” 这种说法是错的，因为MVC应用不包括客户端部分。</p></blockquote><blockquote><p>MVC中的VIEW，并不是代表HTML页面，而是一个视图程序，HTML页面是由这个视图程序加工而来的。</p></blockquote><h3 id="MVC替代"><a href="#MVC替代" class="headerlink" title="MVC替代"></a>MVC替代</h3><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231020102753733.png" alt="image-20231020102753733"></p><h2 id="模型，数据库，活动记录"><a href="#模型，数据库，活动记录" class="headerlink" title="模型，数据库，活动记录"></a>模型，数据库，活动记录</h2><h3 id="内存中的对象vs-存储中的对象"><a href="#内存中的对象vs-存储中的对象" class="headerlink" title="内存中的对象vs.存储中的对象"></a>内存中的对象vs.存储中的对象</h3><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231020104958594.png" alt="image-20231020104958594"></p><p>将内存汇总的对象序列化后存储到固态介质中，生成存储中的对象；存储中的对象通过反序列化生成内存中的对象。对象的基本操作: CRUD (Create, Read，Update, Delete)。</p><p><strong>活动记录（ActiveRecord）</strong>：每个模型都知道如何使用通用机制进行CRUD操作</p><h2 id="控制器，路由"><a href="#控制器，路由" class="headerlink" title="控制器，路由"></a>控制器，路由</h2><h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p><strong>REST思路：URI命名资源 , 而不是页面 或者动作</strong>，使用 HTTP请求 + URI 刻画某个资源，并对该资源实施动作，其响应(repsonse)包括了发现其他RESTful资源的超链接</p><p>(在SOA意义上)带有类似特征的一组操作组成的服务称为<strong>RESTful服务</strong></p><hr><h3 id="路由-Route"><a href="#路由-Route" class="headerlink" title="路由(Route)"></a>路由(Route)</h3><ul><li><p>在MVC中，用户可以进行的每个交互都是由<strong>控制器中的动作</strong>来处理的 – Ruby语言中的方法(method)处理这种交互</p></li><li><p>一个路由将 &lt;HTTP method, URI&gt; 映射到控制器的动作</p></li></ul><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231020110215076.png" alt="image-20231020110215076"></p><p>Rails路由子系统如下：</p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231020110256244.png" alt="image-20231020110256244" style="zoom:67%;" /><ul><li>通过给定的控制器动作生成&lt;method,URI&gt;，分发&lt;method,URI&gt;到正确的控制器动作，而URI和提交查询的参数则被解析为一个Hash作为动作的输入：</li></ul><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231020110803301.png" alt="image-20231020110803301"></p><p>下面通过<code>GET   /movies/3/edit   HTTP/1.0</code>来进行举例：</p><ul><li>匹配路由：<code>GET /movies/:id/edit &#123;:action=&gt;&quot;edit&quot;, :controller=&gt;&quot;movies&quot;&#125;</code></li><li>解析通配符的参数：params[:id]&#x3D;“3”</li><li>消息分发：对<code>movies_controller.rb</code>中的<code>edit</code>方法进行调用</li></ul><p>下面是RESTful资源的CRUD方式（以movies举例）：</p><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231020111523383.png" alt="image-20231020111523383"></p><h2 id="模板视图和Haml"><a href="#模板视图和Haml" class="headerlink" title="模板视图和Haml"></a>模板视图和Haml</h2><p>视图由标记和在运行时发生的选择性插入组成，插入填写内容通常是：变量的值，或对一小段代码运行后的结果。以前，这就是应用程序(例如PHP)</p><p><strong>但现在不要在视图中添加功能代码！</strong></p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231020112505066.png" alt="image-20231020112505066" style="zoom:67%;" /><h1 id="五、Rails框架"><a href="#五、Rails框架" class="headerlink" title="五、Rails框架"></a>五、Rails框架</h1><h2 id="Rails作为MVC框架"><a href="#Rails作为MVC框架" class="headerlink" title="Rails作为MVC框架"></a>Rails作为MVC框架</h2><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231021135020902.png" alt="image-20231021135020902"></p><p><strong>Rails应用程序执行过程：</strong></p><ol><li>**路由(**在routing.rb中)将传入的URL映射到<font color='red'>控制器动作</font>并提取任何<font color='red'>可选参数</font>，路由的“通配符”参数(例如:id)，加上URL中“?”之后的任何内容被放入params[]哈希表中，可在控制器动作中访问</li><li>控制器动作设置实例变量，视图可见，views&#x2F;目录下的子目录和文件名匹配控制器动作名称</li><li>控制器动作最终导致一个视图被呈现，即view被返回</li></ol><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231021135525696.png" alt="image-20231021135525696"></p><h2 id="Rails哲学"><a href="#Rails哲学" class="headerlink" title="Rails哲学"></a>Rails哲学</h2><ul><li><p><strong>约定优先于配置原则</strong>：如果命名遵循某些约定，则不需要配置文件。这点与JAVA不太一样，Java中需要使用配置文件或是注释来绑定路由，而在Rails中不需要，例如：<img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231021140410050.png" alt="image-20231021140410050"></p></li><li><p>Don’t Repeat Yourself (DRY)：提取公共功能的开发原则</p></li></ul><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>必须调用ActiveRecord模型实例上的<code>save</code>或<code>save!</code>方法将实际更改保存到数据库,如果操作失败“!”版本方法将抛出异常，<code>create</code>方法是 new 方法与 save方法的组合，其具有原子性。</p><p>创建后，对象获得一个主键(每个ActiveRecord模型表中的id列)</p><h1 id="六、行为驱动设计（BDD）和用户故事介绍"><a href="#六、行为驱动设计（BDD）和用户故事介绍" class="headerlink" title="六、行为驱动设计（BDD）和用户故事介绍"></a>六、行为驱动设计（BDD）和用户故事介绍</h1><h2 id="6-1-敏捷生命周期"><a href="#6-1-敏捷生命周期" class="headerlink" title="6.1 敏捷生命周期"></a>6.1 敏捷生命周期</h2><h2 id="6-2-行为驱动的设计"><a href="#6-2-行为驱动的设计" class="headerlink" title="6.2 行为驱动的设计"></a>6.2 行为驱动的设计</h2><h2 id="6-3-生产力和工具"><a href="#6-3-生产力和工具" class="headerlink" title="6.3 生产力和工具"></a>6.3 生产力和工具</h2><h2 id="6-4-用户故事"><a href="#6-4-用户故事" class="headerlink" title="6.4 用户故事"></a>6.4 用户故事</h2><h3 id="创建用户故事"><a href="#创建用户故事" class="headerlink" title="创建用户故事"></a>创建用户故事</h3><p>用户故事的评判从五个方面来进行：</p><ul><li>Specific</li><li>Measurable</li><li>Achievable</li><li>Relevant</li><li>Timeboxed</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;一、软件工程概述&quot;&gt;&lt;a href=&quot;#一、软件工程概述&quot; class=&quot;headerlink&quot; title=&quot;一、软件工程概述&quot;&gt;&lt;/a&gt;一、软件工程概述&lt;/h1&gt;&lt;p</summary>
      
    
    
    
    <category term="计算机基础学科" scheme="http://cjx_0723.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/"/>
    
    
    <category term="课堂学习" scheme="http://cjx_0723.gitee.io/tags/%E8%AF%BE%E5%A0%82%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="软件工程" scheme="http://cjx_0723.gitee.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件分析与测试</title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E4%B8%8E%E6%B5%8B%E8%AF%95/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E4%B8%8E%E6%B5%8B%E8%AF%95/</id>
    <published>2023-10-30T14:04:29.118Z</published>
    <updated>2023-10-30T14:04:29.118Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;软件缺陷&quot;&gt;&lt;a href=&quot;#软件缺陷&quot; class=&quot;headerlink&quot; title=&quot;软件缺陷&quot;&gt;&lt;/a&gt;软件缺陷&lt;/h2&gt;</summary>
      
    
    
    
    <category term="计算机基础学科" scheme="http://cjx_0723.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/"/>
    
    
    <category term="课堂学习" scheme="http://cjx_0723.gitee.io/tags/%E8%AF%BE%E5%A0%82%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="软件工程" scheme="http://cjx_0723.gitee.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>概率论与数理统计</title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-30T14:04:29.068Z</published>
    <updated>2023-10-30T14:04:29.068Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="概率论与数理统计笔记"><a href="#概率论与数理统计笔记" class="headerlink" title="概率论与数理统计笔记"></a>概率论与数理统计笔记</h1><p><font color=gray><em><strong>什么是统计学？</strong></em></font></p><p><font color=gray><em>人生，是从不充分的证据开始，引出完美结论的一种艺术。——Samuel Bulter</em></font></p><p><font color=gray><em>如果我们不在同一时期，把理解了的科学知识变为我们日常生活的一部分，科学家降不可能提高他们互相拥有的知识。——J.D.Bernal</em></font></p><p><font color=gray><em>与人类有关的事实，可以由数量来表示，并且经过大量的积累重复可以导出一般规律。——英国皇家统计学会</em></font></p><h1 id="一-事件与概率"><a href="#一-事件与概率" class="headerlink" title="一 事件与概率"></a>一 事件与概率</h1><h2 id="1-1-随机试验和随机事件"><a href="#1-1-随机试验和随机事件" class="headerlink" title="1.1 随机试验和随机事件"></a>1.1 随机试验和随机事件</h2><ol><li><p><strong>随机现象：</strong>自然界中的客观现象，当人们观测它时，所得结果不能预先确定，而仅仅是多种可能结果之一。</p></li><li><p><strong>随机试验：</strong>随机现象的实现和对它某个特征的观测。</p></li><li><p><strong>基本事件：</strong>随机试验中的每个单一结果，犹如分子中的原子，在化学反应中不可再分。</p><p><em>e.g. 硬币抛3次，有8种结果：正正正、正正反、正反正……这8种可能结果的每一个都是基本事件。</em></p></li><li><p><strong>随机事件：</strong>简称事件，在随机试验中我们所关心的可能出现的各种结果，它由一个或若干个基本事件组成。通常用英文大写字母表示或{一种叙述}来表示。</p></li><li><p><strong>样本空间：</strong>随机试验中所有基本事件所构成的集合，通常用$\Omega$或$S$表示。</p><p>e.g. 掷一枚骰子，观察出现的点数，则$\Omega&#x3D;{1,2,3,4,5,6}$.</p></li><li><p><strong>必然事件（$\Omega$）：</strong>在试验中一定会发生的事件。</p></li><li><p><strong>不可能事件（$\phi$）：</strong>在试验中不可能发生的事件。</p></li></ol><h2 id="1-2-事件的运算"><a href="#1-2-事件的运算" class="headerlink" title="1.2 事件的运算"></a>1.2 事件的运算</h2><ol><li><strong>子事件$$A\subset B$$：</strong>事件$A$发生蕴含时间$B$一定发生，则时间$A$成为事件$B$的子事件。若$A\subset B$，且$B\subset A$，则称时间$A$与事件$B$相等，记为$A&#x3D;B$.</li></ol><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/AsubsetB.png" style="zoom:100%;" /><ol start="2"><li><strong>事件的和（$$A\cup B$$）：</strong>事件$A$和事件$B$中至少有一个发生称为事件$A$和事件$B$的和。</li></ol><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/AcapB.png" style="zoom:100%;" /><ol start="3"><li><p><strong>事件的积（$A\cap B$）：</strong>事件$A$和事件$B$同时发生称为$A$和事件$B$的积。如果$A\cap B&#x3D;\phi$，则称$A$和$B$不相容，即事件$A$和$B$不能同时发生。</p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/AcupB.png" style="zoom:100%;" /></li><li><p><strong>对立事件$A^c$（或$\overline{A}$）：</strong>$A$不发生这一事件称为事件$A$的对立事件（或余事件）。</p></li></ol><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/notA.png" style="zoom:100%;" /><ol start="5"><li><strong>事件$A$和事件$B$的差（$A-B$）：</strong>事件$A$发生而事件$B$不发生这一事件称为事件$A$和事件$B$的差，或等价于$AB^c$.</li></ol><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/AminusB.png" style="zoom:100%;" /><ol start="6"><li><strong><em>De Morgan</em>対偶法则及其推广</strong></li></ol><p>$$<br>\overline{A\cup B}&#x3D;\overline{A}\cap \overline{B},<br>$$</p><p>$$<br>\overline{A\cap B}&#x3D;\overline{A}\cup \overline{B}<br>$$</p><p>上式可推广到<em>n</em>个事件：<br>$$<br>\overline{\bigcup_{i&#x3D;1}^{n}A_i}&#x3D;\bigcap_{i&#x3D;1}^{n}\overline{A_i},<br>$$</p><p>$$<br>\overline{\bigcap_{i&#x3D;1}^{n}A_i}&#x3D;\bigcup_{i&#x3D;1}^{n}\overline{A_i},<br>$$</p><h2 id="1-3-概率的定义"><a href="#1-3-概率的定义" class="headerlink" title="1.3 概率的定义"></a>1.3 概率的定义</h2><p>&amp;emsp;&amp;emsp;概率是随机事件发生可能性大小的数字表征，其值在0和1之间，即概率是事件的函数。概率有以下定义：</p><h3 id="1-3-1-古典概率"><a href="#1-3-1-古典概率" class="headerlink" title="1.3.1 古典概率"></a>1.3.1 古典概率</h3><p>&amp;emsp;&amp;emsp;设一个试验有<em>N</em>个等可能的结果，而事件$E$恰包含其中的$M$个结果，则事件$E$的概率，记为$P(E)$，定义为<br>$$<br>P(E)&#x3D;M&#x2F;N<br>$$<br>或<br>$$<br>P(E)&#x3D;n(M) &#x2F; n(N),<br>$$<br>其中，$n(M)$为事件$M$中基本事件的个数。</p><p>&amp;emsp;&amp;emsp;古典概型有<strong>两个条件</strong>：</p><ul><li>有限性，试验结果只有有限个（记为<em>n</em>），</li><li>等可能性，每个基本时间发生的可能性相同。</li></ul><blockquote><p><strong>注：</strong>古典概率可引申出“几何概率”。</p></blockquote><h3 id="1-3-2-概率的统计定义"><a href="#1-3-2-概率的统计定义" class="headerlink" title="1.3.2 概率的统计定义"></a>1.3.2 概率的统计定义</h3><p>&amp;emsp;&amp;emsp;古典概率的两个条件往往不能满足，但可以将事件的随机试验独立反复做<em>n</em>次（<em>Bernouli</em>试验），设事件$A$发生了$n_A$次，称比值$\frac{n_A}{n}$为事件$A$发生的频率，当<em>n</em>越来越大时，频率会在某个值<em>p</em>附近波动，且波动越来越小，这个值<em>p</em>就定义为事件$A$的概率。该学派为频率派。</p><blockquote><p><strong>注：</strong>不能写为$lim_{n\rightarrow{\infty}}\frac{n_A}{n}&#x3D;p$，因为$\frac{n_A}{n}$不是<em>n</em>的函数。</p></blockquote><h3 id="1-3-3-主观概率"><a href="#1-3-3-主观概率" class="headerlink" title="1.3.3 主观概率"></a>1.3.3 主观概率</h3><p>&amp;emsp;&amp;emsp;主观概率可以理解为一种心态或倾向性。究其根由，大抵有二：一是根据其经验和知识，二是根据其利害关系。该学派在金融和管理有大量的应用，这一学派成为<em>Bayes</em>学派。</p><h3 id="1-3-4-概率的公理化定义"><a href="#1-3-4-概率的公理化定义" class="headerlink" title="1.3.4 概率的公理化定义"></a>1.3.4 概率的公理化定义</h3><p>&amp;emsp;&amp;emsp;对概率运算规定一些简单的基本法则：</p><ol><li><p>设$A$是随机事件，则$0 \leq P(A) \leq 1$,</p></li><li><p>设$\Omega$为必然事件，则$P(\Omega)&#x3D;1$,</p></li><li><p>若事件$A$和$B$不相容，则$P(A\cup B)&#x3D;P(A)+P(B)$,</p><p>可推广至无穷：$$P(\bigcup_{i&#x3D;1}^{n}A_i)&#x3D;\sum_{i&#x3D;1}^{\infty}P(A_i)$$.</p></li></ol><blockquote><p><strong>注：</strong></p><ol><li><p>一般情况下，$P(A\cup B)&#x3D;P(A)+P(B)-P(AB)$，$P(A\cup B \cup C)&#x3D;P(A)+P(B)+P(C)-P(AB)-P(AC)-P(BC)+P(ABC)$</p></li><li><p>$P(\overline{A})&#x3D;1-P(A)$</p></li><li><p>$P(A-B)&#x3D;P(A)-P(AB)$</p></li></ol></blockquote><h2 id="1-4-古典概率计算"><a href="#1-4-古典概率计算" class="headerlink" title="1.4 古典概率计算"></a>1.4 古典概率计算</h2><h3 id="1-4-1-排列组合"><a href="#1-4-1-排列组合" class="headerlink" title="1.4.1 排列组合"></a>1.4.1 排列组合</h3><ul><li><strong>选排列：</strong>从<em>n</em>个不同元素中取<em>r</em>个不同取法（$1\leq r\leq n$），$P^{n}_{r}&#x3D;n(n-1)…(n-r+1)$.</li><li><strong>重复排列：</strong>从<em>n</em>个不同元素中可重复地取<em>r</em>个不同取法（$1\leq r\leq n$），$P^{n}_{r}&#x3D;n^r$.</li><li><strong>组合：</strong>同选排列，但不考虑次序，$\binom{n}{r}&#x3D;\frac{P^{n}_{r}}{r!}$.</li></ul><blockquote><p><strong>注：</strong></p><ol><li>排列英文为<em>Permutation</em>，组合英文为<em>Combination</em>.</li><li>$0!$为1。当<em>r</em>不是非负整数时，记号$r!$没有意义.</li><li>一些书中将组合写成$C_{n}^{r}$或$C_{r}^{n}$，更通用的是$\binom{n}{r}$.</li></ol></blockquote><h3 id="1-4-2-其他公式"><a href="#1-4-2-其他公式" class="headerlink" title="1.4.2 其他公式"></a>1.4.2 其他公式</h3><ul><li>组合系数$\binom{n}{r}$又常称为二项式系数</li></ul><p>$$<br>(a+b)^n&#x3D;\sum_{i&#x3D;0}^{n}\binom{n}{r}a^i b^{n-1}<br>$$</p><ul><li><em>n</em>个相异物件分成<em>k</em>堆，各堆物件数分为$r_1, …, r_k$的方法是</li></ul><p>$$<br>n!&#x2F;(r_1!…r_k!).<br>$$</p><h2 id="1-5-条件概率"><a href="#1-5-条件概率" class="headerlink" title="1.5 条件概率"></a>1.5 条件概率</h2><p>&amp;emsp;&amp;emsp;条件概率就是知道了<strong>一定信息</strong>下得到的随机事件的概率。设事件$A$和$B$是随机试验$\Omega$中的两个事件，$P(B)&gt;0$，称<br>$$<br>P(A|B)&#x3D;\frac{P(AB)}{P(B)}<br>$$<br>为事件$B$发生条件下事件$A$发生的条件概率，可用图形表示：</p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/con_prob.png" style="zoom:40%;" /><blockquote><p><strong>注：</strong>事实上，我们所考虑的概率都是在一定条件下计算的，因为随机试验就是在一定条件下进行的。</p></blockquote><h3 id="1-5-1-条件概率性质"><a href="#1-5-1-条件概率性质" class="headerlink" title="1.5.1 条件概率性质"></a>1.5.1 条件概率性质</h3><p>&amp;emsp;&amp;emsp;给定$A$发生，$P(A)&gt;0$：</p><ul><li>$0 \leq P(B|A) \leq 1$</li><li>$0 \leq P(\Omega|A) &#x3D; 1$</li><li>若$B_1 \cap B_2 &#x3D; \phi _1$，则$P(B_1 \cup B_2 | A) &#x3D; P(B_1|A) + P(B_2|A)$，可推广至无穷。</li></ul><h3 id="1-5-2-乘法定理"><a href="#1-5-2-乘法定理" class="headerlink" title="1.5.2 乘法定理"></a>1.5.2 乘法定理</h3><p>&amp;emsp;&amp;emsp;由$P(A|B)&#x3D;\frac{P(AB)}{P(B)} \Rightarrow P(AB)&#x3D;P(A|B)P(B)$，可推广至<br>$$<br>P(A_1 A_2 …A_n)&#x3D;P(A_1)P(A_2|A_1)…P(A_n|A_1…A_{n-1})<br>$$</p><blockquote><p><strong>注：</strong> 右边看似麻烦，其实容易算，左边看似简单，但是难算。</p></blockquote><h2 id="1-6-全概率"><a href="#1-6-全概率" class="headerlink" title="1.6 全概率"></a>1.6 全概率</h2><p>&amp;emsp;&amp;emsp;设$B_1,B_2,…B_n$是样本空间$\Omega$中的<strong>两两不相容</strong>的一组事件，即$B_i B_j&#x3D;\phi$，$i\neq j$，且满足$\bigcup_{i&#x3D;1}^{n}B_i&#x3D;\Omega$，则称$B_1,B_2,…B_n$是样本空间$\Omega$的一个分割（又称为<strong>完备事件群</strong>，英文为<em>partition</em>）。</p><p>&amp;emsp;&amp;emsp;设${B_1,B_2,…B_n}$是样本空间$\Omega$的一个分割，$A$为$\Omega$的一个事件，则<br>$$<br>P(A)&#x3D;\sum_{i&#x3D;1}^{n}P(A|B_i)P(B_i)<br>$$<br><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/full_prob.png" style="zoom:70%;" /></p><p>推导：<br>$$<br>\begin{align}<br>P(A)&amp;&#x3D;P(A \cap \Omega)\<br>&amp;&#x3D;P(A \cap \sum_{i&#x3D;1}^{n}B_i)\<br>&amp;&#x3D;P(\sum_{i&#x3D;1}^{n}AB_i)\<br>&amp;&#x3D;\sum_{i&#x3D;1}^{n}P(AB_i)\<br>&amp;&#x3D;\sum_{i&#x3D;1}^{n}P(A|B_i)P(B_i)\<br>&amp;&#x3D;\sum_{i&#x3D;1}^{n}P(A|B_i)P(B_i)<br>\end{align}<br>$$</p><blockquote><p><strong>注：</strong>有时不易直接计算事件$A$的概率，但是在每个$B_i$上$A$的条件概率容易求出</p></blockquote><h2 id="1-7-Bayes公式"><a href="#1-7-Bayes公式" class="headerlink" title="1.7 Bayes公式"></a>1.7 <em>Bayes</em>公式</h2><p>&amp;emsp;&amp;emsp;设${B_1, B_2, …B_n}$是样本空间的一个分割，$A$为$\Omega$中的一个事件，$P(B_i)&gt;0$，$i&#x3D;1,2,…,n$，$P(A)&gt;0$，则<br>$$<br>P(B_i|A)&#x3D;\frac{P(A|B_i)P(B_i)}{\sum_{j&#x3D;1}^{n}P(A|B_j)P(B_j)}&#x3D;\frac{P(A|B_i)P(B_i)}{P(A)}<br>$$</p><blockquote><p><strong>注：</strong>当有因果关系互换时必须用<em>Bayes</em>公式。</p></blockquote><h2 id="1-8-事件的独立性"><a href="#1-8-事件的独立性" class="headerlink" title="1.8 事件的独立性"></a>1.8 事件的独立性</h2><p>&amp;emsp;&amp;emsp;设$A$，$B$是随机试验中的两个事件，若满足$P(AB)&#x3D;P(A)P(B)$，则称事件$A$和$B$相互独立。判断事件的独立，应该是<strong>从实际出发</strong>，如果能够判断事件$B$的发生与否对事件$A$的发生与否不产生影响，则事件$A$，$B$即为独立。</p><p>&amp;emsp;&amp;emsp;设$\widetilde{A}$表示事件$A$发生和不发生之一，$\widetilde{B}$表示事件$B$发生和不发生之一。有独立性的定义可推至$P(\widetilde{A}\widetilde{B})&#x3D;P(\widetilde{A})P(\widetilde{B})$（一共有四个等式）。可推广至：<br>$$<br>P(\widetilde{A}_1\widetilde{A}_2…\widetilde{A}_n)&#x3D;P(\widetilde{A}_1)…P(\widetilde{A}_n)<br>$$<br>上面有$2^n$个等式。</p><blockquote><p><strong>注：</strong>独立（<em>independent</em>）和不相容（<em>exclusive</em>）是不同的两个概念，前者有公共部分，后者没有公共部分，独立一定相容。</p></blockquote><h2 id="1-9-重要公式与结论"><a href="#1-9-重要公式与结论" class="headerlink" title="1.9 重要公式与结论"></a>1.9 重要公式与结论</h2><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230920114428193.png" alt="image-20230920114428193"></p><h1 id="二-随机变量及其分布"><a href="#二-随机变量及其分布" class="headerlink" title="二 随机变量及其分布"></a>二 随机变量及其分布</h1><h2 id="2-1-随机变量的概念"><a href="#2-1-随机变量的概念" class="headerlink" title="2.1  随机变量的概念"></a>2.1  随机变量的概念</h2><ol><li><strong>随机变量（<em>Random variable</em>）：</strong>值随机会而定的变量，研究随机试验的一串事件。可按维数分为一维、二维至多维随机变量。按性质可分为<strong>离散型随机变量</strong>以及<strong>连续型随机变量</strong>。</li><li><strong>分布（<em>Distribution</em>）：</strong>事件之间的联系，用来计算概率。</li><li><strong>示性函数（<em>Indication function</em>）：</strong><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230920114505945.png" alt="image-20230920114505945" style="zoom: 50%;" />，事件$A$有随机变量$I_A$表示出来，$I_A$称为事件$A$的示性函数。</li></ol><h2 id="2-2-离散型随机变量及其分布"><a href="#2-2-离散型随机变量及其分布" class="headerlink" title="2.2 离散型随机变量及其分布"></a>2.2 离散型随机变量及其分布</h2><ol><li><p><strong>离散型随机变量：</strong>设$X$为一随机变量，如果$X$<strong>只取有限个或可数个值</strong>，则称$X$为一个（一维）离散型随机变量。</p></li><li><p><strong>概率函数：</strong>设$X$为一随机变量，其全部可能值为${a_1, a_2,…}$，则$p_i&#x3D;P(X&#x3D;a_i),i&#x3D;1,2,…$称为$X$的概率函数。</p></li><li><p><strong>概率分布：</strong>离散型随机变量的概率分布可以用分布表来表示：</p><table><thead><tr><th align="center">可能值</th><th align="center">$a_1$</th><th align="center">$a_2$</th><th align="center">…</th><th align="center">$a_i$</th><th align="center">…</th></tr></thead><tbody><tr><td align="center">概率</td><td align="center">$p_1$</td><td align="center">$p_2$</td><td align="center">…</td><td align="center">$p_i$</td><td align="center">…</td></tr></tbody></table></li><li><p><strong>概率分布函数：</strong></p><ul><li><strong>定义：</strong>设$X$为一随机变量，则函数</li></ul></li></ol><p>$$<br>F(X)&#x3D;P(X\leq x)\quad(-\infty&lt;x&lt;\infty)<br>$$</p><p>   称为$X$的分布函数。（<strong>注：这里并未限定$X$为离散型的，它对任何随机变量都有定义。</strong>）</p><ul><li><p><strong>性质：</strong></p><ul><li>$F(x)是单调非降的：当$$x_1&lt;x_2$时，有$F(x_1)\leq F(X_2)$.</li><li>当$x \rightarrow \infty$时，$F(x)\rightarrow1$；当$x \rightarrow-\infty$时，$F(x)\rightarrow0$.</li></ul></li><li><p><strong>离散型随机变量分布函数：</strong></p><p>对于离散型随机变量<img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230920113359710.png" alt="image-20230920113359710"></p></li></ul><ol start="5"><li><p><strong>二项分布（<em>Bionomial distribution</em>）</strong>：</p><ul><li><p><strong>定义：</strong>设某事件$A$在一次试验中发生的概率为$p$，先把试验独立地重复n次，以$X$记$A$在这n次试验中发生的次数，则$X$取值$0,1,…,n$，且有<br>$$<br>P(X&#x3D;k)&#x3D;\binom{n}{k}p^k(1-p)^{n-k},\quad k&#x3D;0,1,…,n<br>$$<br>称$X$服从二项分布，记为$X\sim B(n,p)$.</p></li><li><p><strong>服从二项分布的条件：</strong>1. 各次试验的条件是稳定的，即事件$A$的概率$p$在各次试验中保持不变；2. 各次试验的独立性</p></li></ul></li><li><p><strong>泊松分布（<em>Poisson distribution</em>）：</strong></p><ul><li><p><strong>定义：</strong>设随机变量$X$的概率分布为<br>$$<br>P(X&#x3D;i)&#x3D;\frac{\lambda^i}{i!}e^{-\lambda},\quad i&#x3D;0,1,2,…,\quad\lambda&gt;0<br>$$<br>则称$X$服从参数为$\lambda$的<em>Poisson</em>分布，并记$X\sim P(\lambda)$.</p></li><li><p><strong>特点：</strong></p><ul><li><p>描述稀有事件发生概率</p></li><li><p>作为二项分布的近似。若$X\sim B(n,p)$，其中$n$很大，$p$很小，而$np&#x3D;\lambda$不太大时（一般$n&gt;30,np\leq5$），则$X$的分布接近泊松分布$P(\lambda)$.</p><p><strong>推导：</strong></p><p>若事件$A\sim B(n,p)$，且$n$很大，$p$很小，而$np&#x3D;\lambda$不太大时，设$\lambda&#x3D;np$，<br>$$<br>\begin{align}<br>P(X&#x3D;i)&amp;&#x3D;\lim_{n\rightarrow \infty}\binom{n}{i}(\frac{\lambda}{n})^i(1-\frac{\lambda}{n})^{n-i}\<br>&amp;&#x3D;\lambda^i\lim_{n\rightarrow \infty}\frac{\binom{n}{i}}{n^i}\lim_{n\rightarrow \infty}(1-\frac{\lambda}{n})^{n-i}\<br>&amp;&#x3D;\lambda^i e^{-\lambda}\lim_{n\rightarrow \infty}\frac{n(n-1)(n-2)…(n-i+1)}{i!n^i}\<br>&amp;&#x3D;\lambda^i e^{-\lambda}\lim_{n\rightarrow \infty}\frac{(1-\frac{1}{n})(1-\frac{2}{n})…(1-\frac{i-1}{n})}{i!}\<br>&amp;&#x3D;\frac{\lambda^i}{i!}e^{-\lambda}<br>\end{align}<br>$$</p></li></ul></li></ul></li></ol><h2 id="2-3-连续型随机变量及其分布"><a href="#2-3-连续型随机变量及其分布" class="headerlink" title="2.3 连续型随机变量及其分布"></a>2.3 连续型随机变量及其分布</h2><ol><li><p><strong>连续型随机变量：</strong>设$X$为一随机变量，如果$X$<strong>不仅有无限个而且有不可数个值</strong>，则称$X$为一个连续型随机变量。</p></li><li><p><strong>概率密度函数：</strong></p><ul><li><p><strong>定义：</strong>设连续型随机变量$X$有概率分布函数$F(x)$，则$F(x)$的导数$f(x)&#x3D;F’(x)$称为$X$的概率密度函数。</p></li><li><p><strong>性质：</strong></p><ul><li>对于所有的$-\infty&lt;x&lt;+\infty$，有$f(x)\ge 0$；</li><li>$\int_{-\infty}^{+\infty}f(x)dx&#x3D;1$；</li><li>对于任意的$-\infty&lt;a\leq b&lt;+\infty$，有$P(a\leq X\leq b)&#x3D;F(b)-F(a)&#x3D;\int_{a}^{b}f(x)dx$.</li></ul></li><li><p><strong>注：</strong></p><ul><li>对于任意的$-\infty&lt;x&lt;+\infty$，有$P(X&#x3D;x)&#x3D;\int_{x}^{x}f(u)du&#x3D;0$.</li><li>假设有总共一个单位的质量连续地分布在$a\leq x\leq b$上，那么$f(x)$表示在点$x$的质量密度且$\int_{c}^{d}f(x)dx$表示在区间$[c, d]$上的全部质量。</li></ul></li></ul></li><li><p><strong>概率分布函数：</strong>设$X$为一连续型随机变量，则<br>$$<br>F(x)&#x3D;\int_{-\infty}^xf(u)du,\quad-\infty&lt;x&lt;+\infty<br>$$</p></li><li><p><strong>正态分布（<em>Normal distribution</em>）：</strong></p><ul><li><p><strong>定义：</strong>如果一个随机变量具有概率密度函数<br>$$<br>f(x)&#x3D;\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}},\quad -\infty&lt;x&lt;+\infty<br>$$<br>其中$-\infty&lt;\mu&lt;+\infty,\ \sigma^2&gt;0$，则称$X$为正态随机变量，并记为$X\sim N(\mu,\sigma^2)$.特别地，$\mu&#x3D;0,\sigma&#x3D;1$的正态分布成为标准正态分布。用$\Phi(x)$和$\phi(x)$表示标准正态分布$N(0,1)$的分布函数和密度函数。</p></li><li><p><strong>性质：</strong></p><ul><li>正态分布的密度函数是以$x&#x3D;\mu$为对称轴的对称函数，$\mu$称为位置参数，密度函数在$x&#x3D;\mu$处达到最大值，在$(-\infty,\mu)$和$(\mu,+\infty)$内严格单调。</li><li>$\sigma$的大小决定了密度函数的陡峭程度，通常称$\sigma$为正态分布的形状参数。</li><li>若$X\sim N(\mu,\sigma^2)$，则$Y&#x3D;(X-\mu)&#x2F;\sigma\sim N(0,1)$.</li><li>$\Phi(-k)&#x3D;1-\Phi(k)$</li></ul></li><li><p><strong>图像（密度和分布函数图）：</strong></p></li></ul></li></ol><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/normal_dense.png" style="zoom:50%;" /><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/normal_dist.png" style="zoom:50%;" /><ol start="4"><li><p><strong>指数分布（<em>Exponential distribution</em>）：</strong></p><ul><li><p><strong>定义：</strong>若随机变量$X$具有概率密度函数<br>$$<br>f(x)&#x3D;<br>\begin{cases}<br>\lambda e^{-\lambda x}&amp; x&gt;0 \<br>0&amp; x\leq 0<br>\end{cases}<br>&#x3D;\lambda e^{-\lambda x}I_{(0,\infty)}(x)<br>$$<br>其中$\lambda &gt;0$为常数，则称$X$服从参数为$\lambda$的指数分布。</p></li><li><p><strong>概率分布函数：</strong>$F(x)&#x3D;\begin{cases}<br>1-e^{-\lambda x}&amp; x&gt;0 \<br>0&amp; x\leq 0<br>\end{cases}&#x3D;(1-e^{-\lambda x})I_{(0,\infty)}(x)$</p></li><li><p><strong>性质：</strong></p><ul><li><p>无后效性，即无老化，要来描述寿命（如元件等）的分布。</p><p><strong>证明：</strong></p><p>“无老化”就是说在时刻$x$正常工作的条件下，其失效率总保持为某个常数$\lambda&gt;0$，与$x$无关，可表示</p></li><li><p>$\lambda$为失效率，失效率越高，平均寿命就越小。</p></li></ul></li><li><p><strong>图像（密度函数）：</strong></p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/exponential_dense.png" style="zoom:50%;" /></li></ul></li><li><p><strong>均匀分布（<em>Uniform distribution</em>）：</strong></p><ul><li><p><strong>定义：</strong>设$a&lt;b$，如果分布$F(x)$具有密度函数<br>$$<br>f(x)&#x3D;<br>\begin{cases}<br>\frac{1}{b-a}&amp; a\leq x\leq b \<br>0&amp; 其它<br>\end{cases}<br>&#x3D;\frac{1}{b-a}I_{(a,b)}(x)<br>$$<br>则该分布为区间$[a,b]$上的均匀分布。</p></li><li><p><strong>概率分布函数：</strong>$F(x)&#x3D;\begin{cases}<br>0&amp; x\leq a \<br>\frac{x-a}{b-a}&amp; a&lt;x\leq b\<br>1 &amp;x&gt;b<br>\end{cases}$</p></li><li><p><strong>性质：</strong>$\forall R(c,d) \subset R(a,b),\ P(c&lt;X&lt;d)&#x3D;\frac{d-c}{b-a}$</p></li></ul></li></ol><h2 id="2-4-多维随机变量（随机向量）"><a href="#2-4-多维随机变量（随机向量）" class="headerlink" title="2.4 多维随机变量（随机向量）"></a>2.4 多维随机变量（随机向量）</h2><ol><li><p><strong>随机向量：</strong>设$X&#x3D;{X_1,…,X_n}$.如果每个$X_i$都是一个随机变量，$i&#x3D;1,…,n$，则称$X$为$n$维随机变量或者随机向量。</p></li><li><p><strong>离散型随机向量的分布：</strong>如果每一个$X_i$都是一个离散型随机变量，$i&#x3D;1,…,n$，则称$X&#x3D;{X_1,…,X_n}$为一$n$维离散型随机变量。设$X_i$的所有可能取值为${a_{i1},a{i2},…},\quad i&#x3D;1,…,n$，则称<br>$$<br>p(j_1,…,j_n)&#x3D;P(X_1&#x3D;a_{1j_1},…,X_n&#x3D;a_{nj_n}),\quad j_1,…,j_n&#x3D;1,2,…<br>$$<br>为$n$维随机变量$X$的概率函数，这也是其联合分布。</p><p>其具有下列性质：</p><ul><li>$p(j_1,…,j_n)\geq0,\quad j_i&#x3D;1,2,…,\quad i&#x3D;1,2,…,n;$</li><li>$\sum_{j_1,…,j_n}p(j_1,…,j_n)&#x3D;1.$</li></ul><blockquote><p><strong>注：</strong>对于高维离散型随机变量，一般不使用分布函数</p></blockquote></li><li><p><strong>多项式分布</strong></p><ul><li><p><strong>定义：</strong>设$A_1,A_2,…,A_n$是某一试验之下的完备事件群，分别以$p_1,p_2,…,p_n$记事件$A_1,A_2,…,A_n$的概率，则$p_i\geq 0,\quad p_1+…+p_n&#x3D;1$.将试验独立地重复$N$次，以$X_i$记在这$N$次试验中事件$A_i$出现的次数$(i&#x3D;1,…,n)$，则$X&#x3D;(X_1,…,X_n)$为一个$n$维随机向量。该分布记作$M(N;p_1,…,p_n)$.</p></li><li><p><strong>概率分布函数：</strong>$P(X_1&#x3D;k_1,X_2&#x3D;k_2,…,X_n&#x3D;k_n)&#x3D;\frac{N!}{k_1!k_2!…k_n!}p_1^{k_1}p_2^{k_2}….p_n^{k_n}$</p></li></ul></li><li><p><strong>连续型随机向量的分布：</strong>$X&#x3D;{X_1,…,X_n}$为$n$维连续型随机变量，如果存在$\R^n$上的非负函数$f(x_1,…,x_n)$，使得对任意的$-\infty&lt;a_1\leq b_1&lt;+\infty,…,-\infty&lt;a_n\leq b_n &lt;+\infty$，有<br>$$<br>P(a_1\leq X_1 \leq b_1,…,a_n\leq X_n\leq b_n)&#x3D;\int_{a_n}^{b_n} …\int_{a_1}^{b_1}f(x_1,…,x_n)dx_1…dx_n<br>$$<br>则称为$f$为$X$的概率密度函数。有<br>$$<br>P(a_1\leq X_1 \leq b_1,…,a_n\leq X_n\leq b_n)&#x3D;F(x_1,…,x_n)<br>$$<br>则称为$F$为$X$的（联合）分布函数。其中分布函数$F(X_1,…,X_n)$具有下述性质：</p><ul><li>$F(x_1,…,x_n)$单调非降；</li><li>对任意的$1\leq j \leq n$，有$\lim_{x_j\rightarrow-\infty F(x_1,…,x_n)}&#x3D;0$；</li><li>$\lim_{x_1\rightarrow\infty,…,x_n\rightarrow\infty}F(x_1,…,x_n)&#x3D;1$</li></ul></li><li><p><strong>边缘分布：</strong>因为$X$的每个分量$X_i$都是一维随机变量，故它们都有各自的分布$F_i\ (i&#x3D;1,…,n)$，这些都是一维分布，称为随机向量$X$或其分布$F$的边缘分布。</p><ul><li><p><strong>离散型随机向量</strong></p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/partial_discrete.png" style="zoom:50%;" /><p>行和与列和就是边缘分布。即固定某个$x_i$，即可计算边缘分布，故有<br>$$<br>p_X(x_i)&#x3D;P(X&#x3D;x_i)&#x3D;\sum_{j}^{m}P(X&#x3D;x_i,Y&#x3D;y_j)&#x3D;\sum_{j}^{m}p_{ij}&#x3D;p_{i\cdot},\quad i&#x3D;1,2,…,n\<br>p_Y(y_i)&#x3D;P(Y&#x3D;y_i)&#x3D;\sum_{i}^{m}P(X&#x3D;x_i,Y&#x3D;y_j)&#x3D;\sum_{i}^{m}p_{ij}&#x3D;p_{j\cdot},\quad j&#x3D;1,2,…,n<br>$$</p></li><li><p><strong>连续型随机向量</strong></p><p>为求某分量$X_i$的概率密度函数，只需把$f(x_1,…,x_n)$中的$x_i$固定，然后对$x_1,…,x_{i-1},x_{i+1},…,x_n$在$-\infty$到$\infty$之间做定积分，如<br>$$<br>(X,Y)\sim f(x, y)\<br>f_X(u)&#x3D;\int^{+\infty}<em>{-\infty}f(u,v)dv\<br>f_Y(u)&#x3D;\int^{+\infty}</em>{-\infty}f(u,v)du\<br>$$</p></li></ul></li></ol><blockquote><p><strong>注：</strong>二维正态分布$N(a,b,\sigma_1^2,\sigma_2^2,\rho )$的边缘分布密度分别是一维正态分布$N(a,\sigma_1^2)$和$N(b,\sigma_2^2)$。因此联合分布可推边缘分布，而边缘分布不可推联合分布。</p></blockquote><h2 id="2-5-条件分布和随机变量的独立性"><a href="#2-5-条件分布和随机变量的独立性" class="headerlink" title="2.5 条件分布和随机变量的独立性"></a>2.5 条件分布和随机变量的独立性</h2><ol><li><p><strong>离散型随机变量的条件分布：</strong>设$(X,Y)$为二维离散型随机变量，对于给定的事件${Y&#x3D;y_j}$，其概率$P(Y&#x3D;y_j)&gt;0$，则称<br>$$<br>P(X&#x3D;x_i|Y&#x3D;y_j)&#x3D;\frac{P(X&#x3D;x_i,Y&#x3D;y_j)}{P(Y&#x3D;y_j)}&#x3D;\frac{p_{ij}}{p_{\cdot j}},\quad i&#x3D;1,2,…<br>$$<br>为在给定$Y&#x3D;y_j$的条件下$X$的条件分布律。类似的，称<br>$$<br>P(Y&#x3D;y_i|X&#x3D;x_j)&#x3D;\frac{P(X&#x3D;x_i,Y&#x3D;y_j)}{P(X&#x3D;x_j)}&#x3D;\frac{p_{ij}}{p_{i\cdot}},\quad j&#x3D;1,2,…<br>$$<br>为在给定$X&#x3D;x_j$的条件下$Y$的条件分布律。</p></li><li><p><strong>连续型随机变量的条件分布：</strong>设$(X,Y)$为二维连续型随机变量，对于给定条件$Y&#x3D;y$下的条件概率密度为<br>$$<br>f_{X|Y}(x|y)&#x3D;\frac{f(x,y)}{f_Y(y)}, \quad f_Y(y)&gt;0.\<br>$$<br>类似的，在$X&#x3D;x$下的条件概率密度为<br>$$<br>f_{Y|X}(y|x)&#x3D;\frac{f(x,y)}{f_X(x)}, \quad f_X(x)&gt;0.\<br>$$</p><blockquote><p>二维正态分布$\rho&#x3D;0$时，其联合密度分布等于条件密度分布的乘积。</p></blockquote></li><li><p><strong>随机变量的独立性</strong></p><p>称随机变量$X_1, …,X_n$相互独立，</p><ul><li><p><strong>离散型随机变量</strong></p><p>则联合分布律等于各自的边缘分布律的乘积，即<br>$$<br>P(X_1&#x3D;x_1,…,X_n&#x3D;x_n)&#x3D;P(X_1&#x3D;x_1)…P(X_n&#x3D;x_n)<br>$$<br>其中$(x_1,…x_n)$为$(X_1,…,X_n)$的值域中的任意一点。</p></li><li><p><strong>连续型随机变量</strong></p><p>则联合密度等于各自的边缘密度的乘积，即<br>$$<br>f(x_1,…,x_n)&#x3D;f_1(x_1)…f_n(x_n),\quad \forall(x_1,…,x_n)\in \R ^n<br>$$</p></li><li><p><strong>更具一般地</strong></p><p>设$X_1,…,X_n$为$n$个随机变量，如果它们的联合分布函数等于各自边缘分布函数的乘积，即<br>$$<br>F(X_1, …,x_n)&#x3D;F_1(x_1)…F_n(x_n),\quad \forall (x_1,…,x_n)\in \R^n<br>$$<br>则称随机变量$X_1, …,X_n$相互独立。</p></li></ul><blockquote><p><strong>一些重要的结论</strong></p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/conclusion.png" style="zoom:70%;" /></blockquote></li></ol><h2 id="2-6-随机变量的函数的概率分布"><a href="#2-6-随机变量的函数的概率分布" class="headerlink" title="2.6 随机变量的函数的概率分布"></a>2.6 随机变量的函数的概率分布</h2><p>&amp;emsp;&amp;emsp;最简单的情形，是由一维随机变量$X$的概率分布去求其一给定函数$Y&#x3D;g(X)$的分布。较为常见的，是由$(X_1,X_2,…,X_n)$的分布去求$Y&#x3D;g(X_1,X_2,…,X_n)$的分布。更一般地，由$(X_1,X_2,…,X_n)$的分布去求$(Y_1,Y_2,…,Y_m)$的分布，其中$Y_i&#x3D;g_i(X_1,X_2,…,X_n),\quad i&#x3D;1,2,…,m$.</p><ol><li><p><strong>离散型分布的情形：</strong>设$X$的分布律为$P(X&#x3D;x_i)&#x3D;p_i,\quad i&#x3D;1,2,…$</p><p>$g:R\rightarrow R$，令$Y&#x3D;g(X)$，则$Y$的分布律为<br>$$<br>P(Y&#x3D;y_j)&#x3D;P(g(X)&#x3D;y_j)&#x3D;\sum_{x_i:g(x_i)&#x3D;y_j}P(X&#x3D;x_i)&#x3D;\sum_{i:g(x_i)&#x3D;y_j}p_i<br>$$<br>即把$Y&#x3D;g(X_1,…,X_n)$可以取的不同值找出来，把与某个值相应的全部$(X_1,…,X_n)$值的概率加起来，即得$Y$取这个值的概率。</p></li><li><p><strong>连续型分布的情形</strong></p><ul><li><p><strong>一个变量的情况</strong></p><p>设$X$有密度函数$f(x)$.设$Y&#x3D;g(x)$，$g$是一个严格单调的函数，即当$x_1&lt;x_2$时，必有$g(x_1)&lt;g(x_2)$或当$x_1&gt;x_2$时，必有$g(x_1)&gt;g(x_2)$.又设$g$的导数$g’$存在。由于$g$的严格单调性，其反函数$X&#x3D;h(Y)$存在，且$h$的导数$h’$也存在。有$g(X)$的密度函数$l(y)$为<br>$$<br>l(y)&#x3D;f(h(y))|h’(y)|.<br>$$</p></li><li><p><strong>多个变量的情形</strong></p><p>以两个为例，设$(X_1,X_2)$的密度函数$f(x_1,x_2)$，$Y_1,Y_2$都是$(X_1,X_2)$的函数：<br>$$<br>Y_1&#x3D;g_1(X_1,X_2),\quad Y_2&#x3D;g_2(X_1,X_2),<br>$$<br>要求$(Y_1,Y_2)$的概率密度函数$l(y_1,y_2)$.假定$(X_1,X_2)$到$(Y_1,Y_2)$的一一对应变换有逆变换：<br>$$<br>X_1&#x3D;h_1(Y_1,Y_2),\quad X_2&#x3D;h_2(Y_1,Y_2)<br>$$<br>即雅可比行列式<br>$$<br>J(y_1,y_2)&#x3D;\begin{vmatrix}<br> \partial h_1&#x2F;\partial y_1&amp;\partial h_1&#x2F;\partial y_2 \<br> \partial h_2&#x2F;\partial y_1&amp;\partial h_2&#x2F; \partial y_2<br>\end{vmatrix}<br>$$<br>不为0.在$(Y1,Y2)$的平面上任取一个区域$A$，变换后到$(X_1,X_2)$平面的区域$B$，则有<br>$$<br>P((Y_1,Y_2)\in A)&#x3D;P((X_1,X_2)\in B)&#x3D;\iint_Bf(x_1,x_2)dx_1dx_2\<br>P((Y_1,Y_2)\in A)&#x3D;\iint_Af(h_1(y_1,y_2),h_2(y_1,y_2))|J(y_1,y_2)|dy_1dy_2<br>$$</p></li><li><p><strong>随机变量和的密度函数</strong></p><p>设$(X_1,X_2)$的联合密度函数为$f(x_1,x_2)$，$Y&#x3D;X_1+X_2$的密度函数：</p><ul><li>一般的，$l(y)&#x3D;\int_{-\infty}^\infty f(x_1,y-x_1)dx_1&#x3D;\int_{-\infty}^\infty f(x,y-x)dx$.</li><li>若$X_1,X_2$独立，则$l(y)&#x3D;\int_{-\infty}^\infty f_1(x)f_2(y-x)dx&#x3D;\int_{-\infty}^\infty f_1(y-x)f_2(x)dx$.</li></ul><blockquote><p>两个独立的正态变量的和仍服从正态分布，且有关的参数相加，其逆命题也成立。</p></blockquote></li><li><p><strong>随机变量商的密度函数</strong><br>设$(X_1,X_2)$的联合密度函数为$f(x_1,x_2)$，$Y&#x3D;X_1&#x2F;X_2$的密度函数：</p><ul><li>一般的，$l(y)&#x3D;\int_{0}^\infty x_1f(x_1,x_1y)dx_1$.</li><li>若$X_1,X_2$独立，则$l(y)&#x3D;\int_{0}^\infty x_1f_1(x_1)f_2(x_1y)dx_1$.</li></ul></li></ul></li></ol><ul><li><p><strong>统计学三大分布</strong></p><p>引入两个重要的特殊函数：</p><p>$\Gamma(x)&#x3D;\int_0^\infty e^{-t}t^{x-1}dt\quad (x&gt;0)$ 和 $B(x,y)&#x3D;\int_0^1t^{x-1}(1-t)^{y-1}dt\quad (x&gt;0,y&gt;0)$</p><blockquote><p>其中，$\Gamma(1)&#x3D;1,\quad \Gamma(1&#x2F;2)&#x3D;\sqrt{\pi},\quad \Gamma(n)&#x3D;(n-1)!$</p><p>$B(x,y)&#x3D;\Gamma(x)\Gamma(y)&#x2F;\Gamma(x+y)$</p></blockquote><ul><li><p><strong>卡方分布，记作$\chi_n^2$</strong></p><p><strong>密度函数：</strong>$k_n(x)&#x3D;\frac{1}{\Gamma(\frac{n}{2}2^{n&#x2F;2})}e^{-x&#x2F;2}x^{(n-2)&#x2F;2}I_{(0,\infty)}(x)$</p><p><strong>性质：</strong>1. 设$X_1,X_2$独立，$X_1\sim\chi_m^2,X_2\sim\chi_n^2$，则$X_1+X_2\sim\chi_{m+n}^2$</p><p>​    2. 若$X_1,…,X_n$独立，且都服从指数分布，则$X&#x3D;2\lambda(X_1+…+X_n)\sim\chi_{2n}^2$</p></li><li><p><strong>$t$分布，记作$t_n$</strong></p><p>设$X_1，X_2$独立，$X_1\sim\chi_n^2,X_2\sim N(0,1)$，而$Y&#x3D;X_2&#x2F;\sqrt{X_1&#x2F;n}$，则$Y\sim t_n$.</p><p><strong>密度函数：</strong>$t_n(y)&#x3D;\frac{\Gamma((n+1)&#x2F;2)}{\sqrt{n\pi}\Gamma(n&#x2F;2)}(1+\frac{y^2}{n})^{(\frac{n+1}{2})}$</p><p><strong>性质：</strong>密度函数关于原点对称，其图形与正态分布$N(0,1)$的密度函数的图形相似。</p></li><li><p><strong>$F$分布，记作$F_{mn}$</strong></p><p>设$X_1,X_2$独立，$X_1\sim\chi_n^2,X_2\sim\chi_m^2$，而$Y&#x3D;m^{-1}X_2&#x2F;(n^{-1}X_1)$，则$Y\sim F_{mn}$</p><p><strong>密度函数：</strong>$f_{mn}(y)&#x3D;m^{m&#x2F;2}n^{n&#x2F;2}\frac{\Gamma(\frac{m+n}{2})}{\Gamma(\frac{m}{2})\Gamma(\frac{n}{2})}y^{m&#x2F;2-1}(my+n)^{-(m+n)&#x2F;2}\quad (y&gt;0)$</p></li></ul><blockquote><p><strong>三大分布的几个重要性质</strong></p><ol><li><p>设$X_1,…,X_n$独立同分布，有公共的正态分布$N(\mu,\sigma^2)$.记$\bar{X}&#x3D;(X_1+…+X_n),S^2&#x3D;\sum_{i&#x3D;1}^{n}(X_i-\bar(X))^2&#x2F;(n-1)$.则$(n-1)S^2&#x2F;\sigma^2&#x3D;\sum_{i&#x3D;1}^{n}(X_i-\bar{X})^2&#x2F;\sigma^2\sim\chi_{n-1}^{2}$.</p></li><li><p>设$X_1,…,X_n$的假定同1，则$\sqrt{n}(\bar{X}-\mu)&#x2F;S\sim t_{n-1}$</p></li><li><p>设$X_1,…,X_n,Y_1,…,Y_m$独立，$X_i$各有分布$N(\mu1,\sigma_1^2)$，$Y_j$各有分布$N(\mu_2,\sigma_2^2)$，则<br>$$<br>[\sum_{j&#x3D;1}^m(Y_j-\bar{Y})^2&#x2F;(\sigma_2^2(m-1))]&#x2F;[\sum_{i&#x3D;1}^n(X_i-\bar{X})^2&#x2F;(\sigma_1^2(n-1))]\sim F_{m-1,n-1}<br>$$<br>若$\sigma_1^2&#x3D;\sigma_2^2$，则<br>$$<br>\sqrt{\frac{nm(n+m-2)}{n+m}}[(\bar{X}-\bar{Y})-(\mu_1-\mu_2)]&#x2F;[\sum_{i&#x3D;1}^{n}(X_i-\bar{X})^2+\sum_{j&#x3D;1}^m(Y_j-\bar{Y})^2]^{1&#x2F;2}\sim t_{n+m-2}<br>$$</p></li></ol></blockquote></li></ul><h1 id="三-随机变量的数字特征"><a href="#三-随机变量的数字特征" class="headerlink" title="三 随机变量的数字特征"></a>三 随机变量的数字特征</h1><h2 id="3-1-数学期望（均值）与中位数"><a href="#3-1-数学期望（均值）与中位数" class="headerlink" title="3.1 数学期望（均值）与中位数"></a>3.1 数学期望（均值）与中位数</h2><ol><li><p><strong>数学期望</strong></p><ul><li><p><strong>定义：</strong>设随机变量$X$只取有限个可能值$a_1,…,a_m$，其概率分布为$P(X&#x3D;a_i)&#x3D;p_i\ (i&#x3D;1,…,m)$.则$X$的数学期望记作$E(X)^*$或$E(X)$，定义为$E(X)&#x3D;a_1p_1+a_2p_2+…+a_mp_m$.数学期望也常称为”均值“，即指以概率为权的加权平均。</p></li><li><p><strong>离散型变量的数学期望：</strong>$E(X)&#x3D;\sum^\infty_{i&#x3D;1}a_ip_i.$（当级数绝对收敛，即$\sum_{i&#x3D;1}^\infty|a_i|p_i&lt;\infty$）</p></li><li><p><strong>连续型变量的数学期望：</strong>$E(X)&#x3D;\int_{-\infty}^\infty xf(x)dx$.（当$\int_{-\infty}^\infty |x|f(x)dx&lt;\infty$）</p></li><li><p><strong>常见分布的数学期望：</strong></p><ul><li><p><strong>泊松分布：</strong>$E(X)&#x3D;\lambda$.</p></li><li><p><strong>二项分布：</strong>$E(X)&#x3D;np$.</p></li><li><p><strong>均匀分布：</strong>$E(X)&#x3D;\frac{1}{2}(a+b)$.</p></li><li><p><strong>指数分布：</strong>$E(X)&#x3D;\lambda^{-1}$.</p></li><li><p><strong>正态分布：</strong>$E(X)&#x3D;\mu$.</p></li><li><p><strong>卡方分布：</strong>$E(X)&#x3D;n$.</p></li><li><p><strong>$t$分布：</strong>$E(X)&#x3D;0 \quad (n&gt;1)$.</p></li><li><p><strong>$F$分布：</strong>$E(X)&#x3D;n&#x2F;(n-2)\quad (n&gt;2)$.</p></li></ul></li><li><p><strong>性质：</strong></p><ul><li>若干个随机变量之和的期望等于各变量的期望值和，即<br>$$<br>E(X_1+X_2+…+X_n)&#x3D;E(X_1)+E(X_2)+…+E(X_n).<br>$$</li><li>若干个<strong>独立</strong>随机变量之积的期望等于各变量的期望之积，即<br>$$<br>E(X_1X_2…X_n)&#x3D;E(X_1)E(X_2)…E(X_n).<br>$$</li><li>设随机变量$X$为离散型，有分布$P(X&#x3D;a_i)&#x3D;p_i(i&#x3D;1,2,…)$；或者为连续型，有概率密度函数$f(x)$.则</li></ul><p>$$<br>E(g(x))&#x3D;\sum_ig(a_i)p_i\quad (当\sum_i|g(a_i)|p_i&lt;\infty时) \<br>或\<br>E(g(x))&#x3D;\int_{-\infty}^\infty g(x)f(x)dx \quad (当\int_{-\infty}^{\infty}|g(x)|f(x)dx&lt;\infty时)<br>$$</p><ul><li>若$c$为常数，则$E(cX)&#x3D;cE(X)$.</li></ul></li></ul></li><li><p><strong>条件数学期望</strong></p><ul><li><strong>定义：</strong>随机变量Y的条件期望就是它在给定的某种附加条件下的数学期望。$E(Y|x)&#x3D;\int_{-\infty}^{\infty}yf(y|x)dy$.它反映了随着$X$取值$x$的变化$Y$的平均变化的情况如何。在统计上，常把条件期望$E(Y|x)$作为$x$的函数，称为$Y$对$X$的回归函数。</li><li><strong>性质：</strong><ul><li>$E(Y)&#x3D;\int_{-\infty}^{\infty}E(Y|x)f_X(x)dx$.</li><li>$E(Y)&#x3D;E[E(Y|X)]$.</li></ul></li></ul></li><li><p><strong>中位数</strong></p><ul><li><strong>定义：</strong>设连续型随机变量$X$的分布函数为$F(x)$，则满足条件$P(X\leq m)&#x3D;F(m)&#x3D;1&#x2F;2$的数$m$称为$X$或分布$F$的中位数。即$m$这个点把$X$的分布从概率上一切两半。</li><li><strong>性质：</strong><ul><li>与期望值相比，中位数受特大值或特小值影响很小，而期望不然。</li><li>中位数可能不唯一，且在某些离散型情况下，中位数不能达到一分两半的效果。</li></ul></li></ul></li></ol><h2 id="3-2-方差与矩"><a href="#3-2-方差与矩" class="headerlink" title="3.2 方差与矩"></a>3.2 方差与矩</h2><ol><li><p><strong>方差与标准差</strong></p><ul><li><strong>定义：</strong>设$X$为随机变量，分布为$F$，则$Var(X)&#x3D;E(X-EX)^2$称为$X$（或分布$F$）的方差，其平方根$\sqrt{Var(X)}$（取正值）称为$X$（或分布$F$）的标准差。</li><li><strong>常见分布的方差：</strong><ul><li><strong>泊松分布：</strong>$Var(X)&#x3D;\lambda$.</li><li><strong>二项分布：</strong>$Var(X)&#x3D;np(1-p)$.</li><li><strong>正态分布：</strong>$Var(X)&#x3D;\sigma^2$.</li><li><strong>指数分布：</strong>$Var(X)&#x3D;1&#x2F;\lambda^2$.</li><li><strong>均匀分布：</strong>$Var(X)&#x3D;(b-a)^2&#x2F;12$.</li><li><strong>卡方分布：</strong>$Var(X)&#x3D;2n$.</li><li><strong>$t$分布：</strong>$Var(X)&#x3D;n&#x2F;(n-2)$.</li><li><strong>$F$分布：</strong>$Var(X)&#x3D;2n^2(m+n-2)&#x2F;[m(n-2)^2(n-4)]\quad (n&gt;4)$.</li></ul></li><li><strong>性质：</strong><ul><li>$Var(X)&#x3D;E(X^2)-(EX)^2$.</li><li>常数的方差为0，即$Var(c)&#x3D;0$.</li><li>若$c$为常数，则$Var(X+c)&#x3D;Var(X)$.</li><li>若$c$为常数，则$Var(cX)&#x3D;c^2Var(X)$.</li><li><strong>独立</strong>随机变量和的方差等于各变量方差和，即$Var(X_1+…+X_n)&#x3D;Var(X_1)+…+Var(X_n)$.</li></ul></li></ul></li><li><p><strong>矩</strong></p><ul><li><p><strong>定义：</strong>设$X$为随机变量，$c$为常数，$k$为正整数。则量$E[(X-c)^k]$称为$X$关于$c$点的$k$阶矩。特别地，有两种重要的情况：</p><p>(1) $c&#x3D;0$ .这时$a_k&#x3D;E(X^k)$称为$X$的$k$阶原点矩。</p><p>(2)$c&#x3D;E(X)$.这时$\mu_k&#x3D;E[(X-EX)^k]$称为$X$的$k$阶中心矩。</p><p>一阶原点矩就是期望，一阶中心距$\mu_1&#x3D;0$，二阶中心距$\mu_2$就是$X$的方差$Var(X)$.</p></li><li><p><strong>两种重要应用：</strong></p><ul><li><strong>偏度系数：</strong>$\beta_1&#x3D;\mu_3&#x2F;\mu_2^{3&#x2F;2}$.衡量概率分布函数$f(x)$是否关于均值对称。如果$\beta&gt;0$，则称分布为正偏或右偏；如果$\beta&lt;0$，则称分布为负偏或左偏；如果$\beta&#x3D;0$，则对称。（注：$\mu_2^{3&#x2F;2}$为标准差的三次方，可将$\mu_3$缩放到一次因次）</li><li><strong>峰度系数：</strong>$\beta_2&#x3D;\mu_4&#x2F;\mu_2^2$.衡量概率分布函数$f(x)$在均值附近的陡峭程度。若$X$有正态分布$N(\mu,\sigma^2)$，则$\beta_2&#x3D;3$.(注：$\mu_2^2$为标准差的四次方，将$\mu_4$缩放到一次因次。为了迁就正态分布，也常定义$\mu_4&#x2F;\mu_2^2-3$为峰度系数，以使正态分布的峰度系数为0)</li></ul></li></ul></li></ol><h2 id="3-3协方差与相关系数"><a href="#3-3协方差与相关系数" class="headerlink" title="3.3协方差与相关系数"></a>3.3协方差与相关系数</h2><p>&amp;emsp;&amp;emsp;两者都反映了随机变量之间的关系。</p><ol><li><p><strong>协方差（<em>Covariance</em>）</strong></p><ul><li><strong>定义：</strong>称$E[(X-m_1)(Y-m_2)]$为$X$，$Y$的协方差，并记为$Cov(X,Y)$.</li><li><strong>性质：</strong><ul><li>$Cov(X,Y)$与$X,Y$的次序无关，即$Cov(X,Y)&#x3D;Cov(Y,X)$.</li><li>$Cov(c_1X+c_2,c_3Y+c_4)&#x3D;c_1c_3Cov(X,Y)$.</li><li>$Cov(X,Y)&#x3D;E(XY)-E(X)E(Y)$.</li><li>若$X,Y$独立，则$Cov(X,Y)&#x3D;0$.</li><li>$[Cov(X,Y)]^2\leq \sigma_1^2\sigma_2^2$.等号当且仅当$X,Y$之间有严格线性关系（$Y&#x3D;a+bX$）时成立。</li></ul></li></ul><blockquote><p><strong>注：</strong>协方差的结果受随机变量量纲影响。</p></blockquote></li><li><p><strong>相关系数（<em>Correlation coefficient</em>）</strong></p><ul><li><strong>定义：</strong>称$Cov(X,Y)&#x2F;(\sigma_1\sigma_2)$为$X,Y$的相关系数，并记为$Corr(X,Y)$.</li><li><strong>性质：</strong><ul><li>若$X,Y$独立，则$Corr(X,Y)&#x3D;0$.</li><li>$-1\leq Corr(X,Y)\leq 1$，或$|Corr(X,Y)\leq 1|$，等号当且仅当$X$和$Y$有严格线性关系时达到。当$Corr(X,Y)&#x3D;0$时，推出$X,Y$不线性相关。</li></ul></li></ul><blockquote><p><strong>注：</strong>相关系数常称为“<strong>线性相关系数</strong>”，实际上相关系数并不是刻画了$X,Y$之间<strong>消除量纲后</strong>“一般”关系的程度，而只是“线性关系的程度”。即使$X$与$Y$有某种严格的函数关系但非线性关系，$|Corr(X,Y)|$不仅不必为1，还可以为0.</p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/correlation.png" style="zoom:100%;" /></blockquote></li></ol><h2 id="3-4大数定理和中心极限定理"><a href="#3-4大数定理和中心极限定理" class="headerlink" title="3.4大数定理和中心极限定理"></a>3.4大数定理和中心极限定理</h2><ol><li><p><strong>大数定理</strong></p><p>“大数”的意思，就是指涉及大量数目的观察值$X_i$，它表明这种定理中指出的现象只有在大量次数的试验和观察之下才能成立。</p><ul><li><strong>定义：</strong>设$X_1,X_2,…,X_n,…$是独立同分布的随机变量，记它们的公共均值为$a$.又设它们的方差存在并记为$\sigma^2$.则对任意给定的$\varepsilon &gt;0$，有$lim_{n\rightarrow\infty}P(|\bar{X}_n-a|\geq \varepsilon )&#x3D;0$.（该式表明，当$n$很大时，$\bar{X}_n$接近$a$）</li></ul></li><li><p><strong>中心极限定理</strong></p><p>即和的分布收敛于正态分布。</p><ul><li><p><strong>定义：</strong>设$X_1,X_2,…,X_n$为独立同分布的随机变量，$E(X_i)&#x3D;a,Var(X_i)&#x3D;\sigma^2(0&lt;\sigma^2&lt;\infty)$.则对任何实数$x$，有$lim_{n\rightarrow\infty}P(\frac{1}{\sqrt{n}\sigma}(X_1+…+X_n-na)\leq x)&#x3D;\Phi(x)$.（$\Phi(x)$为标准正态分布$N(0,1)$的分布函数）</p></li><li><p><strong>特例：</strong>设$X_1,X_2,…,X_n$独立同分布，$X_i$分布是$P(X_i&#x3D;1)&#x3D;p$，$P(X_i&#x3D;0)&#x3D;1-p\ (0&lt;p&lt;1)$.则对任何实数$x$，有$lim_{n\rightarrow \infty}P(\frac{1}{\sqrt{np(1-p)}}(X_1+…+X_n-np)\leq x)&#x3D;\Phi(x)$.</p><blockquote><p><strong>注：</strong>如果$t_1,t_2$是两个正整数，$t_1&lt;t_2$.则当$n$相当大时，近似地有</p></blockquote></li></ul></li></ol><blockquote><p>$$<br>P(t_1\leq X_1+…+X_n\leq t_2)\approx \Phi(y_2)-\Phi(y_1),<br>$$<br>其中<br>$$<br>y_i&#x3D;(t_i-np)&#x2F;sqrt{np(1-p)}\quad (i&#x3D;1,2).<br>$$<br>若把$y_1,y_2$修正为<br>$$<br>y_1&#x3D;(t_1-\frac{1}{2}-np)&#x2F;\sqrt{np(1-p)},\<br>y_2&#x3D;(t_2-\frac{1}{2}-np)&#x2F;\sqrt{np(1-p)}<br>$$<br>在应用上式，则一般可提高精度。</p></blockquote><h1 id="四-统计量及其分布"><a href="#四-统计量及其分布" class="headerlink" title="四 统计量及其分布"></a>四 统计量及其分布</h1><p><mark>该部分后续需拓展</mark></p><h2 id="4-1-总体与样本"><a href="#4-1-总体与样本" class="headerlink" title="4.1 总体与样本"></a>4.1 <strong>总体与样本</strong></h2><ol><li><p><strong>总体</strong></p><p>&amp;emsp;&amp;emsp;在一个统计问题里，研究对象的全体叫做总体，构成总体的每个成员称为个体。根据个体的数量指标数量，定义总体的维度，如每个个体只有一个数量指标，总体就是一维的，同理，个体有两个数量指标，总体就是二维的。<strong>总体就是一个分布，数量指标就是服从这个分布的随机变量。</strong><br>&amp;emsp;&amp;emsp;总体根据个体数分为<strong>有限总体</strong>和<strong>无限总体</strong>，当有限总体的个体数充分大时，其可以看为无限总体。</p></li><li><p><strong>样本</strong></p><ul><li><strong>定义：</strong></li></ul><p>&amp;emsp;&amp;emsp;从总体中随机抽取的部分个体组成的集合称为样本，<strong>样本个数称为样本容量</strong>。</p><ul><li><p><strong>性质：</strong></p><ul><li><p><strong>二重性：</strong>抽取前随机，是随机变量；抽取后确定，是一组数值。</p></li><li><p><strong>随机性：</strong>每个个体都有同等的机会被选入样本。</p></li></ul></li><li><p><strong>独立性：</strong>每个样本的取值不影响其他样本取值，即分部独立。</p><p>满足后面两个性质称为<strong>简单随机样本</strong>，则<br>$$<br>F(x_1,x_2,…,x_n)&#x3D;\prod^n_{i&#x3D;1}F(x_i),\<br>f(x_1,x_2,…,x_n)&#x3D;\prod^n_{i&#x3D;1}f(x_i),\<br>p(x_1,x_2,…,x_n)&#x3D;\prod^n_{i&#x3D;1}p(x_i)<br>$$</p></li></ul></li><li><p><strong>分组样本</strong></p><p>&amp;emsp;&amp;emsp;只知样本观测值所在区间，而不知具体值的样本称为分组样本。<strong>缺点：</strong>与完全样本相比损失部分信息。<strong>优点：</strong>在样本量较大时，用分组样本既简明扼要，又能帮助人们更好地认识总体。</p></li></ol><h2 id="4-2-样本数据的整理与显示"><a href="#4-2-样本数据的整理与显示" class="headerlink" title="4.2 样本数据的整理与显示"></a>4.2 样本数据的整理与显示</h2><ol><li><p><strong>经验分布函数</strong></p><p>&amp;emsp;&amp;emsp;若将样本观测值$x_1,x_2,…,x_n$由小到大进行排列，得到有序样本$x_{(1)}\leq x_{(2)}\leq…\leq x_{(n)}$，用有序样本定义如下函数<br>$$<br>F_n(x)&#x3D;\left{\begin{matrix}<br>0 &amp; 当x&lt;x_{(1)}\<br>k&#x2F;n &amp; 当x_{(k)}\leq x&lt;x_{(k+1)},k&#x3D;1,2,…,n-1\<br>1 &amp; 当x\geq x_{(n)}<br>\end{matrix}\right.<br>$$<br>则称为$F_n(x)$为该样本的经验分布函数。</p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/ex_distribution.png" style="zoom:100%;" /></li><li><p><strong>格里纹科定理</strong></p><p>&amp;emsp;&amp;emsp;设$x_1,x_2,…,x_n$是取自总体分布函数为$F(x)$的样本，$F_n(x)$是该样本的经验分布函数，则当$n\rightarrow+\infty$时，有<br>$$<br>P(sup_{-\infty&lt;x&lt;+\infty}|F_n(x)-F(x)|\rightarrow0)&#x3D;1<br>$$<br>表明当n相当大时，经验分布函数$F_n(x)$是总体分布函数$F(x)$的一个良好的近似。它是经典统计学的一块基石。</p></li><li><p><strong>频数频率分布表</strong></p><p>&amp;emsp;&amp;emsp;有样本$x_1,x_2,…,x_n$制作频数频率分布表的操作步骤如下：</p><ul><li>确定组数k；</li><li>确定每组组距，通常取每组组距相等为d（方便起见，可选为整数）；</li><li>确定组限（下限$a_0$略小于最小观测值，上限$a_k$略大于最大观测值）；</li><li>统计样本数据落入每个区间的频数，并计算频率。</li></ul><p>该表能够简明扼要地把样本特点表示出来。不足之处是该表依赖于分组，不同的分组方式有不同的频数频率分布表。</p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/frequency.png" style="zoom:50%;" /></li><li><p><strong>直方图</strong></p><ul><li>利用频数频率分布表上的区间（横坐标）和频数（纵坐标）可作为频数直方图；</li><li>若把纵坐标改为频率就得频率直方图；</li><li>若把纵坐标改为频率&#x2F;组距，就得到单位频率直方图。这时长条矩形的面积之和为1.</li></ul><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/hist.png" style="zoom:100%;" /></li><li><p><strong>茎叶图</strong></p><p>&amp;emsp;&amp;emsp;把样本中的每个数据分为茎与叶，把茎放于一侧，叶放于另一侧，就得到一张该样本的茎叶图。比较两个样本时，可画出背靠背的茎叶图。茎叶图保留数据中全部信息，当样本量较大，数据很分散，<strong>横跨二、三个数量级时，茎叶图并不适用</strong>。</p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/leave.jpg" style="zoom:100%;" /></li></ol><h2 id="4-3-统计量及其分布"><a href="#4-3-统计量及其分布" class="headerlink" title="4.3 统计量及其分布"></a>4.3 统计量及其分布</h2><ol><li><p><strong>统计量</strong></p><p>&amp;emsp;&amp;emsp;不含未知参数的样本函数称为统计量。统计量的分布称为抽样分布。</p></li><li><p><strong>样本均值</strong></p><ul><li><p><strong>定义：</strong></p><p>&amp;emsp;&amp;emsp;样本$x_1,x_2,…,x_n$的算数平均值称为样本均值，记为$\bar{x}$.分组样本均值$\bar{x}&#x3D;\frac{1}{n}\sum_{i&#x3D;1}^{k}x_if_i$，其中n为样本量，k为组数，**$x_i$与$f_i$为第i组的组中值和频率<strong>，</strong>分组样本均值是完全样本均值的一种较好的近似**。</p><p>&amp;emsp;&amp;emsp;样本均值是样本的位置特征，样本中大多数值位于$\bar{x}$左右。平均可消除一些随机干扰，等价交换也是在平均数中实现的。</p></li><li><p><strong>性质：</strong></p><ul><li>$\sum_{i&#x3D;1}^n (x_i-\bar{x})&#x3D;0$，<strong>样本数据$x_i$对样本均值$\bar{x}$的偏差之和为零</strong>；</li><li><strong>样本数据$x_i$与样本均值$\bar{x}$的偏差平方和最小</strong>，即对任意的实数c有$\sum_{i&#x3D;1}^n(x_i-\bar{x})^2\leq \sum_{i&#x3D;1}^n(x_i-c)^2$;</li><li>若总体分布为$N(\mu,\sigma^2)$，则$\bar{x}$的精确分布为$N(\mu,\sigma^2&#x2F;n)$；</li><li>若总体分布未知，但其期望$\mu$与方差$\sigma^2$存在，则当n较大时，$\bar{x}$的渐进分布为$N(\mu,\sigma^2&#x2F;n)$，这里渐进分布是指n较大时的近似分布。</li></ul></li></ul></li><li><p><strong>样本方差与样本标准差</strong></p><p>&amp;emsp;&amp;emsp;样本方差有两种，$s_*^2&#x3D;\frac{1}{n}\sum_{i&#x3D;1}^n(x_i-\bar{x})^2$与$s^2&#x3D;\frac{1}{n-1}\sum_{i&#x3D;1}^n(x_i-\bar{x})^2$，后者为无偏方差，也是最常用的。（这是因为当$\sigma^2$为总体方差时，总有$E(s_*^2)&#x3D;\frac{n-1}{n}\sigma^2$,$E(s^2)&#x3D;\sigma^2$，表明$s_*^2$有系统偏小的误差，$s^2$无此系统偏差。）称$\sqrt{s^2}$为样本标准差。</p><p>&amp;emsp;&amp;emsp;样本方差是样本的散布特征，$s^2$<strong>越大样本越分散，$s^2$越小分布越集中</strong>，样本标准差比样本方差使用更频繁，因为前者和样本均值有着相同的单位。</p><p>&amp;emsp;&amp;emsp;$s^2$的计算有如下<strong>三个公式</strong>可供选用：<br>$$<br>s^2&#x3D;\frac{1}{n-1}\sum(x_i-\bar{x})^2&#x3D;\frac{1}{n-1}[\sum x_i^2-\frac{(\sum x_i)^2}{n}]&#x3D;\frac{1}{n-1}(\sum x_i^2-n\bar{x}^2)<br>$$<br>在分组样本场合，样本方差的近似计算公式为<br>$$<br>s^2&#x3D;\frac{1}{n-1}\sum_{i&#x3D;1}^kf_i(x_i-\bar{x})^2&#x3D;\frac{1}{n-1}(\sum_{i&#x3D;1}^k f_ix_i^2-n\bar{x}^2)<br>$$<br>其中k为组数，$x_i,f_i$分别为第i个区间的组中值与频数，$\bar{x}$为分组样本的均值。</p></li><li><p><strong>样本矩及其函数</strong></p><ul><li>样本的k阶原点矩$a_k&#x3D;\frac{1}{n}\sum_{i&#x3D;1}^{n}x_i^k$，样本均值$\bar{x}$为样本的一阶原点矩；</li><li>样本的k阶中心距$b_k&#x3D;\frac{1}{n}\sum_{i&#x3D;1}^n(x_i-\bar{x})^k$，样本方差$s^2$和$s_*^2$都为样本的二阶中心矩；</li><li>样本变异系数$C_r&#x3D;s&#x2F;\bar{x}$；</li><li>样本的偏度$\hat{\beta_s}&#x3D;b_3&#x2F;b_2^{3&#x2F;2}$，反映样本数据与对称性偏离程度和偏离方向；</li><li>样本的峰度$\hat{\beta_k}&#x3D;\frac{b_4}{b_2^2}-3$，反映总体分布密度曲线在其峰值附近的陡峭程度和尾部粗细.</li></ul></li></ol><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/skewness.png" style="zoom:100%;" /><ol start="5"><li><p><strong>次序统计量及其分布</strong></p><p>&amp;emsp;&amp;emsp;设$x_1,…,x_n$是取自某总体的一个样本，$x_{(i)}$称为该样本的第i个次序统计量（升序排序后，第i个样本）。</p><ul><li>$x_{(1)}&#x3D;min{x_1,…,x_n}$称为该样本的<strong>最小次序统计量</strong>；</li><li>$x_{(n)}&#x3D;max{x_1,…,x_n}$称为该样本的<strong>最大次序统计量</strong>；</li><li>$(x_{(1)},x_{(2)},…,x_{(n)}}$称为该样本的次序统计量，即<strong>不独立也不同分布</strong>；</li><li>$R&#x3D;x_{(n)}-x_{(1)}$称为样本极差。<br>设总体$X$的密度函数为$f(x)$，分布函数为$F(x)$，$x_1,…,x_n$为样本，则有</li><li>样本第k个次序统计量$x_{(k)}$的密度函数为<br>$$<br>f_k(x)&#x3D;\frac{n!}{(k-1)!(n-k)!}(F(x))^{k-1}(1-F(x))^{n-k}f(x);<br>$$</li><li>样本第i个与第j个次序统计量的联合密度函数为<br>$$<br>f_{ij}(y,z)&#x3D;\frac{n!}{(i-1)!(j-i-1)!(n-j)!}(F(y))^{i-1}(F(z)-F(y))^{j-i-1}(1-F(z))^{n-j}f(xy)f(z),\quad y\leq z, 1\leq i&lt;j\leq n<br>$$</li></ul></li><li><p><strong>样本中位数与样本分位数</strong></p><p>设$x_1,…,x_n$是取自某总体的样本，$x_{(1)}\leq x_{(2)}\leq …\leq x_{(n)}$为该样本的次序统计量，则样本中位数$m_{0.5}$定义为<br>$$<br>m_{0.5}&#x3D;\left{\begin{matrix}<br>x_{(\frac{n+1}{2})} &amp; n为奇数\<br>\frac{1}{2}(x_{(\frac{n}{2})} + x_{(\frac{n}{2}+1)}) &amp; n为偶数<br>\end{matrix}\right.<br>$$<br>样本的p分位数$m_p$定义为<br>$$<br>m_{p}&#x3D;\left{\begin{matrix}<br>x_{[np+1]} &amp; np不是整数\<br>\frac{1}{2}(x_{(np)} + x_{(np+1)}) &amp; np是整数<br>\end{matrix}\right.<br>$$<br>其中[x]表示向下取整。<strong>中位数对样本的极端值有抗干扰性，或称有稳健性</strong>。<br><strong>样本分位数的渐近分布：</strong>设总体的密度函数为$f(x)$，$x_p$为总体的p分位数。若$p(x)$在$x_p$处连续且$p(x_p)&gt;0$，则当n充分大时，有<br>$$<br>m_p\sim N(x_p,\frac{p(1-p)}{n\cdot p^2(x_p)}),\<br>m_{0.5}\sim N(x_{0.5},\frac{1}{4n\cdot p^2(x_{0.5})})<br>$$</p></li><li><p><strong>五数概括与箱线图</strong></p><p>&amp;emsp;&amp;emsp;五数指用样本的五个次序统计量，即最小观测值，最大观测值，中位数，第一4分位数和第三4分位数。其图形为箱线图，可描述样本分布形状。</p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/box.png" style="zoom:70%;" /><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/box_normal.png" style="zoom:70%;" /></li></ol><h1 id="五-参数估计"><a href="#五-参数估计" class="headerlink" title="五 参数估计"></a>五 参数估计</h1><p>&amp;emsp;&amp;emsp;统计学与概率论的区别就是归纳和演绎，前者通过样本推测总体的分布，而后者已知总体分布去研究样本。因此参数估计则是归纳的过程，参数估计有两种形式：<strong>点估计</strong>和<strong>区间估计</strong><u>（点估计和区间估计都是对于未知参数的估计，而<strong>点估计给出的是一个参数可能的值</strong>，<strong>区间估计给出的是参数可能在的范围</strong>）</u>。</p><h2 id="5-1-点估计"><a href="#5-1-点估计" class="headerlink" title="5.1 点估计"></a>5.1 点估计</h2><h3 id="5-1-1-点估计的概念"><a href="#5-1-1-点估计的概念" class="headerlink" title="5.1.1 点估计的概念"></a>5.1.1 点估计的概念</h3><p><strong>点估计（<em>Point estimation</em>）：</strong>设$x_1, …, x_n$是来自总体的一个样本，用于估计未知参数$\theta$的统计量$\hat{\theta}&#x3D;\hat{\theta}(x_1,…,x_n)$成为$\theta$的估计量，或称为$\theta$的点估计。</p><h3 id="5-1-2-点估计的方法"><a href="#5-1-2-点估计的方法" class="headerlink" title="5.1.2 点估计的方法"></a>5.1.2 点估计的方法</h3><ol><li><p><strong>矩估计</strong></p><p><strong>定义：</strong>设总体概率函数已知，为$p(x;\theta_1,…,\theta_k)$，$(\theta_1,…,\theta_k)\in\Theta$是未知参数或参数向量，$x_1,…,x_n$是样本，假定总体的$k$阶原点矩$\mu_k$存在，则对所有的$j$，$o&lt;j&lt;k$，$\mu_j$都存在，若假设$\theta_1,…,\theta_k$能够表示成$\mu_1,…,\mu_k$的函数$\theta_j&#x3D;\theta_j(\mu_1,…,\mu_k)$，则可给出诸$\theta_j$的矩估计：</p></li></ol><p>$$<br>   \hat{\theta_j}&#x3D;\theta_j(a_1,…,a_k),\quad j&#x3D;1,…,k<br>$$<br>   其中$a_1,…,a_k$是前$k$阶样本原点矩$a_j&#x3D;\frac{1}{n}\sum_{i&#x3D;1}^{n}x_i^j$.</p><p>   矩估计基于大数定律（格里纹科定理），实质是用经验分布函数去替换总体分布，矩估计可以概括为：</p><ul><li><p>用样本矩代替总体矩（可以是原点矩也可以是中心矩）；</p><ul><li>用样本矩的函数去替换相应的总体矩的函数。</li></ul><blockquote><p><strong>注：</strong>矩估计可能是不唯一的，尽量使用低阶矩给出未知参数的估计 。</p></blockquote></li></ul><ol start="2"><li><p><strong>最大似然估计</strong></p><p><strong>定义：</strong>设总体的概率函数为$p(x;\theta),\ \theta\in\Theta$，其中$\theta$是一个未知参数或几个未知参数组成的参数向量，$\Theta$是参数空间，$x_1,…,x_n$是来自该总体的样本，将样本的联合概率函数看成$\theta$的函数，用$L(\theta;x_1,…,x_n)$表示，简记为$L(\theta)$，<br>$$<br>L(\theta)&#x3D;L(\theta;x_1,…,x_n)&#x3D;p(x_1;\theta)p(x_2;\theta)…p(x_n;\theta)<br>$$<br>$L(\theta)$称为样本的<strong>似然函数</strong>。若统计量$\hat{\theta}&#x3D;\hat{\theta}(x_1,…,x_n)$满足<br>$$<br>L(\hat{\theta})&#x3D;\max_{\theta\in\Theta}L(\theta)<br>$$<br>则称$\hat{\theta}$是$\theta$的<strong>最大似然估计</strong>，简称<strong>MLE（maximum likelihood estimate）.</strong></p><p><strong>注：</strong>最大似然估计基于样本观测数据，根据概率论思想进行参数估计，首先抽取一定样本，默认这些样本的出现概率是符合原始分布的，即恰好抽到这些样本是因为这些样本出现的概率极大，然后根据概率密度计算联合概率，形成似然函数，似然函数极值位置即为参数的估计值。**<u>最大似然估计的前提是已知数据的分布。</u>**</p><p><strong>最大似然估计步骤：</strong></p><ul><li>写出似然函数；</li><li>对似然函数取对数，并整理；</li><li>求参数向量的偏导，令其为0，得到似然方程；</li><li>求解似然方程，其解为参数值。</li></ul></li><li><p><strong>最小均方误差估计</strong></p><p>在样本量一定时，评价一个点估计好坏的度量指标可使用估计值$\hat{\theta}$与参数真值$\theta$的距离函数，最常用的是距离平方，由于$\hat{\theta}$具有随机性，对该函数求期望即得<strong>均方误差</strong>：<br>$$<br>\begin{align}<br>MSE(\hat{\theta})&amp;&#x3D;E(\hat{\theta}-\theta)^2\<br>&amp;&#x3D;E[(\hat{\theta}-E\hat{\theta})+(E\hat{\theta}-\theta)]^2\<br>&amp;&#x3D;E(\hat{\theta}-E\hat{\theta})^2+(E\hat{\theta}-\theta)^2+\underbrace{2E[(\hat{\theta}-E\hat{\theta})(E\hat{\theta}-\theta)]}<em>{E(\hat{\theta}-E\hat{\theta})&#x3D;0}\<br>&amp;&#x3D;\underbrace{Var(\hat{\theta})}</em>{点估计的方差}+\underbrace{(E\hat{\theta}-\theta)^2}_{偏差的平方}<br>\end{align}<br>$$<br>其中，<strong>如果$\hat{\theta}$是$\theta$的无偏估计，则$MSE(\hat{\theta})&#x3D;Var(\hat{\theta})$，此时用均方误差评价点估计与用方差是完全一样的</strong>。如果如果$\hat{\theta}$不是$\theta$的无偏估计，就要看其均方误差$MSE(\hat{\theta})$，即不仅要看其方差大小，还要看其偏差大小。</p><p><strong>定义：</strong>设有样本$x_1,…,x_n$，对待估参数$\theta$，设有一个估计类，如果对该估计类中另外任意一个$\theta$的估计$\widetilde{\theta}$，在参数空间$\Theta$上都有$MSE_\theta(\hat{\theta})\leq MSE_\theta(\widetilde{\theta})$，称$\hat{\theta}(x_1,…,x_n)$是该估计类中$\theta$的一致最小均方误差估计。</p></li><li><p><strong>最小方差无偏估计</strong></p><p><strong>定义：</strong>设$\hat{\theta}$是$\theta$的一个无偏估计，如果对另外任意一个$\theta$的无偏估计$\widetilde{\theta}$，在参数空间$\Theta&#x3D;{\theta}$上都有$Var_{\theta}(\hat{\theta})\leq Var_{\theta}(\widetilde{\theta})$，则称$\hat{\theta}$是$\theta$的一致最小方差无偏估计，简记为<strong>UMVUE</strong>。</p><p><strong>判断准则：</strong>设$\hat{\theta}&#x3D;\hat{\theta}(x_1,…,x_n)$是$\theta$的一个无偏估计，$Var(\hat{\theta})&lt;+\infty$.如果对任意一个满足$E(\varphi(x_1,…,x_n))&#x3D;0$的$\varphi$，都有<br>$$<br>Cov_\theta(\hat{\theta},\varphi)&#x3D;0,\quad\forall\theta\in\Theta,<br>$$<br>则$\hat{\theta}$是$\theta$的UMVUE.</p></li><li><p><strong>贝叶斯估计</strong></p><p>区别于频率学派，在统计推断中贝叶斯用到了三种信息：<strong>总体信息、样本信息和先验信息</strong>（频率学派只用了前两种），其中：</p><ul><li>总体信息：总体信息即总体分布或总体所属分布族提供的信息，如，若已知总体是正态分布，则可以知道很多信息；</li><li>样本信息：样本信息即抽取样本所得观测值提供的信息，如，在有了样本观测值后，可以根据它知道总体的一些特征数；</li><li>先验信息：若把抽取样本看作做一次试验，则样本信息就是试验中得到的信息，如，在一次抽样后，这第一次的抽样就是先验信息。先验信息来源于经验和历史资料。</li></ul><p><strong>回顾贝叶斯公式</strong>：设${B_1, B_2, …B_n}$是样本空间的一个分割，$A$为$\Omega$中的一个事件，$P(B_i)&gt;0$，$i&#x3D;1,2,…,n$，$P(A)&gt;0$，则<br>$$<br>P(B_i|A)&#x3D;\frac{P(A|B_i)P(B_i)}{\sum_{j&#x3D;1}^{n}P(A|B_j)P(B_j)}<br>$$<br><strong>贝叶斯密度函数形式：</strong></p><ul><li><p>在参数$\theta$分布已知（已假设）的情况下，$p(x|\theta)$表示随机变量$\theta$取某个给定值时总体的<strong>条件概率函数</strong>，（参考$P(A|B)$）；</p></li><li><p>任一未知量$\theta$都可以看作随机变量，可用一个概率分布去描述，这个分布成为<strong>先验分布</strong>，该先验分布$\pi(\theta)$，（参考$P(B)$）；</p></li><li><p>贝叶斯的观点，样本$X&#x3D;(x_1,…,x_n)$的产生需分两步：</p></li><li><p>从先验分布$\pi(\theta)$产生一个样本$\theta_0$；</p></li><li><p>从$p(X|\theta_0)$中产生一组样本。</p></li></ul><p>  此时，样本$X&#x3D;(x_1,…,x_n)$的<strong>联合条件概率函数</strong>（参考$\sum_{j&#x3D;1}^{n}P(A|B_j)$）为<br>  $$<br>  p(X|\theta_0)&#x3D;p(x_1,…,x_n|\theta_0)&#x3D;\prod^{n}_{i&#x3D;1}p(x_i|\theta_0)<br>  $$</p><ul><li><p>因为$\theta_0$未知，是从先验分布$\pi(\theta)$中产生的，所以需要考虑它的发生概率，样本$X$和参数$\theta$的<strong>联合分布</strong>（参考$\sum_{j&#x3D;1}^{n}P(A|B_j)P(B_j)$）为<br>$$<br>h(X,\theta)&#x3D;p(X|\theta)\pi(\theta)<br>$$</p></li><li><p>因为目的是对$\theta$进行推断，所以在有样本观测值$X&#x3D;(x_1,…,x_n)$之后，可依据$h(X,\theta)$对$\theta$作出推断，按照乘法公式（参考1.5.2节），$h(X,\theta)$可分解为<br>$$<br>h(X,\theta)&#x3D;\pi(\theta|X)m(X)<br>$$<br>其中，$m(X)$是$X$的边际概率函数，类比$\pi(\theta)$，<br>$$<br>m(X)&#x3D;\int_\Theta h(X,\theta)d\theta&#x3D;\int_\Theta p(X|\theta)\pi(\theta)d\theta<br>$$<br>所以可通过条件概率$\pi(\theta|X)$推断$\theta$的分布<br>$$<br>\pi(\theta|X)&#x3D;\frac{h(X,\theta)}{m(X)}&#x3D;\frac{p(X|\theta)\pi(\theta)}{\int_{\Theta}p(X|\theta)\pi(\theta)d\theta}<br>$$<br>该分布成为$\theta$的<strong>后验分布</strong>。<strong>它其实是利用总体和样本对先验分布$\pi(\theta)$调整的结果，比$\pi(\theta)$更接近$\theta$的实际情况（机器学习里的贝叶斯模型就是基于这样的原理）</strong>。</p><blockquote><p><strong>Flag：</strong>感觉贝叶斯定理很有意思，今后也会学习相关的贝叶斯分析数据，敬请期待～</p></blockquote></li></ul></li></ol><h3 id="5-1-3-点估计的优良性准则"><a href="#5-1-3-点估计的优良性准则" class="headerlink" title="5.1.3 点估计的优良性准则"></a>5.1.3 点估计的优良性准则</h3><ol><li><p><strong>无偏性：</strong>设$\hat{\theta}&#x3D;\hat{\theta}(x_1,…,x_n)$是$\theta$的一个估计，$\theta$的参数空间为$\Theta$，若对任意的$\theta \in \Theta$，有<br>$$<br>E_{\theta}(\hat{\theta})&#x3D;\theta<br>$$<br>则称$\hat{\theta}$是$\theta$的<strong>无偏估计</strong>，否则称为<strong>有偏估计</strong>。无偏性的要求也可以改写为$E_{\theta}(\hat{\theta-\theta})&#x3D;0$，无偏性表示表示估计参数与真实参数没有系统偏差。</p><blockquote><p><strong>一个重要的结论：</strong>样本均值$\bar{x}&#x3D;\frac{1}{n}\sum_{i&#x3D;1}^nx_i$是总体均值$\mu$的无偏估计。样本方差$s_n^2&#x3D;\frac{1}{n}\sum_{i&#x3D;1}^n(x_i-\bar{x})^2$不是总体方差$\sigma^2$的无偏估计（而是渐进无偏估计），因此需要对样本方差进行修正，$s^2&#x3D;\frac{1}{n-1}\sum_{i&#x3D;1}^n(x_i-\bar{x})^2$.</p><ul><li>样本均值的无偏性推导</li></ul><p>$$<br>\begin{align}<br>E(\bar{x})&#x3D;&amp;E(\frac{1}{n}\sum_{i&#x3D;1}^nx_i)\<br>&#x3D;&amp;\frac{1}{n}\sum_{i&#x3D;1}^nE(x_i),\ x_i为iid\<br>&#x3D;&amp;\frac{1}{n}\sum_{i&#x3D;1}^n\mu\<br>&#x3D;&amp;\mu<br>\end{align}<br>$$</p><ul><li>样本方差的有偏性推导<br>$$<br>\begin{align}<br>E(s_n^2)&#x3D;&amp;E[\frac{1}{n}\sum_{i&#x3D;1}^n(x_i-\bar{x})^2]\<br>&#x3D;&amp;E[\frac{1}{n}\sum_{i&#x3D;1}^n((x_i-\mu)-\frac{1}{n}(\bar{x}-\mu))^2]\<br>&#x3D;&amp;E[\frac{1}{n}\sum_{i&#x3D;1}^n((x_i-\mu)^2-\frac{2}{n}(x_i-\mu)(\bar{x}-\mu)+\frac{1}{n}(\bar{x}-\mu)^2)]\<br>&#x3D;&amp;E[\frac{1}{n}\sum_{i&#x3D;1}^n(x_i-\mu)^2-\frac{2}{n}\sum_{i&#x3D;1}^n(x_i-\mu)(\bar{x}-\mu)+(\bar{x}-\mu)^2],\ 其中,\bar{X}-\mu&#x3D;\frac{1}{n}\sum_{i&#x3D;1}^n(x_i-\mu)\<br>&#x3D;&amp;E[\frac{1}{n}\sum_{i&#x3D;1}^n(x_i-\mu)^2-2(\bar{x}-\mu)^2+(\bar{x}-\mu)^2]\<br>&#x3D;&amp;E[\frac{1}{n}\sum_{i&#x3D;1}^n(x_i-\mu)^2-(\bar{x}-\mu)^2]\<br>&#x3D;&amp;E[\frac{1}{n}\sum_{i&#x3D;1}^n(x_i-\mu)^2]-E[(\bar{x}-\mu)^2]\<br>&#x3D;&amp;\sigma^2-E[(\bar{x}-\mu)^2]\ …(1)\<br>&#x3D;&amp;\sigma^2-\frac{\sigma^2}{n}\<br>&#x3D;&amp;\frac{n-1}{n}\sigma^2,\quad 当n\rightarrow \infty时, E(s_n^2)\rightarrow \sigma^2\<br>\<br>E[(\bar{x}-\mu)^2]&#x3D;&amp;E(\bar{x}^2)-2\mu E(\bar{x})+\mu^2\<br>&#x3D;&amp;E(\bar{x}^2)-\mu^2\<br>&#x3D;&amp;Var(\bar{x})+E^2(\bar{x})-\mu^2\<br>&#x3D;&amp;Var(x)\<br>&#x3D;&amp;\frac{\sigma^2}{n}\ …代入(1)式<br>\end{align}<br>$$</li></ul></blockquote></li><li><p><strong>有效性</strong></p><p>无偏估计往往有很多种，以总体均值为例，$x_1,…,x_n$是取自某总体的样本，样本均值$\mu$和样本$x_i$都是总体均值的无偏估计，对于两个估计参数的选取需要基于一个度量无偏估计优劣的准则。有效性作为这样的准则，反映了<strong>参数估计值和参数真值的波动</strong>，波动大小可用方差来衡量，波动越小表示参数的估计越有效。</p><p>设$\hat{\theta_1}$，$\hat{\theta_2}$是$\theta$的两个无偏估计，如果对任意的$\theta\in\Theta$有<br>$$<br>Var(\hat{\theta}_1)\leq Var(\hat{\theta}_2)<br>$$<br>且至少有一个$\theta\in\Theta$使得上述不等号严格成立，则称$\hat{\theta}_1$比$\hat{\theta}_2$有效。</p></li><li><p><strong>相合性</strong></p><p>根据格里纹科定理，随着样本量不断增大，经验分布函数逼近真实分布函数，即设$\theta\in\Theta$为未知参数，$\hat{\theta}_n&#x3D;\hat{\theta}<em>n(x_1,…,x_n)$是$\theta$的一个估计量，$n$是样本容量，若对任何一个$\epsilon&gt;0$，有<br>$$<br>\lim</em>{n\rightarrow\infty}P(|\hat{\theta}_n-\theta|\geq\epsilon)&#x3D;0<br>$$<br>则称$\hat{\theta}_n$为参数$\theta$的相合估计。</p><p><strong>定理1：</strong>设$\hat{\theta}_n&#x3D;\hat{\theta}<em>n(x_1,…,x_n)$是$\theta$的一个估计量，若<br>$$<br>\lim</em>{n\rightarrow\infty}E(\hat{\theta}<em>n)&#x3D;\theta,\quad\lim</em>{n\rightarrow\infty}Var(\hat{\theta}_n)&#x3D;0<br>$$<br>则$\hat{\theta}_n$是$\theta$的相合估计。</p><p><strong>定理2：</strong>若$\hat{\theta}<em>{n1},…,\hat{\theta}</em>{nk}$分别是$\theta_1,…,\theta_k$的相合估计，$\eta&#x3D;g(\theta_1,…,\theta_k)$是$\theta_1,…,\theta_k$的连续函数，则$\hat{\eta}<em>n&#x3D;g(\hat{\theta}</em>{n1},…,\hat{\theta}_{nk})$是$\eta$的相合估计。</p><blockquote><p>矩估计一般都具有相合性：</p><ul><li>样本均值是总体均值的相合估计；</li><li>样本标准差是总体标准差的相合估计；</li><li>样本变异系数$s&#x2F;\bar{x}$是总体变异系数的相合估计。</li></ul></blockquote></li><li><p><strong>渐进正态性</strong>（MLE）</p><p>在很一般条件下，总体分布$p(x;\theta)$中的$\theta$的MLE$\hat{\theta}_n$具有相合性和渐进正态性，即$\hat{\theta}<em>n\sim AN(\theta,\frac{1}{nI(\theta)})$，其中$n$为样本容量，$I(\theta)&#x3D;\int</em>{-\infty}^{\infty}(\frac{\part{lnp}}{\part\theta})^2p(x;\theta)dx$为费希尔信息量。</p></li><li><p><strong>充分性</strong>（UMVUE）</p><ul><li>任一参数$\theta$的UMVUE不一定存在，若存在，则它一定是充分统计量的函数；</li><li>若$\theta$的某个无偏估计$\hat{\theta}$不是充分统计量$T&#x3D;T(x_1,…,x_n)$的函数，则通过条件期望可以获得一个新的无偏估计$\widetilde{\theta}&#x3D;E(\hat{\theta|T})$，且方差比原估计的方差要小；</li><li>考虑$\theta$的估计时，只需要在其充分统计量的函数中寻找即可，该说法对所有统计推断都是正确的，这便是充分性原则。</li></ul></li></ol><h2 id="5-2-区间估计"><a href="#5-2-区间估计" class="headerlink" title="5.2 区间估计"></a>5.2 区间估计</h2><h3 id="5-2-1-区间估计的概念"><a href="#5-2-1-区间估计的概念" class="headerlink" title="5.2.1 区间估计的概念"></a>5.2.1 区间估计的概念</h3><ol><li><p><strong>双侧区间</strong></p><p>设$\theta$是总体的一个参数，其参数空间为$\Theta$，$x_1,…,x_n$是来自该总体的样本，对给定的一个$\alpha\quad(0&lt;\alpha&lt;1)$，假设有两个统计量$\hat{\theta}_L&#x3D;\hat{\theta}_L(x_1,…,x_n)$和$\hat{\theta}_U&#x3D;\hat{\theta}_U(x_1,…,x_n)$，若对任意的$\theta\in\Theta$，有<br>$$<br>P_\theta(\hat{\theta}_L\leq\theta\leq\hat{\theta}_U)\geq(&#x3D;)1-\alpha<br>$$<br>其中，总体为连续分布时取等号，表示用足了置信水平。称随机区间$[\hat{\theta}_L,\hat{\theta}_U]$为$\theta$的<strong>置信水平为$1-\alpha$的置信区间</strong>，或简称$[\hat{\theta}_L,\hat{\theta}_U]$是$\theta$的**$1-\alpha$置信区间<strong>，$\hat{\theta}_L$和$\hat{\theta}_U$分别称为$\theta$的</strong>置信下限<strong>和</strong>置信上限**。</p><blockquote><p>置信水平$1-\alpha$的频率解释：在大量的区间估计观测值中，至少有$100(1-\alpha)%$包含$\theta$，如下图所示，其置信度为0.95.</p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/confidence_interval.gif" style="zoom:100%;" /></blockquote></li><li><p><strong>单侧区间</strong></p><p>设$\hat{\theta}_L&#x3D;\hat{\theta}_L(x_1,…,x_n)$是统计量，对给定的$\alpha\in(0,1)$和任意的$\theta\in\Theta$，有<br>$$<br>P_\theta(\hat{\theta}_L\leq\theta)\geq1-\alpha,\quad\forall\theta\in\Theta<br>$$<br>则称$\hat{\theta}_L$为$\theta$的置信水平为$1-\alpha$的<strong>置信下限</strong>。同理，设$\hat{\theta}_U&#x3D;\hat{\theta}_U(x_1,…,x_n)$是统计量，对给定的$\alpha\in(0,1)$和任意的$\theta\in\Theta$，有<br>$$<br>P_\theta(\hat{\theta}_L\geq\theta)\geq1-\alpha,\quad\forall\theta\in\Theta<br>$$<br>则称$\hat{\theta}_L$为$\theta$的置信水平为$1-\alpha$的<strong>置信上限</strong>。</p></li></ol><h3 id="5-2-2-区间估计的方法"><a href="#5-2-2-区间估计的方法" class="headerlink" title="5.2.2 区间估计的方法"></a>5.2.2 区间估计的方法</h3><ol><li><p><strong>枢轴量法</strong></p><p><em><strong>Step 1</strong></em>：设法构造一个样本和$\theta$的函数$G&#x3D;G(x_1,…,x_n,\theta)$使得**$G$的分布不依赖于未知参数**，称具有这种性质的$G$为枢轴量。</p><p><em><strong>Step 2</strong></em>：适当地选择两个常数c，d，使对给定的$\alpha\quad(0&lt;\alpha&lt;1)$，有<br>$$<br>P(c\leq G\leq d)&#x3D;1-\alpha<br>$$<br>（在离散场合，将上式等号改为$\geq$）</p><p><em><strong>Step 3</strong></em>：假如能将$c\leq G\leq d$进行不等式等价变形化为$\hat{\theta}_L\leq\theta\leq\hat{\theta}_U$，则有<br>$$<br>P_\theta(\hat{\theta}_L\leq\theta\leq\hat{\theta}_U)&#x3D;1-\alpha<br>$$<br>表明$[\hat{\theta}_L,\hat{\theta}_U]$是$\theta$的$1-\alpha$同等置信区间。</p><blockquote><p><strong>注：</strong>满足条件的c和d有很多，最终选择的目的是希望平均长度$E_\theta(\hat{\theta}_U)-\hat{\theta}_L$尽可能短，但在一些场合中很难做到这一点，因此可以选择c和d，使得两个尾部概率各为$\alpha&#x2F;2$，即<br>$$<br>P_\theta(G&lt;c)&#x3D;P_\theta(G&gt;d)&#x3D;\alpha&#x2F;2<br>$$<br>得到<strong>等尾置信区间</strong>。</p></blockquote><blockquote><p>例：设$x_1,…,x_n$是来自均匀总体$U(0,\theta)$的一个样本，试对设定的$\alpha\ (0&lt;\alpha&lt;1)$给出$\theta$的$1-\alpha$同等置信区间。</p><p>解：三步法：</p><ul><li><p>已知$\theta$的最大似然估计为样本的最大次序统计量$x_{(n)}$，而$x_{(n)}&#x2F;\theta$的密度函数为<br>$$<br> p(y;\theta)&#x3D;ny^{n-1},\quad 0&lt;y&lt;1<br>$$<br> 它与参数$\theta$无关，故可取$x_{(n)}&#x2F;\theta$作为枢轴量$G$。</p></li><li><p>由于$x_{(n)}&#x2F;\theta$的分布函数为$F(y)&#x3D;y^n$，$0&lt;y&lt;1$，故$P(c\leq x_{(n)}&#x2F;\theta\leq d&#x3D;d^n-c^n)$，因此可以选择适当的c和d满足<br>$$<br> d^n-c^n&#x3D;1-\alpha<br>$$</p></li><li><p>在$0\leq c&lt;d\leq 1$及$d^n-c^n&#x3D;1-\alpha$的条件下，当$d&#x3D;1, c&#x3D;\sqrt[n]{\alpha}$时，$E_\theta(\hat{\theta}<em>U)-\hat{\theta}<em>L$取最小值，所以$[x</em>{(n)},x</em>{(n)}&#x2F;\sqrt[n]{\alpha}]$是$1-\alpha$置信区间</p></li></ul></blockquote></li></ol><h3 id="5-2-3-一些情况下的区间估计"><a href="#5-2-3-一些情况下的区间估计" class="headerlink" title="5.2.3 一些情况下的区间估计"></a>5.2.3 一些情况下的区间估计</h3><ol><li><p><strong>单个正态总体参数的置信区间</strong></p><ul><li><strong>$\sigma$已知时$\mu$的置信区间</strong>：$[\bar{x}-u_{1-\alpha&#x2F;2}\sigma&#x2F;\sqrt{n},\quad\bar{x}+u_{1-\alpha&#x2F;2}\sigma&#x2F;\sqrt{n}]$</li><li><strong>$\sigma$未知时$\mu$的置信区间</strong>：$[\bar{x}-t_{1-\alpha&#x2F;2}(n-1)s&#x2F;\sqrt{n},\quad\bar{x}+t_{1-\alpha&#x2F;2}(n-1)s&#x2F;\sqrt{n}]$</li><li><strong>$\sigma^2$的置信区间（$\mu$未知）</strong>：$[(n-1)s^2&#x2F;\chi^2_{1-\alpha&#x2F;2}(n-1),\quad(n-1)s^2&#x2F;\chi^2_{\alpha&#x2F;2}(n-1)]$</li></ul></li><li><p><strong>大样本置信区间</strong>：$[\bar{x}-u_{1-\alpha&#x2F;2}\sqrt{\frac{\bar{x}(1-\bar{x})}{n}},\quad \bar{x}+u_{1-\alpha&#x2F;2}\sqrt{\frac{\bar{x}(1-\bar{x})}{n}}]$</p></li><li><p><strong>两个正态总体下的置信区间</strong></p><ul><li><p><strong>$\mu_1-\mu_2$的置信区间</strong></p><ul><li><strong>$\sigma^2_1$和$\sigma^2_2$已知时</strong>：$[\bar{x}-\bar{y}-u_{1-\alpha&#x2F;2}\sqrt{\frac{\sigma^2_1}{m}+\frac{\sigma^2_2}{n}},\quad \bar{x}-\bar{y}+u_{1-\alpha&#x2F;2}\sqrt{\frac{\sigma^2_1}{m}+\frac{\sigma^2_2}{n}}]$</li><li><strong>$\sigma^2_1&#x3D;\sigma^2_2&#x3D;\sigma^2$未知时</strong>：$[\bar{x}-\bar{y}-\sqrt{\frac{m+n}{mn}}s_wt_{1-\alpha&#x2F;2}(m+n-2),\quad \bar{x}-\bar{y}+\sqrt{\frac{m+n}{mn}}s_wt_{1-\alpha&#x2F;2}(m+n-2)]$</li><li><strong>$\sigma^2_2&#x2F;\sigma^2_1&#x3D;c$已知时</strong>：$[\bar{x}-\bar{y}-\sqrt{\frac{mc+n}{mn}}s_wt_{1-\alpha&#x2F;2}(m+n-2),\quad \bar{x}-\bar{y}+\sqrt{\frac{mc+n}{mn}}s_wt_{1-\alpha&#x2F;2}(m+n-2)]$</li><li><strong>当m和n都很大时的近似置信区间</strong>：$[\bar{x}-\bar{y}-u_{1-\alpha&#x2F;2}\sqrt{\frac{s^2_x}{m}+\frac{s^2_y}{n}},\quad \bar{x}-\bar{y}+u_{1-\alpha&#x2F;2}\sqrt{\frac{s^2_x}{m}+\frac{s^2_y}{n}}]$</li><li><strong>一般情况下的近似置信区间</strong>：$[\bar{x}-\bar{y}-s_0t_{1-\alpha&#x2F;2}(l),\quad \bar{x}-\bar{y}+s_0t_{1-\alpha&#x2F;2}(l)]$</li></ul></li><li><p><strong>$\sigma^2_1&#x2F;\sigma^2_2$的置信区间</strong>：$[\frac{s_x^2}{s_y^2}\cdot\frac{1}{F_{1-\alpha&#x2F;2(m-1,n-1)}},\quad \frac{s_x^2}{s_y^2}\cdot\frac{1}{F_{\alpha&#x2F;2(m-1,n-1)}}]$</p></li></ul></li></ol><h1 id="六-假设检验"><a href="#六-假设检验" class="headerlink" title="六 假设检验"></a>六 假设检验</h1><h2 id="6-1-假设检验的基本思想和概念"><a href="#6-1-假设检验的基本思想和概念" class="headerlink" title="6.1 假设检验的基本思想和概念"></a>6.1 假设检验的基本思想和概念</h2><ol><li><p><strong>基本思想</strong></p><p>以“女士品茶”为例，对于该女士有没有品茶的能力，有两种假设：该女士没有品茶能力和该女士有品茶能力。在统计上这两个非空不相交参数集合称作<strong>统计假设</strong>，简称<strong>假设</strong>。通过样本对一个假设作出对与不对的判断，则称为该假设的一个<strong>检验</strong>。若检验结果否定该命题，则称<strong>拒绝</strong>这个假设，否则就<strong>接受（不拒绝）</strong>这个假设。</p><p>假设可分为两种：1. <strong>参数假设检验</strong>，即已经知道数据的分布，针对总体的某个参数进行假设检验；2. <strong>非参数假设检验</strong>，即数据分布未知，针对该分布进行假设检验。</p></li><li><p><strong>假设检验的基本步骤</strong></p><p><em>建立假设</em>—&gt;<em>选择检验统计量，给出拒绝域形式</em>—&gt;<em>选择显著性水平</em>—&gt;<em>给出拒绝域</em>—&gt;<em>做出判断</em></p><p><strong><em>Step 1</em>：建立假设</strong></p><blockquote><p><strong>主要针对参数假设检验问题</strong></p><p>设有来自某分布族${F(x,\theta)|\theta\in\Theta}$的样本$x_1,…,x_n$，其中$\Theta$为参数空间，设$\Theta_0\in\Theta$，且$\Theta_0\neq\phi$，则命题$H_0:\theta\in\Theta_0$称为<strong>原假设</strong>或<strong>零假设（null hypothesis）</strong>，若有另一个$\Theta_1$（$\Theta_1\in\Theta,\Theta_1\Theta_0&#x3D;\phi$，常见的一种情况是$\Theta_1&#x3D;\Theta-\Theta_0$），则命题$H_1:\theta\in\Theta_1$称为$H_0$的<strong>对立假设</strong>或<strong>备择假设（alternative hypotheis）</strong>，当$H_0$为简单假设，即$\Theta_0$只含一个点时，备择假设有三种可能：$H_1’:\theta\neq\theta_0$，$H_1’’:\theta&lt;\theta_0$，$H_1’’’:\theta&gt;\theta_0$。</p></blockquote><p><strong><em>Step 2</em>：选择检验统计量，给出拒绝域形式</strong></p><blockquote><p>根据样本计算统计量$Z$（如样本均值、标准差等，称为<strong>检验统计量</strong>），并基于某个法则既可以决定接受$H_0$还是拒绝$H_0$，具体地，当统计量在拒绝域$W$中即拒绝$H_0$，在接受域$\overline{W}$中即接受$H_0$。由此可见，<strong>一个拒绝域$W$唯一确定一个检验法则，反之，一个检验法则也唯一确定一个拒绝域。</strong></p><p><strong>注：</strong>不能用一个样本（例子）证明一个命题（假设成立），但是可以用一个样本（例子）去推翻一个命题。此外，拒绝域与接受域之间有一个模糊域，即统计量恰好符合法则，通常将模糊域归为接受域，因此接受域是复杂的。</p></blockquote><p><strong><em>Step 3</em>：选择显著性水平</strong></p><blockquote><p>假设检验基于<strong>小概率事件</strong>，即小概率事件在一次试验中几乎不会发生，因此选择一个很小的概率值$\alpha$，令$p(拒绝H_0|H_0为真)\leq\alpha$，表示$Z\in W$是一个小概率事件，在一次试验中不应该发生。如果通过样本得到的统计量$z\in W$，即不该发生的小概率事件竟然发生了，那么应该拒绝$H_0$。</p><p>由于向本是随机的，通常做检验时可能做出错误判断，由此引入了两个错误，分别为<strong>第一类错误</strong>和<strong>第二类错误</strong>，如下表所示。</p><table><thead><tr><th align="center">观测数据情况</th><th align="center">总体情况</th><th align="center">总体情况</th></tr></thead><tbody><tr><td align="center"></td><td align="center">$H_0$为真</td><td align="center">$H_1$为真</td></tr><tr><td align="center">接受$H_0$</td><td align="center">第一类错误（拒真）</td><td align="center">正确</td></tr><tr><td align="center">拒绝$H_0$</td><td align="center">正确</td><td align="center">犯第二类错误（取伪）</td></tr></tbody></table><p>犯第一类错误概率：$\alpha&#x3D;P(X\in W|H_0)$，即$\alpha&#x3D;P(拒绝H_0|H_0为真)$；</p></blockquote></li></ol><blockquote><p>犯第二类错误概率：$\beta&#x3D;P(X\in \overline{W}|H_1)$，即$\beta&#x3D;P(接受H_0|H_0为假)$。</p><p>可以证明的，在一定样本量下，两类错误概率无法共同减小，但是当样本增加时，可以同时减小。</p><blockquote><p> 证明该问题需要引入是函数，下面将简单介绍势函数，但不对上述结论证明。</p><p>定义：设检验问题$H_0:\theta\in\Theta_0\quad vs\quad H_1:\theta \in \Theta_1$的拒绝域为$W$，则样本观测值$\mathbf{X}$落在拒绝域$W$内的概率称为该检验的<strong>势函数</strong>，记为<br>$$<br>g(\theta)&#x3D;P_\theta(\mathbf{X}\in W),\ \theta\in\Theta&#x3D;\Theta_0\cup\Theta_1\<br>g(\theta)&#x3D;\left{\begin{matrix}<br>\alpha(\theta) &amp; \theta\in\Theta_0\<br>1-\beta(\theta) &amp;\theta\in\Theta_1<br>\end{matrix}\right.<br>$$</p></blockquote><p>第一类错误概率$\alpha$即为初始设定的很小的概率，称为<strong>置信水平</strong>，称该检验时<strong>显著性水平为$\alpha$的显著性检验</strong>，简称<strong>水平为$\alpha$的检验</strong>。为了尽量减少两类错误，可简单的将其简化为减小第一类错误概率（第二类错误概率难求）。常用的$\alpha&#x3D;0.05$有时也选择0.1或0.01。</p></blockquote><p>   <strong><em>Step 4</em>：给出拒绝域</strong></p><blockquote><p>为了使得第一类错误的概率尽可能小，给定一个较小的$\alpha$，并选择一个数$k$，设定若$Z\geq k$拒绝$H_0$，使得$P(u&#x3D;|\frac{z-\mu}{\sigma&#x2F;\sqrt{n}}|\geq k)\leq \alpha$，所以$k&#x3D;u_{\alpha&#x2F;2}$。</p><p>注：算拒绝域时，需基于标准正态分布。</p></blockquote><p>   <strong><em>Step 5</em>：做出判断</strong></p><blockquote><p>通过样本计算统计量，若统计量在拒绝域中，则拒绝原假设，否则接受原假设。</p></blockquote><ol start="3"><li><p><strong>检验的$p$值</strong></p><p>不同置信水平$\alpha$的取值，可能会存在不同的结果。因此引入新的指标，即利用样本观测值能够作出拒绝原假设的最小显著水平，称为<strong>检验的$p$值</strong>。由检验的$p$值与心目中的显著性水平$\alpha$进行比较，可以容易做出检验结论：</p><ul><li>若$\alpha\geq p$，则在显著性水平$\alpha$下拒绝$H_0$；</li><li>若$\alpha&lt;p$，则在显著性水平$\alpha$下接受$H_0$.</li></ul><blockquote><p> <strong>注：</strong>一般以$p&lt;0.05$ 为有统计学差异， $p&lt;0.01$ 为有显著统计学差异，$p&lt;0.001$为有极其显著的统计学差异。</p></blockquote></li></ol><blockquote><p>Author：钱小z </p><p>Email：<a href="mailto:&#113;&#x7a;&#95;&#103;&#105;&#x73;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;">&#113;&#x7a;&#95;&#103;&#105;&#x73;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;</a></p><p>Bio：GISer，Spatiotemporal data mining</p><p>GitHub：QianXzhen</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;概率论与数理统计笔记&quot;&gt;&lt;a href=&quot;#概率论与数理统计笔记&quot; class=&quot;headerlink&quot; title=&quot;概率论与数理统计笔记&quot;&gt;&lt;/a&gt;概率论与数理统计笔</summary>
      
    
    
    
    <category term="计算机基础学科" scheme="http://cjx_0723.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AD%A6%E7%A7%91/"/>
    
    
    <category term="数学" scheme="http://cjx_0723.gitee.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E7%94%9F%E6%B4%BB/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%94%9F%E6%B4%BB/PPT/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E7%94%9F%E6%B4%BB/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%94%9F%E6%B4%BB/PPT/</id>
    <published>2023-10-30T14:04:29.061Z</published>
    <updated>2023-10-30T14:04:29.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大气污染控制与环境审计：中国的经验和启示"><a href="#大气污染控制与环境审计：中国的经验和启示" class="headerlink" title="大气污染控制与环境审计：中国的经验和启示"></a>大气污染控制与环境审计：中国的经验和启示</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ul><li>中国的快速工业化和城市化进程对自然生态环境造成了巨大的代价</li><li>空气污染问题对公共健康和经济社会的长期可持续性产生了直接和有害的影响</li><li>环境法规和执法干预是解决空气环境问题的重要手段</li></ul><h2 id="政策和计划"><a href="#政策和计划" class="headerlink" title="政策和计划"></a>政策和计划</h2><ul><li>中国政府采取了重要措施来解决空气污染问题，投入更多资源到相关技术、机构和倡议中</li><li>各种政策和计划强调了环境保护和可持续发展的重要性，表明了在空气污染控制方面越来越高的关注度和细致度</li><li>大气环境审计是中国政府审计机构实施环境治理的重要措施，发挥着至关重要的作用</li></ul><h2 id="研究结果"><a href="#研究结果" class="headerlink" title="研究结果"></a>研究结果</h2><ul><li>空气环境审计对减少空气污染物排放具有显著和稳健的影响</li><li>不同污染物的影响程度有所不同</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li>空气污染控制是中国政府的重要任务，也是全球环境治理的重要议题</li><li>大气环境审计是实现空气污染控制的重要手段，可以为其他国家和地区提供借鉴和启示</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大气污染控制与环境审计：中国的经验和启示&quot;&gt;&lt;a href=&quot;#大气污染控制与环境审计：中国的经验和启示&quot; class=&quot;headerlink&quot; title=&quot;大气污染控制与环境审计：中国的经验和启示&quot;&gt;&lt;/a&gt;大气污染控制与环境审计：中国的经验和启示&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>研一选课</title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E7%94%9F%E6%B4%BB/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%94%9F%E6%B4%BB/%E7%A0%94%E4%B8%80%E9%80%89%E8%AF%BE/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E7%94%9F%E6%B4%BB/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%94%9F%E6%B4%BB/%E7%A0%94%E4%B8%80%E9%80%89%E8%AF%BE/</id>
    <published>2023-10-30T14:04:29.061Z</published>
    <updated>2023-10-30T14:04:29.062Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230907104256933.png" alt="image-20230907104256933" style="zoom: 67%;" /><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230906160250167.png" alt="image-20230906160250167"></p><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230906160313646.png" alt="image-20230906160313646"></p><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230906160409660.png" alt="image-20230906160409660"></p><p>下面的课可以勾选为<font color='red'>专业学位课</font>：核心课、专业课、研讨课</p><p>下面的课可以勾选为<font color='red'>专业选修课</font>：在核心课、专业课、研讨课、实验课、实践课、科学前沿讲座</p><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230906160358582.png" alt="image-20230906160358582"></p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230906160144575.png" alt="image-20230906160144575" style="zoom:150%;" /><h2 id="选课打算"><a href="#选课打算" class="headerlink" title="选课打算"></a>选课打算</h2><table><thead><tr><th>抢课顺序</th><th>课程名称</th><th>编号</th><th>属性</th><th>开课教授</th><th>学分（分）</th></tr></thead><tbody><tr><td>7</td><td><font color='orange'>新时代中国特色社会主义理论与实践</font></td><td></td><td>公共必修课</td><td></td><td>2</td></tr><tr><td></td><td><font color='orange'>自然辩证法概论</font></td><td></td><td>公共必修课</td><td></td><td>1</td></tr><tr><td>5</td><td><font color='orange'>学术道德与学术写作规范</font></td><td></td><td>公共必修课</td><td></td><td>1</td></tr><tr><td>4</td><td><font color='orange'>硕士学位英语</font></td><td></td><td>公共必修课</td><td></td><td>3</td></tr><tr><td></td><td><font color='orange'>高级软件工程（专业）</font></td><td>180086081200P1006H-1</td><td>学科核心课</td><td>魏峻</td><td>3</td></tr><tr><td>2</td><td><font color='orange'>软件测试与分析</font></td><td>180086083500M3001H</td><td>专业课</td><td>严俊</td><td>2</td></tr><tr><td></td><td><font color='cornflowerblue'>操作系统高级教程（专业）</font></td><td>180086083500P1002H</td><td>学科核心课</td><td>杨力祥</td><td>3</td></tr><tr><td>3</td><td><font color='orange'>计算机算法设计与分析（专业）</font></td><td>180086083500P1001H</td><td>学科核心课</td><td>陈玉福</td><td>3</td></tr><tr><td></td><td><font color='orange'>模式识别与机器学习</font></td><td></td><td>专业核心课</td><td><a href="https://jwxkts2.ucas.ac.cn/course/courseteacher/246463"> 卿来云</a></td><td>3</td></tr><tr><td></td><td><font color='orange'>知识工程前沿</font></td><td>180086083500P4001H</td><td>研讨课</td><td></td><td>1</td></tr></tbody></table><table><thead><tr><th>课程名称</th><th>总分数</th></tr></thead><tbody><tr><td>公共必修课</td><td>7</td></tr><tr><td>专业学位课</td><td>12</td></tr><tr><td>公共选修课</td><td>0</td></tr><tr><td>专业选修课</td><td>0</td></tr></tbody></table><p>r</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;img src=&quot;https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230907104256933.png&quot; a</summary>
      
    
    
    
    <category term="生活" scheme="http://cjx_0723.gitee.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="学校" scheme="http://cjx_0723.gitee.io/tags/%E5%AD%A6%E6%A0%A1/"/>
    
  </entry>
  
  <entry>
    <title>给老爸写的炉石传说外服登录攻略</title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E7%94%9F%E6%B4%BB/%E6%B8%B8%E6%88%8F/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E5%A4%96%E6%9C%8D%E7%82%89%E7%9F%B3/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E7%94%9F%E6%B4%BB/%E6%B8%B8%E6%88%8F/%E5%A6%82%E4%BD%95%E4%B8%8B%E8%BD%BD%E5%A4%96%E6%9C%8D%E7%82%89%E7%9F%B3/</id>
    <published>2023-10-30T14:04:29.060Z</published>
    <updated>2023-10-30T14:04:29.060Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="第一步、登录一元机场"><a href="#第一步、登录一元机场" class="headerlink" title="第一步、登录一元机场"></a>第一步、登录一元机场</h1><p>在浏览器URL栏中输入：https:&#x2F;&#x2F;一元机场.com</p><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231029232445831.png" alt="image-20231029232445831"></p><p>进入页面：</p><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231029230316769.png" alt="image-20231029230316769"></p><p>输入邮箱：<a href="mailto:&#49;&#52;&#56;&#52;&#56;&#57;&#x35;&#x33;&#52;&#x35;&#x40;&#x71;&#113;&#46;&#99;&#111;&#109;">&#49;&#52;&#56;&#52;&#56;&#57;&#x35;&#x33;&#52;&#x35;&#x40;&#x71;&#113;&#46;&#99;&#111;&#109;</a></p><p>输入密码：cccccc123</p><p>进入一元机场</p><h1 id="第二步、下载clash"><a href="#第二步、下载clash" class="headerlink" title="第二步、下载clash"></a>第二步、下载clash</h1><p>点击在<a href="https://github.com/Fndroid/clash_for_windows_pkg/releases/download/0.20.35/Clash.for.Windows.Setup.0.20.35.exe">此处</a>下载。</p><p>Clash.for.Windows.Setup.0.XX.XX.exe（XX.XX具体随版本号而定）是安装版，使用前需安装。</p><p><strong>在安装界面，如果出现Windows防火墙或杀软警告，请全部允许！</strong></p><p>在安装完毕后，运行”Clash for Windows.exe”，进入如下界面：</p><p><img src="https://一元机场.com/img/win/img1.png" alt="img"></p><h1 id="第三步、一元机场数据导入clash"><a href="#第三步、一元机场数据导入clash" class="headerlink" title="第三步、一元机场数据导入clash"></a>第三步、一元机场数据导入clash</h1><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231029230817915.png" alt="image-20231029230817915"></p><p>具体步骤可以点击一元机场网站的<strong>windows教程</strong>查看，链接：https:&#x2F;&#x2F;一元机场.com&#x2F;#&#x2F;knowledge</p><p><strong>下面步骤开始之前，打开clash</strong></p><p>第一步、点击左侧”我的订阅”</p><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231030203623760.png" alt="image-20231030203623760"></p><p>第二步、点击右侧”一键订阅”</p><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231030203718708.png" alt="image-20231030203718708"></p><p>第三步、点击”导入到Clash For Windows”</p><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231030203807872.png" alt="image-20231030203807872"></p><p>点击后，浏览器可能会弹出提示框，点击打开calsh for Windows，即可自动导入。</p><h1 id="第四步、挂VPN"><a href="#第四步、挂VPN" class="headerlink" title="第四步、挂VPN"></a>第四步、挂VPN</h1><p>clash导入成功后，点击左侧代理，即可选择：全局、规则、直连、脚本</p><ul><li>如果选择<strong>规则</strong>：点击”自动选择”则会开启VPN</li><li>如果选择<strong>全局</strong>：点击”DIRECT”则会使VPN失效（无法访问外网）</li></ul><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231029231416036.png" alt="image-20231029231416036"></p><p>例如上图是关闭VPN的状态，即没有开启代理，网速会快一点但是无法访问外网。</p><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231029231510555.png" alt="image-20231029231510555"></p><p>例如上图是选择开启代理，可以访问外网，如果需要玩炉石则需要开启，右侧的那个WiFi图标可以测试网速，也可以选择延迟（ms）低的那个连接。</p><p><strong><font color='red'>接下来的步骤需要确保开启代理！</font></strong></p><h1 id="第五步、下载暴雪平台和游戏"><a href="#第五步、下载暴雪平台和游戏" class="headerlink" title="第五步、下载暴雪平台和游戏"></a>第五步、下载暴雪平台和游戏</h1><p><a href="https://ali213.fhyx.hk/item/1243.html?f=youxia">传送门</a>：<a href="http://www.blizzard.com/">https://www.blizzard.com/</a></p><p><img src="https://img2.ali213.net/picfile/News/2023/07/19/584_2023071953130540.png" alt="游侠网1"></p><p>注意：下载完成后选择语言时，一定要选择使用**<font color='red'>繁体中文</font>!!!!**</p><p><img src="https://img2.ali213.net/picfile/News/2023/07/19/584_2023071953130158.png" alt="游侠网5"></p><p>如果无法选择繁体中文参考文章：<a href="https://www.ali213.net/news/html/2023-7/769655.html">https://www.ali213.net/news/html/2023-7/769655.html</a></p><p>随后进入到登录页面，点击那个齿轮选择”美洲”（我注册的号是美洲的，也可以自己注册一个其他区例如亚洲，亚洲是韩国的服务器）</p><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231029231818724.png" alt="image-20231029231818724"></p><p>输入账号：<a href="mailto:&#x31;&#x34;&#56;&#x34;&#56;&#x39;&#53;&#51;&#x34;&#x35;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#109;">&#x31;&#x34;&#56;&#x34;&#56;&#x39;&#53;&#51;&#x34;&#x35;&#64;&#113;&#x71;&#46;&#99;&#x6f;&#109;</a></p><p>输入密码：Acjxcjxcjx105188a</p><p>随后进入页面，点击炉石传说，点击下载：</p><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231029231921220.png" alt="image-20231029231921220"></p><p>下载完毕后点击开始游戏，左边那个小地球也可以选择区</p><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231029231958315.png" alt="image-20231029231957451"></p><p>打开成功：<img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231029232327243.png" alt="image-20231029232326201"></p><h1 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h1><p>clash 这个软件建议在每次开机后打开，不然开机后访问浏览器会出现代理错误的提示，可以将这个软件设置为开机自启，方法网上搜索。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;第一步、登录一元机场&quot;&gt;&lt;a href=&quot;#第一步、登录一元机场&quot; class=&quot;headerlink&quot; title=&quot;第一步、登录一元机场&quot;&gt;&lt;/a&gt;第一步、登录一元机</summary>
      
    
    
    
    <category term="生活" scheme="http://cjx_0723.gitee.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="游戏" scheme="http://cjx_0723.gitee.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E6%A8%A1%E6%9D%BF/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E6%A8%A1%E6%9D%BF/</id>
    <published>2023-10-30T14:04:29.055Z</published>
    <updated>2023-10-30T14:04:29.055Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">title: Matploblib</span><br><span class="line">date: 2023年9月13日23:10:52</span><br><span class="line">tags: </span><br><span class="line">    - Python</span><br><span class="line">    - Python工具包</span><br><span class="line">categories: 后端</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img: https://w.wallhaven.cc/full/d5/wallhaven-d582rg.png</span><br><span class="line">comments:</span><br><span class="line">cover: https://w.wallhaven.cc/full/d5/wallhaven-d582rg.png</span><br><span class="line">toc:</span><br><span class="line">toc_number:</span><br><span class="line">toc_style_simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright_author:</span><br><span class="line">copyright_author_href: </span><br><span class="line">copyright_url: </span><br><span class="line">copyright_info: </span><br><span class="line">mathjax: </span><br><span class="line">katex:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">aside:</span><br></pre></td></tr></table></figure><meta name="referrer" content="no-referrer"/>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E6%96%87%E7%8C%AE/%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%80%A7%E5%9C%B0%E9%98%85%E8%AF%BB%E6%96%87%E7%8C%AE/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E6%96%87%E7%8C%AE/%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%80%A7%E5%9C%B0%E9%98%85%E8%AF%BB%E6%96%87%E7%8C%AE/</id>
    <published>2023-10-30T14:04:29.054Z</published>
    <updated>2023-10-30T14:04:29.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何选择性地阅读文献"><a href="#如何选择性地阅读文献" class="headerlink" title="如何选择性地阅读文献"></a>如何选择性地阅读文献</h1><p>论文阅读需要有选择性，这取决于这篇文章对于你的意义：</p><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231009144550613.png" alt="image-20231009144550613"></p><h1 id="如何做好文献笔记"><a href="#如何做好文献笔记" class="headerlink" title="如何做好文献笔记"></a>如何做好文献笔记</h1><h2 id="为什么需要做笔记"><a href="#为什么需要做笔记" class="headerlink" title="为什么需要做笔记"></a>为什么需要做笔记</h2><ol><li>过往文献长时间不阅读会遗忘</li><li>学习如何阅读文章以及搭建框架</li><li>方便写作时对比讨论，引用文献</li></ol><p>文献笔记不是简单的勾画与抄写，不要把文章的内容直接复制粘贴，需要融入自己的思考；文献笔记不是给别人看的，只要自己能懂就好；文献笔记不是文献综述，需要有重要性地记录</p><h2 id="如何做好笔记整理"><a href="#如何做好笔记整理" class="headerlink" title="如何做好笔记整理"></a>如何做好笔记整理</h2><p> <img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231009145133956.png" alt="image-20231009145133956"></p><ol><li>文章的信息：这块部分是对文章元数据的展示</li><li>主要框架：背景、目的、可行性、结论（这部分摘抄）</li><li>主要结果与讨论：对文章主要论述的部分加以概述并且适当融入自己的见解</li><li>个人思考：文章的优缺点、自己的想法（按照‘125’原则，1个思路，2个表格，5个句式：思考这篇文章能为自己未来带来怎么样的思路，不管是试验方法还是研究思路；学习这篇文章画的比较好的图标；总结写的好的5个句式，尝试模仿运用）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何选择性地阅读文献&quot;&gt;&lt;a href=&quot;#如何选择性地阅读文献&quot; class=&quot;headerlink&quot; title=&quot;如何选择性地阅读文献&quot;&gt;&lt;/a&gt;如何选择性地阅读文献&lt;/h1&gt;&lt;p&gt;论文阅读需要有选择性，这取决于这篇文章对于你的意义：&lt;/p&gt;
&lt;p&gt;&lt;img</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E6%96%87%E7%8C%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/MapReduce%E6%A8%A1%E5%9E%8B-CK4X2BJ8/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E6%96%87%E7%8C%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/MapReduce%E6%A8%A1%E5%9E%8B-CK4X2BJ8/</id>
    <published>2023-10-30T14:04:29.048Z</published>
    <updated>2023-10-30T14:04:29.049Z</updated>
    
    <content type="html"><![CDATA[<p>MapReduce模型</p><h1 id="1-MapReduce模型介绍"><a href="#1-MapReduce模型介绍" class="headerlink" title="1 MapReduce模型介绍"></a>1 MapReduce模型介绍</h1><p><strong>MapReduce</strong> 是一种编程模型和相关实现，用于处理和生成适合各种现实世界任务的大型数据集。<span style="color: rgb(62, 63, 66)"><span style="background-color: rgb(251, 251, 251)">用户可以通过定义map和reduce函数来指定计算过程，而底层的运行时系统会自动将计算并行化到大规模的机器集群上，处理机器故障，并进行网络和磁盘的高效通信。</span></span></p><p><span style="color: rgb(62, 63, 66)"><span style="background-color: rgb(251, 251, 251)">这个编程模型简单易用，Google内部已经实现了一万多个不同的MapReduce程序，每天平均执行一百万个MapReduce作业，处理每天超过20PB的数据</span></span></p><h1 id="2-MapReduce工作原理"><a href="#2-MapReduce工作原理" class="headerlink" title="2 MapReduce工作原理"></a>2 MapReduce工作原理</h1><h2 id="2-1-工作流程"><a href="#2-1-工作流程" class="headerlink" title="2.1 工作流程"></a>2.1 工作流程</h2><p><img src="/attachments/F7YYEN8A.png" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;F7YYEN8A&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FUEA45RNH%22%2C%22annotationKey%22%3A%229QDJAQFC%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%223%22%2C%22position%22%3A%7B%22pageIndex%22%3A2%2C%22rects%22%3A%5B%5B74.423%2C383.885%2C538.846%2C726%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%5D%2C%22locator%22%3A%223%22%7D%7D&quot; width=&quot;774&quot; height=&quot;570&quot; src=&quot;attachments/F7YYEN8A.png&quot; ztype=&quot;zimage&quot;&gt;"><br><span class="citation" data-citation="%7B%22citationItems%22%3A%5B%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%5D%7D%5D%2C%22properties%22%3A%7B%7D%7D" ztype="zcitation">(<span class="citation-item"><a href="zotero://select/library/items/MUH7F2C2">Dean 和 Ghemawat, 2008</a></span>)</span></p><p><span style="color: rgb(51, 51, 51)">MapReduce 的工作流：</span></p><ul><li><p><span style="color: rgb(51, 51, 51)">将输入文件分成 </span><strong><span style="color: rgb(51, 51, 51)">M</span></strong><span style="color: rgb(51, 51, 51)"> 个小文件(split)，每个文件的大小大概 16M-64M（由用户参数控制），在集群中启动 MapReduce 实例，其中</span><code>fork</code></p><p>一个 Master 和多个 Worker；[1]</p></li><li><p><span style="color: rgb(51, 51, 51)">由 Master 分配任务，将 </span></p><p><code>Map</code>与<code>Reduce</code>任务分配给可用的 Worker[2]；</p></li><li><p><code>Map</code>Worker 读取文件[3]，执行用户自定义的 map 函数，输出 中间值key&#x2F;value 对，缓存在内存中；</p></li><li><p><span style="color: rgb(51, 51, 51)">内存中的 (key, value) 对通过 </span></p><p><code>partitioning function()</code>例如<code>hash(key) mod R</code>分为<strong>R</strong>个 regions（保证相同key的键值对在一个分区），然后写入磁盘(local disk)[4]。完成之后，把这些文件的地址回传给 Master，然后 Master 把这些位置传给<code>Reduce</code>Worker；</p></li><li><p><code>Reduce</code>Worker 收到数据存储位置信息后，使用 RPC(Remote Procedure Call远程过程调用协议) 从<code>Map</code>Worker 所在的磁盘读取这些数据[5]，根据 key 进行排序，并将同一 key 的所有数据分组聚合在一起（<strong>由于许多不同的 key 值会映射到相同的 Reduce 任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序</strong>）；</p></li><li><p><code>Reduce</code>Worker 将分组后的值传给用户自定义的 reduce 函数，输出追加到所属分区的输出文件中；</p></li><li><p><span style="color: rgb(51, 51, 51)">当所有的 Map 任务和 Reduce 任务都完成后，Master 向用户程序返回结果；</span></p></li></ul><p><span style="color: rgb(51, 51, 51)">MapReduce对输出文件的处理：</span></p><p><span style="color: rgb(51, 51, 51)">通常情况下，用户并不需要将 R 个输出文件合并成一个文件；他们通常会将这些文件作为输入传递给另一个 MapReduce 调用，或者从另一个能够处理分割成多个文件的输入的分布式应用程序中使用这些文件。</span></p><hr><h2 id="2-2-Master-数据结构"><a href="#2-2-Master-数据结构" class="headerlink" title="2.2 Master 数据结构"></a>2.2 Master 数据结构</h2><ol><li><span style="color: rgb(51, 51, 51)">记录每一个任务（Map与reduce）状态（idle,in-progress,or completed)</span></li><li><span style="color: rgb(51, 51, 51)">记录每一个工作者身份</span></li><li><span style="color: rgb(51, 51, 51)">记录存储在local disk 中间文件（intermediate file）的大小以及磁盘位置</span></li></ol><hr><h2 id="2-3-容错能力"><a href="#2-3-容错能力" class="headerlink" title="2.3 容错能力"></a><span style="color: rgb(51, 51, 51)">2.3 容错能力</span></h2><h3 id="2-3-1、处理worker错误"><a href="#2-3-1、处理worker错误" class="headerlink" title="2.3.1、处理worker错误"></a><span style="color: rgb(51, 51, 51)">2.3.1、处理worker错误</span></h3><ul><li><p><span style="color: rgb(51, 51, 51)">master通过周期地向worker发送ping指令来确保worker处于存活状态，对于没有回应ping指令的worker，master会将该worker标记为 </span></p><p><strong><span style="color: rgb(51, 51, 51)">failed</span></strong></p></li><li><p><span style="color: rgb(51, 51, 51)">在failed worker执行中的 Map 或 Reduce 任务会被重置为idle状态，可被其他存活worker接收。</span></p></li><li><p><span style="color: rgb(51, 51, 51)">在failed worker上已经执行完成的Map任务会被再次执行，因为其输出结果存储在failed worker本地磁盘中，如果failed worker在local write之前就挂掉，那么该数据无法被读取，因此需要从新执行。而Reduce任务不会被再次执行，因为其输出结果存储在全局文件系统中。</span></p></li></ul><p><span style="color: rgb(51, 51, 51)">对于failed worker任务处理总结下来就是：</span></p><table><thead><tr><th><span style="color: rgb(51, 51, 51)"><span style="background-color: var(--th-bg-color)">任务状态状态</span></span></th><th><span style="color: rgb(51, 51, 51)"><span style="background-color: var(--th-bg-color)">Map任务</span></span></th><th><span style="color: rgb(51, 51, 51)"><span style="background-color: var(--th-bg-color)">Reduce任务</span></span></th></tr></thead><tbody><tr><td><span style="color: rgb(51, 51, 51)">执行中</span></td><td><span style="color: rgb(51, 51, 51)">设置为idle</span></td><td><span style="color: rgb(51, 51, 51)">设置为idle</span></td></tr><tr><td><span style="color: rgb(51, 51, 51)"><span style="background-color: var(--tr-bg-color)">执行结束</span></span></td><td><span style="color: rgb(51, 51, 51)"><span style="background-color: var(--tr-bg-color)">从新执行</span></span></td><td><span style="color: rgb(51, 51, 51)"><span style="background-color: var(--tr-bg-color)">不用处理</span></span></td></tr></tbody></table><p><span style="color: rgb(51, 51, 51)">对于worker A 执行的Map任务随后被worker B 执行，那么所有执行Reduce任务的worker都会接到通知：还没有从worker A读取数据的reduce worker 将会从worker B 上读取数据。</span></p><h4 id="4-3-2、出现错误时的语义处理"><a href="#4-3-2、出现错误时的语义处理" class="headerlink" title="4.3.2、出现错误时的语义处理"></a><span style="color: rgb(51, 51, 51)">4.3.2、出现错误时的语义处理</span></h4><p><span style="color: rgb(51, 51, 51)">用户提供的映射（map）和归约（reduce）操作是其输入值的确定性函数时，分布式实现将生成与整个程序的非故障顺序执行所产生的相同输出。</span></p><p><span style="color: rgb(51, 51, 51)">为了实现这个特性，我们依赖于映射和归约任务输出的原子提交。每个正在进行的任务将其输出写入私有临时文件。一个归约任务产生一个这样的文件，而一个映射任务产生 R 个这样的文件（每个归约任务一个）。当一个映射任务完成时，工作节点向主节点发送消息，并在消息中包含这些临时文件的名称。如果主节点接收到一个已经完成的映射任务的完成消息，它将忽略该消息。否则，它将记录 R 个文件的名称在主节点的数据结构中。当一个归约任务完成时，归约工作节点将其临时输出文件原子性地重命名为最终输出文件。如果相同的归约任务在多个机器上执行，那么对于相同的最终输出文件将执行多个重命名调用。我们依赖底层文件系统提供的原子重命名操作来保证最终文件系统状态仅包含一个归约任务执行产生的数据。我们绝大部分的映射和归约操作是确定性的，而且在这种情况下，我们的语义等效于顺序执行，这使得程序员很容易推断出程序的行为。、</span></p><p><span style="color: rgb(51, 51, 51)">当映射和&#x2F;或归约操作是非确定性的时，我们提供了较弱但仍然合理的语义。在存在非确定性操作的情况下，特定归约任务 R 的输出等价于非确定性程序的顺序执行产生的 R 的输出。然而，不同归约任务 F 的输出可能对应于由非确定性程序的不同顺序执行产生的 R 的输出。</span></p><h3 id="4-4-读取位置-locality"><a href="#4-4-读取位置-locality" class="headerlink" title="4.4 读取位置(locality)"></a><span style="color: rgb(51, 51, 51)">4.4 读取位置(locality)</span></h3><p><span style="color: rgb(51, 51, 51)">为了节省带宽资源，MapReduce工作集群中输入数据通常存储在机器的本地磁盘中，在Map任务开始前，Master会考虑输入文件的位置信息，将尝试在包含输入数据的机器上执行Map任务。</span></p><p><span style="color: rgb(51, 51, 51)">如果上述方法行不通，Master也会考虑在存储输入文件机器附近的机器（例如，在与包含数据的机器处于同一交换机上工作的机器）执行Map任务。</span></p><p><span style="color: rgb(51, 51, 51)">因此MapReduce大部分的输入数据都是在本地读取的，不占用网络带宽。</span></p><h3 id="4-5-任务粒度（Task-Granularity）"><a href="#4-5-任务粒度（Task-Granularity）" class="headerlink" title="4.5 任务粒度（Task Granularity）"></a><span style="color: rgb(51, 51, 51)">4.5 任务粒度（Task Granularity）</span></h3><p><span style="color: rgb(51, 51, 51)">之前在工作流中提到，输入文件被分为 M 个切片，而通过划分函数将存储在disk中的中间文件划分为 R 个区域。为了提升动态载入平衡能力以及加快 failed worker 的恢复，M 和 R 的值应当被设置地远大于worker machines数量。</span></p><p><span style="color: rgb(51, 51, 51)">但 M 和 R 的值越大越好，因为 master 会进行 O(M + R) 次的调度，同时master会在内存中存储 O(M * R) 状态值，因此 M 和 R 的值也会有一个界限（Bound）。</span></p><p><span style="color: rgb(51, 51, 51)">R 的值通常由worker数量来决定，一个worker承担一个或多个region的reduce操作，产出一个单独的结果文件。用户通常决定的是 M 的值，实践中每一个独立的任务在 16MB ~ 64MB 输入数据时，能够最有效地实现局部性优化。而 R 的数量只需要是worker数量的小几倍就行了。</span></p><p><span style="color: rgb(51, 51, 51)">例如：M &#x3D; 200000， R &#x3D; 5000 ，2000 worker machines 来处理。</span></p><p>Referred in <a href="./MTitle：分布式系统研究-NPNE5ZQY.md" rel="noopener noreferrer nofollow" zhref="zotero://note/u/NPNE5ZQY/?ignore=1&#x26;line=2" ztype="znotelink" class="internal-link">MTitle：分布式系统研究</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MapReduce模型&lt;/p&gt;
&lt;h1 id=&quot;1-MapReduce模型介绍&quot;&gt;&lt;a href=&quot;#1-MapReduce模型介绍&quot; class=&quot;headerlink&quot; title=&quot;1 MapReduce模型介绍&quot;&gt;&lt;/a&gt;1 MapReduce模型介绍&lt;/h1&gt;&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E6%96%87%E7%8C%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/MTitle%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%A0%94%E7%A9%B6-NPNE5ZQY/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E6%96%87%E7%8C%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/MTitle%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%A0%94%E7%A9%B6-NPNE5ZQY/</id>
    <published>2023-10-30T14:04:29.047Z</published>
    <updated>2023-10-30T14:04:29.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MTitle：分布式系统研究"><a href="#MTitle：分布式系统研究" class="headerlink" title="MTitle：分布式系统研究"></a>MTitle：分布式系统研究</h1><h1 id="分布式系统技术研究"><a href="#分布式系统技术研究" class="headerlink" title="分布式系统技术研究"></a>分布式系统技术研究</h1><p><a href="./MapReduce模型-CK4X2BJ8.md" rel="noopener noreferrer nofollow" zhref="zotero://note/u/CK4X2BJ8/" ztype="znotelink" class="internal-link">从MapReduce入手了了解简单的分布式系统</a></p><h1 id="分布式相关论文"><a href="#分布式相关论文" class="headerlink" title="分布式相关论文"></a>分布式相关论文</h1><p><a href="./(01-2008)-MapReduce--simplified-data-processing-on-large-clusters-P4YGNUSB.md" rel="noopener noreferrer nofollow" zhref="zotero://note/u/P4YGNUSB/" ztype="znotelink" class="internal-link">MapReduce: simplified data processing on large clusters</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MTitle：分布式系统研究&quot;&gt;&lt;a href=&quot;#MTitle：分布式系统研究&quot; class=&quot;headerlink&quot; title=&quot;MTitle：分布式系统研究&quot;&gt;&lt;/a&gt;MTitle：分布式系统研究&lt;/h1&gt;&lt;h1 id=&quot;分布式系统技术研究&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E6%96%87%E7%8C%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/(01-2008)-MapReduce--simplified-data-processing-on-large-clusters-P4YGNUSB/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E6%96%87%E7%8C%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/(01-2008)-MapReduce--simplified-data-processing-on-large-clusters-P4YGNUSB/</id>
    <published>2023-10-30T14:04:29.046Z</published>
    <updated>2023-10-30T14:04:29.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01-x2F-2008-MapReduce-simplified-data-processing-on-large-clusters"><a href="#01-x2F-2008-MapReduce-simplified-data-processing-on-large-clusters" class="headerlink" title="(01&#x2F;2008) MapReduce: simplified data processing on large clusters"></a><span style="color: #e65100;"><span style="background-color: #fff8e1;">(01&#x2F;2008) MapReduce: simplified data processing on large clusters</span></span></h1><table><thead><tr><th></th></tr></thead><tbody><tr><td>**期刊: <span style="color: #ff0000;">Communications of the ACM</span><strong>（发表日期:<strong>01&#x2F;2008</strong>）</strong>作者:**Jeffrey Dean; Sanjay Ghemawat</td></tr><tr><td>**DOI : **<a href="https://doi.org/10.1145/1327452.1327492">10.1145&#x2F;1327452.1327492</a></td></tr><tr><td>**摘要: **<em>MapReduce is a programming model and an associated implementation for processing and generating large datasets that is amenable to a broad variety of real-world tasks. Users specify the computation in terms of a map and a reduce function, and the underlying runtime system automatically parallelizes the computation across large-scale clusters of machines, handles machine failures, and schedules inter-machine communication to make efficient use of the network and disks. Programmers find the system easy to use: more than ten thousand distinct MapReduce programs have been implemented internally at Google over the past four years, and an average of one hundred thousand MapReduce jobs are executed on Google’s clusters every day, processing a total of more than twenty petabytes of data per day.</em></td></tr><tr><td>**期刊分区: **undefined</td></tr><tr><td>**原文PDF链接: **<a href="zotero://open-pdf/0_UEA45RNH">Dean 和 Ghemawat - 2008 - MapReduce simplified data processing on large clu.pdf</a></td></tr><tr><td>**笔记创建日期: **2023&#x2F;10&#x2F;9 下午3:27:49</td></tr></tbody></table><h2 id="📚文章背景"><a href="#📚文章背景" class="headerlink" title="📚文章背景"></a>📚文章背景</h2><p><a class="internal-link" href="zotero://note/u/3FIF5M4P/" zhref="zotero://note/u/3FIF5M4P/" ztype="znotelink" class="internal-link">写作背景</a></p><blockquote><p>写作背景</p><p>&lt;img src&#x3D;”<a href="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/MVBHW6BL.png">https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/MVBHW6BL.png</a>“ alt&#x3D;”&lt;img alt&#x3D;”” data-attachment-key&#x3D;”MVBHW6BL” data-annotation&#x3D;”%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FUEA45RNH%22%2C%22annotationKey%22%3A%22KLKJGHJP%22%2C%22color%22%3A%22%23aaaaaa%22%2C%22pageLabel%22%3A%22107%22%2C%22position%22%3A%7B%22pageIndex%22%3A0%2C%22rects%22%3A%5B%5B35.4%2C315%2C297%2C470.4%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%5D%2C%22locator%22%3A%22107%22%7D%7D” width&#x3D;”436” height&#x3D;”259” src&#x3D;”attachments&#x2F;MVBHW6BL.png” ztype&#x3D;”zimage” style&#x3D;”zoom:25%;” &gt;” &#x2F;&gt; <span class="citation" data-citation="%7B%22citationItems%22%3A%5B%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%5D%2C%22itemData%22%3A%7B%22id%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%2C%22type%22%3A%22article-journal%22%2C%22abstract%22%3A%22MapReduce%20is%20a%20programming%20model%20and%20an%20associated%20implementation%20for%20processing%20and%20generating%20large%20datasets%20that%20is%20amenable%20to%20a%20broad%20variety%20of%20real-world%20tasks.%20Users%20specify%20the%20computation%20in%20terms%20of%20a%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20map%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20and%20a%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20reduce%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20function%2C%20and%20the%20underlying%20runtime%20system%20automatically%20parallelizes%20the%20computation%20across%20large-scale%20clusters%20of%20machines%2C%20handles%20machine%20failures%2C%20and%20schedules%20inter-machine%20communication%20to%20make%20efficient%20use%20of%20the%20network%20and%20disks.%20Programmers%20find%20the%20system%20easy%20to%20use%3A%20more%20than%20ten%20thousand%20distinct%20MapReduce%20programs%20have%20been%20implemented%20internally%20at%20Google%20over%20the%20past%20four%20years%2C%20and%20an%20average%20of%20one%20hundred%20thousand%20MapReduce%20jobs%20are%20executed%20on%20Google&#x27;s%20clusters%20every%20day%2C%20processing%20a%20total%20of%20more%20than%20twenty%20petabytes%20of%20data%20per%20day.%22%2C%22container-title%22%3A%22Communications%20of%20the%20ACM%22%2C%22DOI%22%3A%2210.1145%2F1327452.1327492%22%2C%22ISSN%22%3A%220001-0782%2C%201557-7317%22%2C%22issue%22%3A%221%22%2C%22journalAbbreviation%22%3A%22Commun.%20ACM%22%2C%22language%22%3A%22en%22%2C%22page%22%3A%22107-113%22%2C%22source%22%3A%22DOI.org%20(Crossref)%22%2C%22title%22%3A%22MapReduce%3A%20simplified%20data%20processing%20on%20large%20clusters%22%2C%22title-short%22%3A%22MapReduce%22%2C%22URL%22%3A%22https%3A%2F%2Fdl.acm.org%2Fdoi%2F10.1145%2F1327452.1327492%22%2C%22volume%22%3A%2251%22%2C%22author%22%3A%5B%7B%22family%22%3A%22Dean%22%2C%22given%22%3A%22Jeffrey%22%7D%2C%7B%22family%22%3A%22Ghemawat%22%2C%22given%22%3A%22Sanjay%22%7D%5D%2C%22accessed%22%3A%7B%22date-parts%22%3A%5B%5B%222023%22%2C10%2C7%5D%5D%7D%2C%22issued%22%3A%7B%22date-parts%22%3A%5B%5B%222008%22%2C1%5D%5D%7D%7D%7D%5D%2C%22properties%22%3A%7B%7D%7D" ztype="zcitation">(<span class="citation-item"><a href="zotero://select/library/items/MUH7F2C2">Dean 和 Ghemawat, 2008</a></span>)</span></p><p>Referred in <a class="internal-link" href="zotero://note/u/7DTXN3FC/?ignore=1&#x26;line=3" zhref="zotero://note/u/7DTXN3FC/?ignore=1&#x26;line=3" ztype="znotelink" class="internal-link">(01&#x2F;2008) MapReduce: simplified data processing on large clusters</a></p></blockquote><p><a class="internal-link" href="zotero://note/u/BHI8RWUB/" zhref="zotero://note/u/BHI8RWUB/" ztype="znotelink" class="internal-link">研究背景</a></p><blockquote><p><span style="color: #7e8386;"><span style="background-color: #aaaaaa80;">研究背景</span></span></p><p>🔤在我们开发 MapReduce 之前，作者和 Google 的许多其他人实施了数百种特殊用途计算，这些计算处理大量原始数据（例如爬行文档、Web 请求日志等），以计算各种派生数据，例如例如倒排索引、Web 文档图形结构的各种表示、每个主机抓取的页面数量的摘要以及给定日期中最频繁查询的集合。大多数此类计算在概念上都很简单。然而，输入数据通常很大，计算必须分布在数百或数千台机器上才能在合理的时间内完成。如何并行计算、分布数据、处理故障等问题，用大量复杂的代码来处理这些问题，掩盖了原本简单的计算🔤</p><p><span class="highlight" data-annotation="%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FUEA45RNH%22%2C%22annotationKey%22%3A%22MK8SK3NA%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%22107%22%2C%22position%22%3A%7B%22pageIndex%22%3A0%2C%22rects%22%3A%5B%5B39.981%2C459.705%2C294.955%2C468.642%5D%2C%5B39.981%2C447.708%2C294.955%2C456.645%5D%2C%5B39.981%2C435.711%2C294.966%2C444.648%5D%2C%5B39.981%2C423.714%2C295.038%2C432.651%5D%2C%5B39.981%2C411.717%2C294.954%2C420.654%5D%2C%5B39.981%2C399.72%2C294.952%2C408.657%5D%2C%5B39.981%2C387.723%2C294.993%2C396.66%5D%2C%5B39.981%2C375.726%2C294.951%2C384.663%5D%2C%5B39.981%2C363.729%2C294.957%2C372.666%5D%2C%5B39.981%2C351.732%2C294.947%2C360.669%5D%2C%5B39.981%2C339.735%2C294.939%2C348.672%5D%2C%5B39.981%2C327.738%2C294.957%2C336.675%5D%2C%5B39.981%2C315.741%2C292.622%2C324.678%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%5D%2C%22locator%22%3A%22107%22%7D%7D" ztype="zhighlight"><a href="zotero://open-pdf/library/items/UEA45RNH?page=1&#x26;annotation=MK8SK3NA">“Prior to our development of MapReduce, the authors and many others at Google implemented hundreds of special-purpose computations that process large amounts of raw data, such as crawled documents, Web request logs, etc., to compute various kinds of derived data, such as inverted indices, various representations of the graph structure of Web documents, summaries of the number of pages crawled per host, and the set of most frequent queries in a given day. Most such computations are conceptually straightforward. However, the input data is usually large and the computations have to be distributed across hundreds or thousands of machines in order to finish in a reasonable amount of time. The issues of how to parallelize the computation, distribute the data, and handle failures conspire to obscure the original simple computation with large amounts of complex code to deal with these issues”</a></span> <span class="citation" data-citation="%7B%22citationItems%22%3A%5B%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%5D%2C%22itemData%22%3A%7B%22id%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%2C%22type%22%3A%22article-journal%22%2C%22abstract%22%3A%22MapReduce%20is%20a%20programming%20model%20and%20an%20associated%20implementation%20for%20processing%20and%20generating%20large%20datasets%20that%20is%20amenable%20to%20a%20broad%20variety%20of%20real-world%20tasks.%20Users%20specify%20the%20computation%20in%20terms%20of%20a%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20map%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20and%20a%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20reduce%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20function%2C%20and%20the%20underlying%20runtime%20system%20automatically%20parallelizes%20the%20computation%20across%20large-scale%20clusters%20of%20machines%2C%20handles%20machine%20failures%2C%20and%20schedules%20inter-machine%20communication%20to%20make%20efficient%20use%20of%20the%20network%20and%20disks.%20Programmers%20find%20the%20system%20easy%20to%20use%3A%20more%20than%20ten%20thousand%20distinct%20MapReduce%20programs%20have%20been%20implemented%20internally%20at%20Google%20over%20the%20past%20four%20years%2C%20and%20an%20average%20of%20one%20hundred%20thousand%20MapReduce%20jobs%20are%20executed%20on%20Google&#x27;s%20clusters%20every%20day%2C%20processing%20a%20total%20of%20more%20than%20twenty%20petabytes%20of%20data%20per%20day.%22%2C%22container-title%22%3A%22Communications%20of%20the%20ACM%22%2C%22DOI%22%3A%2210.1145%2F1327452.1327492%22%2C%22ISSN%22%3A%220001-0782%2C%201557-7317%22%2C%22issue%22%3A%221%22%2C%22journalAbbreviation%22%3A%22Commun.%20ACM%22%2C%22language%22%3A%22en%22%2C%22page%22%3A%22107-113%22%2C%22source%22%3A%22DOI.org%20(Crossref)%22%2C%22title%22%3A%22MapReduce%3A%20simplified%20data%20processing%20on%20large%20clusters%22%2C%22title-short%22%3A%22MapReduce%22%2C%22URL%22%3A%22https%3A%2F%2Fdl.acm.org%2Fdoi%2F10.1145%2F1327452.1327492%22%2C%22volume%22%3A%2251%22%2C%22author%22%3A%5B%7B%22family%22%3A%22Dean%22%2C%22given%22%3A%22Jeffrey%22%7D%2C%7B%22family%22%3A%22Ghemawat%22%2C%22given%22%3A%22Sanjay%22%7D%5D%2C%22accessed%22%3A%7B%22date-parts%22%3A%5B%5B%222023%22%2C10%2C7%5D%5D%7D%2C%22issued%22%3A%7B%22date-parts%22%3A%5B%5B%222008%22%2C1%5D%5D%7D%7D%7D%5D%2C%22properties%22%3A%7B%7D%7D" ztype="zcitation">(<span class="citation-item"><a href="zotero://select/library/items/MUH7F2C2">Dean 和 Ghemawat, 2008</a></span>)</span></p><p>Referred in <a class="internal-link" href="./(01-2008)-MapReduce--simplified-data-processing-on-large-clusters-P4YGNUSB.md" zhref="zotero://note/u/P4YGNUSB/?ignore=1&#x26;line=10" ztype="znotelink" class="internal-link">(01&#x2F;2008) MapReduce: simplified data processing on large clusters</a></p></blockquote><h2 id="🧩可行性"><a href="#🧩可行性" class="headerlink" title="🧩可行性"></a>🧩可行性</h2><p><a class="internal-link" href="zotero://note/u/ADFT34KA/" zhref="zotero://note/u/ADFT34KA/" ztype="znotelink" class="internal-link">研究可行性</a></p><blockquote><p>研究可行性</p><p>🔤我们的抽象受到 Lisp 和许多其他函数式语言中存在的映射和归约原语的启发。我们意识到，我们的大多数计算涉及对输入中的每个逻辑记录应用映射操作，以计算一组中间键&#x2F;值对，然后对共享相同键的所有值按顺序应用归约操作适当地组合派生数据。我们使用具有用户指定的映射和归约操作的功能模型，使我们能够轻松并行化大型计算，并使用重新执行作为容错的主要机制。🔤</p><p><span class="highlight" data-annotation="%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FUEA45RNH%22%2C%22annotationKey%22%3A%22SBJF7GIZ%22%2C%22color%22%3A%22%23aaaaaa%22%2C%22pageLabel%22%3A%22107%22%2C%22position%22%3A%7B%22pageIndex%22%3A0%2C%22rects%22%3A%5B%5B175.81%2C267.714%2C294.905%2C276.651%5D%2C%5B39.979%2C255.717%2C294.857%2C264.654%5D%2C%5B39.979%2C243.72%2C294.893%2C252.657%5D%2C%5B39.979%2C231.723%2C294.886%2C240.66%5D%2C%5B39.979%2C219.726%2C294.899%2C228.663%5D%2C%5B39.979%2C207.729%2C294.868%2C216.666%5D%2C%5B39.979%2C195.732%2C294.839%2C204.669%5D%2C%5B39.979%2C183.735%2C294.894%2C192.672%5D%2C%5B39.979%2C171.738%2C283.837%2C180.675%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%5D%2C%22locator%22%3A%22107%22%7D%7D" ztype="zhighlight"><a href="zotero://open-pdf/library/items/UEA45RNH?page=1&#x26;annotation=SBJF7GIZ">“Our abstraction is inspired by the map and reduce primitives present in Lisp and many other functional languages. We realized that most of our computations involved applying a map operation to each logical record’ in our input in order to compute a set of intermediate key&#x2F;value pairs, and then applying a reduce operation to all the values that shared the same key in order to combine the derived data appropriately. Our use of a functional model with user-specified map and reduce operations allows us to parallelize large computations easily and to use reexecution as the primary mechanism for fault tolerance.”</a></span> <span class="citation" data-citation="%7B%22citationItems%22%3A%5B%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%5D%2C%22itemData%22%3A%7B%22id%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%2C%22type%22%3A%22article-journal%22%2C%22abstract%22%3A%22MapReduce%20is%20a%20programming%20model%20and%20an%20associated%20implementation%20for%20processing%20and%20generating%20large%20datasets%20that%20is%20amenable%20to%20a%20broad%20variety%20of%20real-world%20tasks.%20Users%20specify%20the%20computation%20in%20terms%20of%20a%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20map%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20and%20a%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20reduce%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20function%2C%20and%20the%20underlying%20runtime%20system%20automatically%20parallelizes%20the%20computation%20across%20large-scale%20clusters%20of%20machines%2C%20handles%20machine%20failures%2C%20and%20schedules%20inter-machine%20communication%20to%20make%20efficient%20use%20of%20the%20network%20and%20disks.%20Programmers%20find%20the%20system%20easy%20to%20use%3A%20more%20than%20ten%20thousand%20distinct%20MapReduce%20programs%20have%20been%20implemented%20internally%20at%20Google%20over%20the%20past%20four%20years%2C%20and%20an%20average%20of%20one%20hundred%20thousand%20MapReduce%20jobs%20are%20executed%20on%20Google&#x27;s%20clusters%20every%20day%2C%20processing%20a%20total%20of%20more%20than%20twenty%20petabytes%20of%20data%20per%20day.%22%2C%22container-title%22%3A%22Communications%20of%20the%20ACM%22%2C%22DOI%22%3A%2210.1145%2F1327452.1327492%22%2C%22ISSN%22%3A%220001-0782%2C%201557-7317%22%2C%22issue%22%3A%221%22%2C%22journalAbbreviation%22%3A%22Commun.%20ACM%22%2C%22language%22%3A%22en%22%2C%22page%22%3A%22107-113%22%2C%22source%22%3A%22DOI.org%20(Crossref)%22%2C%22title%22%3A%22MapReduce%3A%20simplified%20data%20processing%20on%20large%20clusters%22%2C%22title-short%22%3A%22MapReduce%22%2C%22URL%22%3A%22https%3A%2F%2Fdl.acm.org%2Fdoi%2F10.1145%2F1327452.1327492%22%2C%22volume%22%3A%2251%22%2C%22author%22%3A%5B%7B%22family%22%3A%22Dean%22%2C%22given%22%3A%22Jeffrey%22%7D%2C%7B%22family%22%3A%22Ghemawat%22%2C%22given%22%3A%22Sanjay%22%7D%5D%2C%22accessed%22%3A%7B%22date-parts%22%3A%5B%5B%222023%22%2C10%2C7%5D%5D%7D%2C%22issued%22%3A%7B%22date-parts%22%3A%5B%5B%222008%22%2C1%5D%5D%7D%7D%7D%5D%2C%22properties%22%3A%7B%7D%7D" ztype="zcitation">(<span class="citation-item"><a href="zotero://select/library/items/MUH7F2C2">Dean 和 Ghemawat, 2008</a></span>)</span></p><p>Referred in <a class="internal-link" href="./(01-2008)-MapReduce--simplified-data-processing-on-large-clusters-P4YGNUSB.md" zhref="zotero://note/u/P4YGNUSB/?ignore=1&#x26;line=-1" ztype="znotelink" class="internal-link">(01&#x2F;2008) MapReduce: simplified data processing on large clusters</a></p></blockquote><h2 id="🔬实现方法"><a href="#🔬实现方法" class="headerlink" title="🔬实现方法"></a>🔬实现方法</h2><h3 id="模型实现"><a href="#模型实现" class="headerlink" title="模型实现"></a>模型实现</h3><p><a class="internal-link" href="zotero://note/u/M9YRSMY9/" zhref="zotero://note/u/M9YRSMY9/" ztype="znotelink" class="internal-link">简述实现方式</a></p><blockquote><p>简述实现方式</p><p>🔤Map 由用户编写，接受一个输入对并生成一组中间键&#x2F;值对。 MapReduce 库将与同一中间键 I 关联的所有中间值组合在一起，并将它们传递给reduce 函数。 reduce 函数也由用户编写，接受中间键 I 和该键的一组值。它将这些值合并在一起以形成可能更小的值集。通常每次reduce 调用仅产生零或一个输出值。中间值通过迭代器提供给用户的reduce函数。这使我们能够处理太大而无法容纳在内存中的值列表。🔤</p><p><span class="highlight" data-annotation="%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FUEA45RNH%22%2C%22annotationKey%22%3A%22TC3F89CH%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%22107%22%2C%22position%22%3A%7B%22pageIndex%22%3A0%2C%22rects%22%3A%5B%5B318.978%2C231.714%2C562%2C240.651%5D%2C%5B306.981%2C219.717%2C562.002%2C228.654%5D%2C%5B306.981%2C207.72%2C561.987%2C216.657%5D%2C%5B306.981%2C195.723%2C454.787%2C204.66%5D%2C%5B318.978%2C183.726%2C561.991%2C192.663%5D%2C%5B306.981%2C171.729%2C562.163%2C180.666%5D%2C%5B306.981%2C159.732%2C561.997%2C168.669%5D%2C%5B306.981%2C147.735%2C562.005%2C156.672%5D%2C%5B306.981%2C135.738%2C561.998%2C144.675%5D%2C%5B306.981%2C123.741%2C556.425%2C132.678%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%5D%2C%22locator%22%3A%22107%22%7D%7D" ztype="zhighlight"><a href="zotero://open-pdf/library/items/UEA45RNH?page=1&#x26;annotation=TC3F89CH">“Map, written by the user, takes an input pair and produces a set of intermediate key&#x2F;value pairs. The MapReduce library groups together all intermediate values associated with the same intermediate key I and passes them to the reduce function. The reduce function, also written by the user, accepts an intermediate key I and a set of values for that key. It merges these values together to form a possibly smaller set of values. Typically just zero or one output value is produced per reduce invocation. The intermediate values are supplied to the user’s reduce function via an iterator. This allows us to handle lists of values that are too large to fit in memory.”</a></span> <span class="citation" data-citation="%7B%22citationItems%22%3A%5B%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%5D%2C%22itemData%22%3A%7B%22id%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%2C%22type%22%3A%22article-journal%22%2C%22abstract%22%3A%22MapReduce%20is%20a%20programming%20model%20and%20an%20associated%20implementation%20for%20processing%20and%20generating%20large%20datasets%20that%20is%20amenable%20to%20a%20broad%20variety%20of%20real-world%20tasks.%20Users%20specify%20the%20computation%20in%20terms%20of%20a%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20map%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20and%20a%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20reduce%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20function%2C%20and%20the%20underlying%20runtime%20system%20automatically%20parallelizes%20the%20computation%20across%20large-scale%20clusters%20of%20machines%2C%20handles%20machine%20failures%2C%20and%20schedules%20inter-machine%20communication%20to%20make%20efficient%20use%20of%20the%20network%20and%20disks.%20Programmers%20find%20the%20system%20easy%20to%20use%3A%20more%20than%20ten%20thousand%20distinct%20MapReduce%20programs%20have%20been%20implemented%20internally%20at%20Google%20over%20the%20past%20four%20years%2C%20and%20an%20average%20of%20one%20hundred%20thousand%20MapReduce%20jobs%20are%20executed%20on%20Google&#x27;s%20clusters%20every%20day%2C%20processing%20a%20total%20of%20more%20than%20twenty%20petabytes%20of%20data%20per%20day.%22%2C%22container-title%22%3A%22Communications%20of%20the%20ACM%22%2C%22DOI%22%3A%2210.1145%2F1327452.1327492%22%2C%22ISSN%22%3A%220001-0782%2C%201557-7317%22%2C%22issue%22%3A%221%22%2C%22journalAbbreviation%22%3A%22Commun.%20ACM%22%2C%22language%22%3A%22en%22%2C%22page%22%3A%22107-113%22%2C%22source%22%3A%22DOI.org%20(Crossref)%22%2C%22title%22%3A%22MapReduce%3A%20simplified%20data%20processing%20on%20large%20clusters%22%2C%22title-short%22%3A%22MapReduce%22%2C%22URL%22%3A%22https%3A%2F%2Fdl.acm.org%2Fdoi%2F10.1145%2F1327452.1327492%22%2C%22volume%22%3A%2251%22%2C%22author%22%3A%5B%7B%22family%22%3A%22Dean%22%2C%22given%22%3A%22Jeffrey%22%7D%2C%7B%22family%22%3A%22Ghemawat%22%2C%22given%22%3A%22Sanjay%22%7D%5D%2C%22accessed%22%3A%7B%22date-parts%22%3A%5B%5B%222023%22%2C10%2C7%5D%5D%7D%2C%22issued%22%3A%7B%22date-parts%22%3A%5B%5B%222008%22%2C1%5D%5D%7D%7D%7D%5D%2C%22properties%22%3A%7B%7D%7D" ztype="zcitation">(<span class="citation-item"><a href="zotero://select/library/items/MUH7F2C2">Dean 和 Ghemawat, 2008</a></span>)</span></p><p>Referred in <a class="internal-link" href="./(01-2008)-MapReduce--simplified-data-processing-on-large-clusters-P4YGNUSB.md" zhref="zotero://note/u/P4YGNUSB/?ignore=1&#x26;line=11" ztype="znotelink" class="internal-link">(01&#x2F;2008) MapReduce: simplified data processing on large clusters</a></p></blockquote><p><a class="internal-link" href="zotero://note/u/YH4AP6M9/" zhref="zotero://note/u/YH4AP6M9/" ztype="znotelink" class="internal-link">实现细节 (Dean 和 Ghemawat, 2008, p. 3)</a></p><blockquote><p>实现细节 <img src="/attachments/8KB6AZVW.png" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;8KB6AZVW&quot; src=&quot;attachments/8KB6AZVW.png&quot; ztype=&quot;zimage&quot;&gt;"> <span class="citation" data-citation="%7B%22citationItems%22%3A%5B%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%5D%2C%22itemData%22%3A%7B%22id%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%2C%22type%22%3A%22article-journal%22%2C%22abstract%22%3A%22MapReduce%20is%20a%20programming%20model%20and%20an%20associated%20implementation%20for%20processing%20and%20generating%20large%20datasets%20that%20is%20amenable%20to%20a%20broad%20variety%20of%20real-world%20tasks.%20Users%20specify%20the%20computation%20in%20terms%20of%20a%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20map%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20and%20a%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20reduce%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20function%2C%20and%20the%20underlying%20runtime%20system%20automatically%20parallelizes%20the%20computation%20across%20large-scale%20clusters%20of%20machines%2C%20handles%20machine%20failures%2C%20and%20schedules%20inter-machine%20communication%20to%20make%20efficient%20use%20of%20the%20network%20and%20disks.%20Programmers%20find%20the%20system%20easy%20to%20use%3A%20more%20than%20ten%20thousand%20distinct%20MapReduce%20programs%20have%20been%20implemented%20internally%20at%20Google%20over%20the%20past%20four%20years%2C%20and%20an%20average%20of%20one%20hundred%20thousand%20MapReduce%20jobs%20are%20executed%20on%20Google&#x27;s%20clusters%20every%20day%2C%20processing%20a%20total%20of%20more%20than%20twenty%20petabytes%20of%20data%20per%20day.%22%2C%22container-title%22%3A%22Communications%20of%20the%20ACM%22%2C%22DOI%22%3A%2210.1145%2F1327452.1327492%22%2C%22ISSN%22%3A%220001-0782%2C%201557-7317%22%2C%22issue%22%3A%221%22%2C%22journalAbbreviation%22%3A%22Commun.%20ACM%22%2C%22language%22%3A%22en%22%2C%22page%22%3A%22107-113%22%2C%22source%22%3A%22DOI.org%20(Crossref)%22%2C%22title%22%3A%22MapReduce%3A%20simplified%20data%20processing%20on%20large%20clusters%22%2C%22title-short%22%3A%22MapReduce%22%2C%22URL%22%3A%22https%3A%2F%2Fdl.acm.org%2Fdoi%2F10.1145%2F1327452.1327492%22%2C%22volume%22%3A%2251%22%2C%22author%22%3A%5B%7B%22family%22%3A%22Dean%22%2C%22given%22%3A%22Jeffrey%22%7D%2C%7B%22family%22%3A%22Ghemawat%22%2C%22given%22%3A%22Sanjay%22%7D%5D%2C%22accessed%22%3A%7B%22date-parts%22%3A%5B%5B%222023%22%2C10%2C7%5D%5D%7D%2C%22issued%22%3A%7B%22date-parts%22%3A%5B%5B%222008%22%2C1%5D%5D%7D%7D%7D%5D%2C%22properties%22%3A%7B%7D%7D" ztype="zcitation">(<span class="citation-item"><a href="zotero://select/library/items/MUH7F2C2">Dean 和 Ghemawat, 2008</a></span>)</span></p><p>&lt;img src&#x3D;”<a href="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/V7TNSNQ8.png">https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/V7TNSNQ8.png</a>“ alt&#x3D;”&lt;img alt&#x3D;”” data-attachment-key&#x3D;”V7TNSNQ8” data-annotation&#x3D;”%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FUEA45RNH%22%2C%22annotationKey%22%3A%22XY4C799D%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%22108%22%2C%22position%22%3A%7B%22pageIndex%22%3A1%2C%22rects%22%3A%5B%5B306.455%2C47.822%2C577.081%2C463.29%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%5D%2C%22locator%22%3A%22108%22%7D%7D” width&#x3D;”451” height&#x3D;”692” src&#x3D;”attachments&#x2F;V7TNSNQ8.png” ztype&#x3D;”zimage” style&#x3D;”zoom:50%;” &gt;” &#x2F;&gt;</p><p><img src="/attachments/LHR6SXL5.png" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;LHR6SXL5&quot; src=&quot;attachments/LHR6SXL5.png&quot; ztype=&quot;zimage&quot;&gt;"> <span class="citation" data-citation="%7B%22citationItems%22%3A%5B%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%5D%2C%22itemData%22%3A%7B%22id%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%2C%22type%22%3A%22article-journal%22%2C%22abstract%22%3A%22MapReduce%20is%20a%20programming%20model%20and%20an%20associated%20implementation%20for%20processing%20and%20generating%20large%20datasets%20that%20is%20amenable%20to%20a%20broad%20variety%20of%20real-world%20tasks.%20Users%20specify%20the%20computation%20in%20terms%20of%20a%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20map%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20and%20a%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20reduce%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20function%2C%20and%20the%20underlying%20runtime%20system%20automatically%20parallelizes%20the%20computation%20across%20large-scale%20clusters%20of%20machines%2C%20handles%20machine%20failures%2C%20and%20schedules%20inter-machine%20communication%20to%20make%20efficient%20use%20of%20the%20network%20and%20disks.%20Programmers%20find%20the%20system%20easy%20to%20use%3A%20more%20than%20ten%20thousand%20distinct%20MapReduce%20programs%20have%20been%20implemented%20internally%20at%20Google%20over%20the%20past%20four%20years%2C%20and%20an%20average%20of%20one%20hundred%20thousand%20MapReduce%20jobs%20are%20executed%20on%20Google&#x27;s%20clusters%20every%20day%2C%20processing%20a%20total%20of%20more%20than%20twenty%20petabytes%20of%20data%20per%20day.%22%2C%22container-title%22%3A%22Communications%20of%20the%20ACM%22%2C%22DOI%22%3A%2210.1145%2F1327452.1327492%22%2C%22ISSN%22%3A%220001-0782%2C%201557-7317%22%2C%22issue%22%3A%221%22%2C%22journalAbbreviation%22%3A%22Commun.%20ACM%22%2C%22language%22%3A%22en%22%2C%22page%22%3A%22107-113%22%2C%22source%22%3A%22DOI.org%20(Crossref)%22%2C%22title%22%3A%22MapReduce%3A%20simplified%20data%20processing%20on%20large%20clusters%22%2C%22title-short%22%3A%22MapReduce%22%2C%22URL%22%3A%22https%3A%2F%2Fdl.acm.org%2Fdoi%2F10.1145%2F1327452.1327492%22%2C%22volume%22%3A%2251%22%2C%22author%22%3A%5B%7B%22family%22%3A%22Dean%22%2C%22given%22%3A%22Jeffrey%22%7D%2C%7B%22family%22%3A%22Ghemawat%22%2C%22given%22%3A%22Sanjay%22%7D%5D%2C%22accessed%22%3A%7B%22date-parts%22%3A%5B%5B%222023%22%2C10%2C7%5D%5D%7D%2C%22issued%22%3A%7B%22date-parts%22%3A%5B%5B%222008%22%2C1%5D%5D%7D%7D%7D%5D%2C%22properties%22%3A%7B%7D%7D" ztype="zcitation">(<span class="citation-item"><a href="zotero://select/library/items/MUH7F2C2">Dean 和 Ghemawat, 2008</a></span>)</span></p><p><span style="color: #333333;">MapReduce 的工作流：</span></p><ul><li><p><span style="color: #333333;">将输入文件分成 </span><strong><span style="color: #333333;">M</span></strong><span style="color: #333333;"> 个小文件(split)，每个文件的大小大概 16M-64M（由用户参数控制），在集群中启动 MapReduce 实例，其中</span><code>fork</code></p><p>一个 Master 和多个 Worker；[1]</p></li><li><p><span style="color: #333333;">由 Master 分配任务，将</span></p><p><code>Map</code>与<code>Reduce</code>任务分配给可用的 Worker[2]；</p></li><li><p><code>Map</code>Worker 读取文件[3]，执行用户自定义的 map 函数，输出 中间值key&#x2F;value 对，缓存在内存中；</p></li><li><p><span style="color: #333333;">内存中的 (key, value) 对通过</span></p><p><code>partitioning function()</code>例如<code>hash(key) mod R</code>分为<strong>R</strong>个 regions（保证相同key的键值对在一个分区），然后写入磁盘(local disk)[4]。完成之后，把这些文件的地址回传给 Master，然后 Master 把这些位置传给<code>Reduce</code>Worker；</p></li><li><p><code>Reduce</code>Worker 收到数据存储位置信息后，使用 RPC(Remote Procedure Call远程过程调用协议) 从<code>Map</code>Worker 所在的磁盘读取这些数据[5]，根据 key 进行排序，并将同一 key 的所有数据分组聚合在一起（<strong>由于许多不同的 key 值会映射到相同的 Reduce 任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序</strong>）；</p></li><li><p><code>Reduce</code>Worker 将分组后的值传给用户自定义的 reduce 函数，输出追加到所属分区的输出文件中；</p></li><li><p><span style="color: #333333;">当所有的 Map 任务和 Reduce 任务都完成后，Master 向用户程序返回结果；</span></p></li></ul><p><span style="color: #333333;">MapReduce对输出文件的处理：</span></p><p><span style="color: #333333;">通常情况下，用户并不需要将 R 个输出文件合并成一个文件；他们通常会将这些文件作为输入传递给另一个 MapReduce 调用，或者从另一个能够处理分割成多个文件的输入的分布式应用程序中使用这些文件。</span></p><p>Referred in <a class="internal-link" href="./(01-2008)-MapReduce--simplified-data-processing-on-large-clusters-P4YGNUSB.md" zhref="zotero://note/u/P4YGNUSB/?ignore=1&#x26;line=-1" ztype="znotelink" class="internal-link">(01&#x2F;2008) MapReduce: simplified data processing on large clusters</a></p></blockquote><h3 id="容错实现"><a href="#容错实现" class="headerlink" title="容错实现"></a>容错实现</h3><p><a class="internal-link" href="zotero://note/u/6YCRLMJ3/" zhref="zotero://note/u/6YCRLMJ3/" ztype="znotelink" class="internal-link">处理worker错误</a></p><blockquote><h3 id="处理worker错误"><a href="#处理worker错误" class="headerlink" title="处理worker错误"></a><span style="color: #333333;">处理worker错误</span></h3><ul><li><p><span style="color: #333333;">master通过周期地向worker发送ping指令来确保worker处于存活状态，对于没有回应ping指令的worker，master会将该worker标记为</span></p><p><strong><span style="color: #333333;">failed</span></strong></p></li><li><p><span style="color: #333333;">在failed worker执行中的 Map 或 Reduce 任务会被重置为idle状态，可被其他存活worker接收。</span></p></li><li><p><span style="color: #333333;">在failed worker上已经执行完成的Map任务会被再次执行，因为其输出结果存储在failed worker本地磁盘中，如果failed worker在local write之前就挂掉，那么该数据无法被读取，因此需要从新执行。而Reduce任务不会被再次执行，因为其输出结果存储在全局文件系统中。</span></p></li></ul><p><span style="color: #333333;">对于failed worker任务处理总结下来就是：</span></p><table><thead><tr><th>&lt;span style&#x3D;”color: rgb(51, 51, 51)”&gt;&lt;span style&#x3D;”background-color: var(–th-bg-color)”&gt;任务状态状态&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;</th><th>&lt;span style&#x3D;”color: rgb(51, 51, 51)”&gt;&lt;span style&#x3D;”background-color: var(–th-bg-color)”&gt;Map任务&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;</th><th>&lt;span style&#x3D;”color: rgb(51, 51, 51)”&gt;&lt;span style&#x3D;”background-color: var(–th-bg-color)”&gt;Reduce任务&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;</th></tr></thead><tbody><tr><td>执行中</td><td>设置为idle</td><td>设置为idle</td></tr><tr><td>执行结束</td><td>从新执行</td><td>不用处理</td></tr></tbody></table><p><span style="color: #333333;">对于worker A 执行的Map任务随后被worker B 执行，那么所有执行Reduce任务的worker都会接到通知：还没有从worker A读取数据的reduce worker 将会从worker B 上读取数据。</span></p><p>Referred in <a class="internal-link" href="zotero://note/u/7DTXN3FC/?ignore=1&#x26;line=8" zhref="zotero://note/u/7DTXN3FC/?ignore=1&#x26;line=8" ztype="znotelink" class="internal-link">(01&#x2F;2008) MapReduce: simplified data processing on large clusters</a></p></blockquote><p><a class="internal-link" href="./(01-2008)-MapReduce--simplified-data-processing-on-large-clusters-P4YGNUSB.md" zhref="zotero://note/u/P4YGNUSB/" ztype="znotelink" class="internal-link">处理错误时的语义处理</a></p><blockquote><h4 id="处理错误时的语义处理"><a href="#处理错误时的语义处理" class="headerlink" title="处理错误时的语义处理"></a><span style="color: #333333;">处理错误时的语义处理</span></h4><p><span style="color: #333333;">用户提供的映射（map）和归约（reduce）操作是其输入值的确定性函数时，分布式实现将生成与整个程序的非故障顺序执行所产生的相同输出。</span></p><p><span style="color: #333333;">为了实现这个特性，我们依赖于映射和归约任务输出的原子提交。每个正在进行的任务将其输出写入私有临时文件。一个归约任务产生一个这样的文件，而一个映射任务产生 R 个这样的文件（每个归约任务一个）。当一个映射任务完成时，工作节点向主节点发送消息，并在消息中包含这些临时文件的名称。如果主节点接收到一个已经完成的映射任务的完成消息，它将忽略该消息。否则，它将记录 R 个文件的名称在主节点的数据结构中。当一个归约任务完成时，归约工作节点将其临时输出文件原子性地重命名为最终输出文件。如果相同的归约任务在多个机器上执行，那么对于相同的最终输出文件将执行多个重命名调用。我们依赖底层文件系统提供的原子重命名操作来保证最终文件系统状态仅包含一个归约任务执行产生的数据。我们绝大部分的映射和归约操作是确定性的，而且在这种情况下，我们的语义等效于顺序执行，这使得程序员很容易推断出程序的行为。、</span></p><p><span style="color: #333333;">当映射和&#x2F;或归约操作是非确定性的时，我们提供了较弱但仍然合理的语义。在存在非确定性操作的情况下，特定归约任务 R 的输出等价于非确定性程序的顺序执行产生的 R 的输出。然而，不同归约任务 F 的输出可能对应于由非确定性程序的不同顺序执行产生的 R 的输出。</span></p><p>Referred in <a class="internal-link" href="zotero://note/u/7DTXN3FC/?ignore=1&#x26;line=9" zhref="zotero://note/u/7DTXN3FC/?ignore=1&#x26;line=9" ztype="znotelink" class="internal-link">(01&#x2F;2008) MapReduce: simplified data processing on large clusters</a></p></blockquote><h3 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h3><p><a class="internal-link" href="zotero://note/u/IM4HIF6A/" zhref="zotero://note/u/IM4HIF6A/" ztype="znotelink" class="internal-link">任务粒度（Task Granularity）</a></p><blockquote><h3 id="任务粒度（Task-Granularity）"><a href="#任务粒度（Task-Granularity）" class="headerlink" title="任务粒度（Task Granularity）"></a><span style="color: #333333;">任务粒度（Task Granularity）</span></h3><p><span style="color: #333333;">之前在工作流中提到，输入文件被分为 M 个切片，而通过划分函数将存储在disk中的中间文件划分为 R 个区域。为了提升动态载入平衡能力以及加快 failed worker 的恢复，M 和 R 的值应当被设置地远大于worker machines数量。</span></p><p><span style="color: #333333;">但 M 和 R 的值越大越好，因为 master 会进行 O(M + R) 次的调度，同时master会在内存中存储 O(M * R) 状态值，因此 M 和 R 的值也会有一个界限（Bound）。</span></p><p><span style="color: #333333;">R 的值通常由worker数量来决定，一个worker承担一个或多个region的reduce操作，产出一个单独的结果文件。用户通常决定的是 M 的值，实践中每一个独立的任务在 16MB ~ 64MB 输入数据时，能够最有效地实现局部性优化。而 R 的数量只需要是worker数量的小几倍就行了。</span></p><p><span style="color: #333333;">例如：M &#x3D; 200000， R &#x3D; 5000 ，2000 worker machines 来处理。</span></p><p>Referred in <a class="internal-link" href="./(01-2008)-MapReduce--simplified-data-processing-on-large-clusters-P4YGNUSB.md" zhref="zotero://note/u/P4YGNUSB/?ignore=1&#x26;line=15" ztype="znotelink" class="internal-link">Workspace Note</a></p><p>Referred in <a class="internal-link" href="zotero://note/u/7DTXN3FC/?ignore=1&#x26;line=13" zhref="zotero://note/u/7DTXN3FC/?ignore=1&#x26;line=13" ztype="znotelink" class="internal-link">(01&#x2F;2008) MapReduce: simplified data processing on large clusters</a></p></blockquote><p><a class="internal-link" href="zotero://note/u/KYQ46U5V/" zhref="zotero://note/u/KYQ46U5V/" ztype="znotelink" class="internal-link">读取位置(locality)</a></p><blockquote><h3 id="读取位置-locality"><a href="#读取位置-locality" class="headerlink" title="读取位置(locality)"></a><span style="color: #333333;">读取位置(locality)</span></h3><p><span class="highlight" data-annotation="%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FUEA45RNH%22%2C%22annotationKey%22%3A%22WY4DT687%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B151.911%2C287.602%2C294.543%2C296.539%5D%2C%5B39.608%2C275.821%2C294.544%2C284.758%5D%2C%5B39.608%2C264.04%2C294.613%2C272.977%5D%2C%5B39.608%2C252.259%2C77.916%2C261.196%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%5D%2C%22locator%22%3A%224%22%7D%7D" ztype="zhighlight"><a href="zotero://open-pdf/library/items/UEA45RNH?page=4&#x26;annotation=WY4DT687">“The MapReduce master takes the location information of the input files into account and attempts to schedule a map task on a machine that contains a replica of the corresponding input data.”</a></span> <span class="citation" data-citation="%7B%22citationItems%22%3A%5B%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%5D%2C%22itemData%22%3A%7B%22id%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2F12640518%2Fitems%2FMUH7F2C2%22%2C%22type%22%3A%22article-journal%22%2C%22abstract%22%3A%22MapReduce%20is%20a%20programming%20model%20and%20an%20associated%20implementation%20for%20processing%20and%20generating%20large%20datasets%20that%20is%20amenable%20to%20a%20broad%20variety%20of%20real-world%20tasks.%20Users%20specify%20the%20computation%20in%20terms%20of%20a%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20map%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20and%20a%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20reduce%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20function%2C%20and%20the%20underlying%20runtime%20system%20automatically%20parallelizes%20the%20computation%20across%20large-scale%20clusters%20of%20machines%2C%20handles%20machine%20failures%2C%20and%20schedules%20inter-machine%20communication%20to%20make%20efficient%20use%20of%20the%20network%20and%20disks.%20Programmers%20find%20the%20system%20easy%20to%20use%3A%20more%20than%20ten%20thousand%20distinct%20MapReduce%20programs%20have%20been%20implemented%20internally%20at%20Google%20over%20the%20past%20four%20years%2C%20and%20an%20average%20of%20one%20hundred%20thousand%20MapReduce%20jobs%20are%20executed%20on%20Google&#x27;s%20clusters%20every%20day%2C%20processing%20a%20total%20of%20more%20than%20twenty%20petabytes%20of%20data%20per%20day.%22%2C%22container-title%22%3A%22Communications%20of%20the%20ACM%22%2C%22DOI%22%3A%2210.1145%2F1327452.1327492%22%2C%22ISSN%22%3A%220001-0782%2C%201557-7317%22%2C%22issue%22%3A%221%22%2C%22journalAbbreviation%22%3A%22Commun.%20ACM%22%2C%22language%22%3A%22en%22%2C%22page%22%3A%22107-113%22%2C%22source%22%3A%22DOI.org%20(Crossref)%22%2C%22title%22%3A%22MapReduce%3A%20simplified%20data%20processing%20on%20large%20clusters%22%2C%22title-short%22%3A%22MapReduce%22%2C%22URL%22%3A%22https%3A%2F%2Fdl.acm.org%2Fdoi%2F10.1145%2F1327452.1327492%22%2C%22volume%22%3A%2251%22%2C%22author%22%3A%5B%7B%22family%22%3A%22Dean%22%2C%22given%22%3A%22Jeffrey%22%7D%2C%7B%22family%22%3A%22Ghemawat%22%2C%22given%22%3A%22Sanjay%22%7D%5D%2C%22accessed%22%3A%7B%22date-parts%22%3A%5B%5B%222023%22%2C10%2C7%5D%5D%7D%2C%22issued%22%3A%7B%22date-parts%22%3A%5B%5B%222008%22%2C1%5D%5D%7D%7D%7D%5D%2C%22properties%22%3A%7B%7D%7D" ztype="zcitation">(<span class="citation-item"><a href="zotero://select/library/items/MUH7F2C2">Dean 和 Ghemawat, 2008</a></span>)</span> 🔤MapReduce master 考虑输入文件的位置信息，并尝试在包含相应输入数据副本的计算机上安排映射任务。🔤</p><p><span style="color: #333333;">为了节省带宽资源，MapReduce工作集群中输入数据通常存储在机器的本地磁盘中，在Map任务开始前，Master会考虑输入文件的位置信息，将尝试在包含输入数据的机器上执行Map任务。</span></p><p><span style="color: #333333;">如果上述方法行不通，Master也会考虑在存储输入文件机器附近的机器（例如，在与包含数据的机器处于同一交换机上工作的机器）执行Map任务。</span></p><p><span style="color: #333333;">因此MapReduce大部分的输入数据都是在本地读取的，不占用网络带宽。</span></p><p>Referred in <a class="internal-link" href="./(01-2008)-MapReduce--simplified-data-processing-on-large-clusters-P4YGNUSB.md" zhref="zotero://note/u/P4YGNUSB/?ignore=1&#x26;line=15" ztype="znotelink" class="internal-link">Workspace Note</a></p><p>Referred in <a class="internal-link" href="zotero://note/u/7DTXN3FC/?ignore=1&#x26;line=14" zhref="zotero://note/u/7DTXN3FC/?ignore=1&#x26;line=14" ztype="znotelink" class="internal-link">(01&#x2F;2008) MapReduce: simplified data processing on large clusters</a></p></blockquote><h2 id="📜结论"><a href="#📜结论" class="headerlink" title="📜结论"></a>📜结论</h2><p>MapReduce 编程模型一成功归因于几个原因。</p><p>首先，该模型易于使用，即使对于没有并行和分布式系统经验的程序员来说也是如此，因为它隐藏了并行化、容错、局部优化和负载平衡的细节。</p><p>其次，各种各样的问题可以很容易地表达为 MapReduce 计算。例如，MapReduce 用于为 Google 的生产网络搜索服务生成数据，用于排序、数据挖掘、机器学习和许多其他系统。</p><p>最后，我们开发了一种 MapReduce 实现，可以扩展到包含数千台机器的大型机器集群。该实现有效地利用了这些机器资源，因此适合用于解决 Google 遇到的许多大型计算问题。通过限制编程模型，我们可以轻松实现并行化和分布式计算，并使此类计算具有容错能力。</p><p>网络带宽是一种稀缺资源。因此，我们系统中的许多优化旨在减少通过网络发送的数据量：局部性优化允许我们从本地磁盘读取数据，并将中间数据的单个副本写入本地磁盘可以节省网络带宽。第三，冗余执行可用于减少缓慢机器的影响，并处理机器故障和数据丢失。</p><h2 id="💡创新点"><a href="#💡创新点" class="headerlink" title="💡创新点"></a>💡创新点</h2><blockquote><p>Tips: 本文提出了什么<u>新的科学问题</u>，提出了什么<u>新的研究思路</u>，或提出了什么<u>新的研究工具</u>？</p></blockquote><h2 id="🤔思考"><a href="#🤔思考" class="headerlink" title="🤔思考"></a>🤔思考</h2><blockquote><p>Tips: 自己的想法（按照‘125’原则，<u>1个思路，2个表格，5个句式</u>：思考这篇文章能为自己未来带来怎么样的思路，不管是试验方法还是研究思路；学习这篇文章画的比较好的图标；总结写的好的5个句式，尝试模仿运用）</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;01-x2F-2008-MapReduce-simplified-data-processing-on-large-clusters&quot;&gt;&lt;a href=&quot;#01-x2F-2008-MapReduce-simplified-data-processing-on-la</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VMware虚拟机与主机之间不能复制粘贴问题</title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/%E8%BF%90%E7%BB%B4/Vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E5%A4%8D%E5%88%B6%E3%80%81%E7%B2%98%E8%B4%B4%E5%86%85%E5%AE%B9%E3%80%81%E6%8B%96%E6%8B%BD%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%A6%E7%BB%86%E6%96%B9%E6%B3%95/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/%E8%BF%90%E7%BB%B4/Vmware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E5%A4%8D%E5%88%B6%E3%80%81%E7%B2%98%E8%B4%B4%E5%86%85%E5%AE%B9%E3%80%81%E6%8B%96%E6%8B%BD%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%A6%E7%BB%86%E6%96%B9%E6%B3%95/</id>
    <published>2023-10-30T14:04:29.044Z</published>
    <updated>2023-10-30T14:04:29.045Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h5 id="1-查看vmware-Tools是否安装"><a href="#1-查看vmware-Tools是否安装" class="headerlink" title="1. 查看vmware Tools是否安装"></a>1. 查看vmware Tools是否安装</h5><p>打开虚拟机 ，点击上方导航栏 ‘虚拟机’ 查看<code>VMware Tools</code>是否安装，如果未安装，安装即可<br><img src="https://img-blog.csdnimg.cn/02d18881609b4f31b1256ee1a944590b.png" alt="在这里插入图片描述"></p><h5 id="2-命令行解决"><a href="#2-命令行解决" class="headerlink" title="2. 命令行解决"></a>2. 命令行解决</h5><p>如果第一种方法不行，可以试试第二种方法</p><p>输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/bin</span><br></pre></td></tr></table></figure><p>切换到 <code>/usr/bin</code> 目录下</p><p><img src="https://img-blog.csdnimg.cn/28567ec76a8543f597995c97663598ed.png" alt="在这里插入图片描述"><br>输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmware-user</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/64c4ac1d23b643c78e993e11c727bce3.png" alt="在这里插入图片描述"></p><h5 id="3-重新安装组件"><a href="#3-重新安装组件" class="headerlink" title="3.重新安装组件"></a>3.重新安装组件</h5><p>如果前两种方法都不行，那就试试第三种<br>输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt autoremove open-vm-tools</span><br></pre></td></tr></table></figure><p>输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install open-vm-tools</span><br></pre></td></tr></table></figure><p>输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install open-vm-tools-desktop</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h5 id=&quot;1-查看vmware-Tools是否安装&quot;&gt;&lt;a href=&quot;#1-查看vmware-Tools是否安装&quot; class=&quot;headerlink&quot; title=&quot;1. 查看</summary>
      
    
    
    
    <category term="运维" scheme="http://cjx_0723.gitee.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="ubuntu" scheme="http://cjx_0723.gitee.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>VMware虚拟机联网</title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/%E8%BF%90%E7%BB%B4/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%81%94%E7%BD%91/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/%E8%BF%90%E7%BB%B4/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%81%94%E7%BD%91/</id>
    <published>2023-10-30T14:04:29.043Z</published>
    <updated>2023-10-30T14:04:29.043Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="1-虚拟机网络编辑器查看"><a href="#1-虚拟机网络编辑器查看" class="headerlink" title="1 虚拟机网络编辑器查看"></a>1 虚拟机网络编辑器查看</h1><h2 id="1-1-打开虚拟网络编辑器"><a href="#1-1-打开虚拟网络编辑器" class="headerlink" title="1.1 打开虚拟网络编辑器"></a>1.1 打开虚拟网络编辑器</h2><p>编辑 &gt;&gt; 虚拟网络编辑器</p><p><img src="https://img-blog.csdnimg.cn/20200201154504154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwOTQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-2-查看NAT和DHCP信息"><a href="#1-2-查看NAT和DHCP信息" class="headerlink" title="1.2 查看NAT和DHCP信息"></a>1.2 查看NAT和<a href="https://so.csdn.net/so/search?q=DHCP&spm=1001.2101.3001.7020">DHCP</a>信息</h2><p>部分用户需获取权限，若提示“需要具备管理器特权才能修改网络配置”，则点击“更改设置”并确认</p><p><img src="https://img-blog.csdnimg.cn/20200201154830625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwOTQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>选定NAT模式，然后点击NAT设置</p><p><img src="https://img-blog.csdnimg.cn/20200201154841273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwOTQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>可以查看到子网IP、掩码和网关，点击确定</p><p><img src="https://img-blog.csdnimg.cn/20200201154850456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwOTQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>回到上一步，再点击DHCP设置</p><p><img src="https://img-blog.csdnimg.cn/20200201154900147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwOTQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这里注意查看起始IP地址和结束IP地址，如本文中是：</p><p>192.168.61.128 192.168.61.254</p><p>之后我们需要在linux中设置静态IP，选择的IP地址就在上述区间内选择，此外还有广播地址，这个一般不重要。</p><h2 id="1-3-修改子网ip和子网掩码（非必须步骤）"><a href="#1-3-修改子网ip和子网掩码（非必须步骤）" class="headerlink" title="1.3 修改子网ip和子网掩码（非必须步骤）"></a>1.3 修改子网ip和子网掩码（非必须步骤）</h2><p>若不想使用默认设置， 可以修改子网ip和子网掩码，修改NAT设置和NHCP设置需要做同步变动</p><p><img src="https://img-blog.csdnimg.cn/20200201154912265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwOTQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200201154936524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwOTQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200201155036379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwOTQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="2-给服务器配置静态IP"><a href="#2-给服务器配置静态IP" class="headerlink" title="2 给服务器配置静态IP"></a>2 给服务器配置静态IP</h1><h2 id="2-1-右键，选择“Open-in-Terminal”打开命令窗口"><a href="#2-1-右键，选择“Open-in-Terminal”打开命令窗口" class="headerlink" title="2.1 右键，选择“Open in Terminal”打开命令窗口"></a>2.1 右键，选择“Open in Terminal”打开命令窗口</h2><p><img src="https://img-blog.csdnimg.cn/20200201155042333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwOTQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="2-2-进行网络配置"><a href="#2-2-进行网络配置" class="headerlink" title="2.2 进行网络配置"></a>2.2 进行网络配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/sysconfig/network-scripts/ #进入network-scripts</span><br><span class="line">ls    #查看当前目录下有哪些文件</span><br><span class="line">vi ifcfg-eno16777736    #编辑配置文件ifcfg-eno16777736，不同的操作系统，这个文件名有所不同，格式一样，用vi打开即可</span><br></pre></td></tr></table></figure><p>打开文件后，点击 “i”键，进入编辑状态</p><p><img src="https://img-blog.csdnimg.cn/20200201155213410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwOTQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>按照下面圈红的内容进行修改，IP地址的选择一定要在1.2查询的IP范围内，否则依然连不上网络。</p><p>这里为服务器配置的静态ip为192.168.61.254，敲黑板，后面会经常用到请务必记住！</p><p><img src="https://img-blog.csdnimg.cn/20200201155257833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwOTQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>按 ESC –Shift+Q –输入wq –Enter键，保存并退出。</p><h2 id="2-2-重启网络，配置生效"><a href="#2-2-重启网络，配置生效" class="headerlink" title="2.2 重启网络，配置生效"></a>2.2 重启网络，配置生效</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network.service</span><br></pre></td></tr></table></figure><p>Redhat6.x和Centos6.x的系统重启网络的命令为：service network restart<br>重启后，用命令“ip addr”即可查看到我们为服务器配置的ip</p><p><img src="https://img-blog.csdnimg.cn/20200201155352647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwOTQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="3-给服务器配置网络连接"><a href="#3-给服务器配置网络连接" class="headerlink" title="3 给服务器配置网络连接"></a>3 给服务器配置网络连接</h1><p>我们可以用“ping <a href="http://www.baidu.com”命令来测试服务器是否可以联网,做完上面的配置后一般还不能联网,还需要有以下配置/">www.baidu.com”命令来测试服务器是否可以联网，做完上面的配置后一般还不能联网，还需要有以下配置</a></p><h2 id="3-1-设置国内DNS服务器"><a href="#3-1-设置国内DNS服务器" class="headerlink" title="3.1 设置国内DNS服务器"></a>3.1 设置国内DNS服务器</h2><p>输入命令 “vi &#x2F;etc&#x2F;resolv.conf” ，添加 “nameserver 114.114.114.114”<br><img src="https://img-blog.csdnimg.cn/2020020115550337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwOTQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>依次按 ESC –Shift+Q –输入wq –Enter键，保存并退出。</p><h2 id="3-2-重启网络，配置生效"><a href="#3-2-重启网络，配置生效" class="headerlink" title="3.2 重启网络，配置生效"></a>3.2 重启网络，配置生效</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network.service</span><br></pre></td></tr></table></figure><p>重启后，即可用“ping <a href="http://www.baidu.com”命令来测试服务器是否可以联网/">www.baidu.com”命令来测试服务器是否可以联网</a><br><img src="https://img-blog.csdnimg.cn/20200201155515784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwOTQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-3-启动VM网络服务"><a href="#3-3-启动VM网络服务" class="headerlink" title="3.3 启动VM网络服务"></a>3.3 启动VM网络服务</h2><p>若做完上面的操作还不能联网，可前往计算机管理界面，检查VMnetDHCP和<a href="https://so.csdn.net/so/search?q=VMware&spm=1001.2101.3001.7020">VMware</a> NAT Service是否已启动，若未启动则手动启动</p><p><img src="https://img-blog.csdnimg.cn/20200201155537678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwOTQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>若VMnetDHCP和VMware NAT Service的属性里启动类型不是自动，可设置为自动并保存</p><p><img src="https://img-blog.csdnimg.cn/20200201155553870.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwOTQwOA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>网络配置完成后，我们就可以使用这个虚拟机了，不过直接在VMware里操作和上传文件不方便，我们推荐使用XShell远程连接服务器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;1-虚拟机网络编辑器查看&quot;&gt;&lt;a href=&quot;#1-虚拟机网络编辑器查看&quot; class=&quot;headerlink&quot; title=&quot;1 虚拟机网络编辑器查看&quot;&gt;&lt;/a&gt;1 虚</summary>
      
    
    
    
    <category term="运维" scheme="http://cjx_0723.gitee.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="ubuntu" scheme="http://cjx_0723.gitee.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>国科大测试课程</title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E5%9B%BD%E7%A7%91%E5%A4%A7%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E5%9B%BD%E7%A7%91%E5%A4%A7%E6%B5%8B%E8%AF%95%E8%AF%BE%E7%A8%8B/</id>
    <published>2023-10-30T14:04:29.042Z</published>
    <updated>2023-10-30T14:04:29.042Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="第五章-插桩技术"><a href="#第五章-插桩技术" class="headerlink" title="第五章 插桩技术"></a>第五章 插桩技术</h1><h2 id="5-1-程序插桩技术"><a href="#5-1-程序插桩技术" class="headerlink" title="5.1 程序插桩技术"></a>5.1 程序插桩技术</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>通过插入程序代码（探针），将源代码修改为代码P。</p><p>程序插桩技术的目的是实现自动化的插桩。</p><p>插桩分类：</p><ol><li>直接插桩：修改代码</li><li>简介插桩：使用解释器调试选项</li></ol><p>按插桩阶段分类：</p><ul><li>静态插桩：在编译阶段进行插桩</li><li>动态插桩：在运行阶段进行插桩</li></ul><p>按插桩粒度分类：</p><ul><li>指令级</li><li>基本块级</li><li>函数级</li><li>其他</li></ul><h3 id="常见的插桩工具"><a href="#常见的插桩工具" class="headerlink" title="常见的插桩工具"></a>常见的插桩工具</h3><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20231019141042231.png" alt="image-20231019141042231" style="zoom: 25%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;第五章-插桩技术&quot;&gt;&lt;a href=&quot;#第五章-插桩技术&quot; class=&quot;headerlink&quot; title=&quot;第五章 插桩技术&quot;&gt;&lt;/a&gt;第五章 插桩技术&lt;/h1&gt;&lt;h</summary>
      
    
    
    
    <category term="后端" scheme="http://cjx_0723.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="课堂学习" scheme="http://cjx_0723.gitee.io/tags/%E8%AF%BE%E5%A0%82%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="软件测试" scheme="http://cjx_0723.gitee.io/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/Python/python%E5%AE%9A%E4%BD%8DHTML%E5%85%83%E7%B4%A0/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/Python/python%E5%AE%9A%E4%BD%8DHTML%E5%85%83%E7%B4%A0/</id>
    <published>2023-10-30T14:04:29.041Z</published>
    <updated>2023-10-30T14:04:29.041Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">title: Matploblib</span><br><span class="line">date: 2023年9月13日23:10:52</span><br><span class="line">tags: </span><br><span class="line">    - Python</span><br><span class="line">    - Python工具包</span><br><span class="line">categories: 后端</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img: https://w.wallhaven.cc/full/d5/wallhaven-d582rg.png</span><br><span class="line">comments:</span><br><span class="line">cover: https://w.wallhaven.cc/full/d5/wallhaven-d582rg.png</span><br><span class="line">toc:</span><br><span class="line">toc_number:</span><br><span class="line">toc_style_simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright_author:</span><br><span class="line">copyright_author_href: </span><br><span class="line">copyright_url: </span><br><span class="line">copyright_info: </span><br><span class="line">mathjax: </span><br><span class="line">katex:</span><br><span class="line">aplayer:</span><br><span class="line">highlight_shrink:</span><br><span class="line">aside:</span><br></pre></td></tr></table></figure><meta name="referrer" content="no-referrer"/><h2 id="一、安装依赖库"><a href="#一、安装依赖库" class="headerlink" title="一、安装依赖库"></a>一、安装依赖库</h2><p>在开始之前，我们需要先安装 Selenium 和 BeautifulSoup 这两个库。可以使用以下命令来安装它们：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><h2 id="二-声明浏览器对象"><a href="#二-声明浏览器对象" class="headerlink" title="二. 声明浏览器对象"></a>二. 声明浏览器对象</h2><ul><li>Selenium 支持非常多的浏览器，如 Chrome、Firefox、Edge 等，还有 Android、BlackBerry 等手机端的浏览器。另外，也支持无界面浏览器 PhantomJS。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser = webdriver.Edge()</span><br><span class="line">browser = webdriver.PhantomJS()</span><br><span class="line">browser = webdriver.Safari()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这样就完成了浏览器对象的初始化并将其赋值为 browser 对象。接下来，我们要做的就是调用 browser 对象，让其执行各个动作以模拟浏览器操作。</strong></p><h2 id="三-基本使用"><a href="#三-基本使用" class="headerlink" title="三. 基本使用"></a>三. 基本使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="comment"># 打开指定（chrome）浏览器</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 指定加载页面</span></span><br><span class="line">browser.get(<span class="string">&quot;http://www.baidu.com/&quot;</span>)</span><br><span class="line"><span class="comment"># 通过name属性选择文本框元素，并设置内容</span></span><br><span class="line">browser.find_element(By.NAME,<span class="string">&#x27;wd&#x27;</span>).send_keys(<span class="string">&quot;selenium&quot;</span>)</span><br><span class="line"><span class="comment"># 通过通过ID属性获取“百度一下”按钮，并执行点击操作</span></span><br><span class="line">browser.find_element(By.ID,<span class="string">&quot;su&quot;</span>).click()</span><br><span class="line"><span class="comment"># 提取页面</span></span><br><span class="line"><span class="built_in">print</span>(browser.page_source.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 提取cookie</span></span><br><span class="line"><span class="built_in">print</span>(browser.get_cookies())</span><br><span class="line"><span class="comment"># 获取当前页面截屏</span></span><br><span class="line"><span class="built_in">print</span>(browser.get_screenshot_as_file(<span class="string">&#x27;123.png&#x27;</span>))</span><br><span class="line"><span class="comment"># 提取当前请求地址</span></span><br><span class="line"><span class="built_in">print</span>(browser.current_url)</span><br><span class="line"><span class="comment"># 设置五秒后执行下一步</span></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 关闭浏览器</span></span><br><span class="line">browser.quit()</span><br></pre></td></tr></table></figure><h2 id="四-初始化配置"><a href="#四-初始化配置" class="headerlink" title="四. 初始化配置"></a>四. 初始化配置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁止图片</span></span><br><span class="line">prefs = &#123;<span class="string">&quot;profile.managed_default_content_settings.images&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">options.add_experimental_option(<span class="string">&quot;prefs&quot;</span>, prefs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 无头模式 在后台运行</span></span><br><span class="line"><span class="comment"># options.add_argument(&quot;-headless&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过设置user-agent</span></span><br><span class="line">user_ag=<span class="string">&#x27;MQQBrowser/26 Mozilla/5.0 (Linux; U; Android 2.3.7; zh-cn; MB200 Build/GRJ22;CyanogenMod-7) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&#x27;</span></span><br><span class="line">options.add_argument(<span class="string">&#x27;user-agent=%s&#x27;</span>% user_ag)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#隐藏&quot;Chrome正在受到自动软件的控制&quot;</span></span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;useAutomationExtension&#x27;</span>, <span class="literal">False</span>) <span class="comment"># 去掉开发者警告</span></span><br><span class="line">options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拓展使用</span></span><br><span class="line">extension_path = <span class="string">r&#x27;E:\BaiduNetdiskDownload\Chrome插件\iguge_2011\igg_2.0.11.crx&#x27;</span></span><br><span class="line">options.add_extension(extension_path)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置代理</span></span><br><span class="line"><span class="comment"># options.add_argument(&quot;--proxy-server=http://58.20.184.187:9091&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化配置</span></span><br><span class="line">browser = webdriver.Chrome(chrome_options=options)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将浏览器最大化显示</span></span><br><span class="line">browser.maximize_window()</span><br><span class="line"><span class="comment"># 设置宽高</span></span><br><span class="line">browser.set_window_size(<span class="number">480</span>, <span class="number">800</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过js新打开一个窗口</span></span><br><span class="line">browser.execute_script(<span class="string">&#x27;window.open(&quot;http://httpbin.org/ip&quot;);&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="五-查找节点"><a href="#五-查找节点" class="headerlink" title="五. 查找节点"></a>五. 查找节点</h2><ul><li>Selenium 可以驱动浏览器完成各种操作，比如填充表单、模拟点击等。比如，我们想要完成向某个输入框输入文字的操作或者抓取数据，而 Selenium 提供了一系列查找节点的方法，我们可以用这些方法来获取想要的节点，以便下一步执行一些动作或者提取信息。</li><li>新版selenium提供了2种方法<ul><li>find_element()系列：用于定位单个的页面元素。</li><li>find_elements()系列：用于定位一组页面元素，获取到的是一组列表。</li></ul></li></ul><h3 id="5-1-单个节点"><a href="#5-1-单个节点" class="headerlink" title="5.1 单个节点"></a>5.1 单个节点</h3><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys  <span class="comment"># 模拟键盘操作</span></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="comment"># 启动并打开指定页面</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="comment"># 通过name属性选择文本框元素，并设置内容</span></span><br><span class="line">s = browser.find_element(By.NAME,<span class="string">&#x27;wd&#x27;</span>)</span><br><span class="line">s.send_keys(<span class="string">&#x27;衣服&#x27;</span>)</span><br><span class="line">s.send_keys(Keys.ENTER)   <span class="comment"># 回车 确定的意思</span></span><br></pre></td></tr></table></figure><p><strong>各种节点提取演示</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">browser.get(<span class="string">&quot;http://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="comment"># ID选择器定位</span></span><br><span class="line">input_text = browser.find_element(By.ID, <span class="string">&quot;kw&quot;</span>)</span><br><span class="line">input_text.send_keys(<span class="string">&quot;selenium&quot;</span>)</span><br><span class="line"><span class="comment"># CSS 选择器定位</span></span><br><span class="line">s =browser.find_element(By.CSS_SELECTOR,<span class="string">&#x27;input.s_ipt&#x27;</span>)</span><br><span class="line">s.send_keys(<span class="string">&#x27;衣服&#x27;</span>)</span><br><span class="line"><span class="comment"># xpath 选择器定位</span></span><br><span class="line">s = browser.find_element(By.XPATH,<span class="string">&#x27;//input[@id=&quot;kw&quot;]&#x27;</span>)</span><br><span class="line">s.send_keys(<span class="string">&#x27;衣服&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="5-2-多个节点"><a href="#5-2-多个节点" class="headerlink" title="5.2 多个节点"></a>5.2 多个节点</h3><ul><li>如果要查找所有满足条件的节点，需要用 find_elements() 这样的方法。注意，在这个方法的名称中，element 多了一个 s，注意区分。</li></ul><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.icswb.com/channel-list-channel-161.html&#x27;</span>)</span><br><span class="line">lis = browser.find_elements(By.CSS_SELECTOR,<span class="string">&#x27;#NewsListContainer li&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(lis)</span><br></pre></td></tr></table></figure><p><strong>补充解释：</strong><br>可以看到，得到的内容变成了列表类型，列表中的每个节点都是 WebElement 类型。</p><p>下面是常用的查找方法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># selenium提供了8种网页元素定位的方式</span></span><br><span class="line"><span class="comment"># 根据ID定位，加s是寻找多节点,其他方式类似,多节点的话，需要使用for循环来遍历每一个节点</span></span><br><span class="line">find_element_by_id()</span><br><span class="line">find_elements_by_id()</span><br><span class="line"><span class="comment"># 根据class定位</span></span><br><span class="line">find_elements_by_class_name()</span><br><span class="line"><span class="comment"># 根据标签名定位</span></span><br><span class="line">find_elements_by_tag_name()</span><br><span class="line"><span class="comment"># 根据CSS选择器定位</span></span><br><span class="line">find_element_by_css_selector()</span><br><span class="line"><span class="comment"># 根据name定位</span></span><br><span class="line">find_elements_by_name()</span><br><span class="line"><span class="comment"># 根据XPath定位</span></span><br><span class="line">find_element_by_xpath()</span><br><span class="line"><span class="comment"># 根据链接文本定位</span></span><br><span class="line">find_element_by_link_text()</span><br><span class="line"><span class="comment"># 根据部分链接文本定位</span></span><br><span class="line">find_element_by_partial_link_text()</span><br></pre></td></tr></table></figure><p>获取元素后可查看元素属性：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get_attribute  获取属性值</span></span><br><span class="line"><span class="comment"># text  获取文本值</span></span><br><span class="line"><span class="comment"># id  获取节点id</span></span><br><span class="line"><span class="comment"># location  获取节点在页面中的相对位置</span></span><br><span class="line"><span class="comment"># tag_name  获取标签名称</span></span><br><span class="line"><span class="comment"># size  获取节点大小(宽和高)</span></span><br></pre></td></tr></table></figure><h2 id="六-节点交互"><a href="#六-节点交互" class="headerlink" title="六. 节点交互"></a>六. 节点交互</h2><ul><li>Selenium 可以驱动浏览器来执行一些操作，也就是说可以让浏览器模拟执行一些动作。比较常见的用法有：输入文字时用 send_keys 方法，清空文字时用 clear 方法，点击按钮时用 click 方法。</li></ul><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="built_in">input</span> = browser.find_element(By.ID,<span class="string">&#x27;kw&#x27;</span>)</span><br><span class="line"><span class="built_in">input</span>.send_keys(<span class="string">&#x27;iPhone&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">input</span>.clear()</span><br><span class="line"><span class="built_in">input</span>.send_keys(<span class="string">&#x27;iPad&#x27;</span>)</span><br><span class="line">button = browser.find_element(By.ID,<span class="string">&#x27;su&#x27;</span>)</span><br><span class="line">button.click()</span><br></pre></td></tr></table></figure><p><strong>通过上面的方法，我们就完成了一些常见节点的动作操作，更多的操作可以参见官方文档的交互动作介绍：<a href="http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.remote.webelement%E3%80%82">http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.remote.webelement。</a></strong></p><h2 id="七-切换IFrame"><a href="#七-切换IFrame" class="headerlink" title="七. 切换IFrame"></a>七. 切换<a href="https://so.csdn.net/so/search?q=IFrame&spm=1001.2101.3001.7020">IFrame</a></h2><p>网页中有一种节点叫作 iframe，也就是子 Frame，相当于页面的子页面，它的结构和外部网页的结构完全一致。</p><p><strong>Selenium 打开页面后，它默认是在父级 Frame 里面操作，而此时如果页面中还有子 Frame，它是不能获取到子 Frame 里面的节点的。这时就需要使用 switch_to.frame() 方法来切换 Frame</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">browser.get(<span class="string">&#x27;https://www.douban.com/&#x27;</span>)</span><br><span class="line">login_iframe = browser.find_element(By.XPATH,<span class="string">&#x27;//div[@class=&quot;login&quot;]/iframe&#x27;</span>)</span><br><span class="line">browser.switch_to.frame(login_iframe)</span><br><span class="line">browser.find_element(By.CLASS_NAME,<span class="string">&#x27;account-tab-account&#x27;</span>).click()</span><br><span class="line">browser.find_element(By.ID,<span class="string">&#x27;username&#x27;</span>).send_keys(<span class="string">&#x27;123123123&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：对于iframe 网页 一定要切换进去才能够定位</p><p>如果需要退回到最初的父Iframe，则需要使用<code>driver.switch_to.default_content()</code></p><h2 id="八-动作链"><a href="#八-动作链" class="headerlink" title="八. 动作链"></a>八. 动作链</h2><ul><li>drag_and_drop()方法</li><li>在上面的实例中，一些交互动作都是针对某个节点执行的。比如，对于输入框，我们就调用它的输入文字和清空文字方法；对于按钮，就调用它的点击方法。其实，还有另外一些操作，它们没有特定的执行对象，比如鼠标拖曳、键盘按键等，这些动作用另一种方式来执行，那就是动作链。</li><li>比如，现在实现一个节点的拖曳操作，将某个节点从一处拖曳到另外一处</li></ul><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">&#x27;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#x27;</span></span><br><span class="line">browser.get(url)</span><br><span class="line">log = browser.find_element(By.XPATH, <span class="string">&#x27;//div[@id=&quot;iframewrapper&quot;]/iframe&#x27;</span>)</span><br><span class="line">browser.switch_to.frame(log)</span><br><span class="line">source = browser.find_element(By.CSS_SELECTOR,<span class="string">&#x27;#draggable&#x27;</span>)</span><br><span class="line">target = browser.find_element(By.CSS_SELECTOR,<span class="string">&#x27;#droppable&#x27;</span>)</span><br><span class="line">actions = ActionChains(browser)</span><br><span class="line">actions.drag_and_drop(source, target)</span><br><span class="line">actions.perform()</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure><ul><li>drag_and_drop()方法涉及到参数传递，一个是要拖拽元素的起点，一个是要拖拽元素的终点</li><li>首先，打开网页中的一个拖曳实例，然后依次选中要拖曳的节点和拖曳到的目标节点，接着声明 <a href="https://so.csdn.net/so/search?q=ActionChains&spm=1001.2101.3001.7020">ActionChains</a> 对象并将其赋值为 actions 变量，然后通过调用 actions 变量的 drag_and_drop() 方法，再调用 perform() 方法执行动作，此时就完成了拖曳操作</li></ul><h2 id="九-页面滚动"><a href="#九-页面滚动" class="headerlink" title="九. 页面滚动"></a>九. 页面滚动</h2><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浏览器滚动到底部 10000位置</span></span><br><span class="line">document.documentElement.scrollTop=<span class="number">10000</span></span><br><span class="line"><span class="comment"># 滚动到顶部</span></span><br><span class="line">document.documentElement.scrollTop=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动到页面最底部  </span></span><br><span class="line">browser.execute_script(<span class="string">&quot;window.scrollTo(0, document.body.scrollHeight)&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 移动到指定的坐标(相对当前的坐标移动)</span></span><br><span class="line">driver.execute_script(<span class="string">&quot;window.scrollBy(0, 700)&quot;</span>)</span><br><span class="line"><span class="comment"># 结合上面的scrollBy语句，相当于移动到700+800=1600像素位置  </span></span><br><span class="line">driver.execute_script(<span class="string">&quot;window.scrollBy(0, 800)&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 移动到窗口绝对位置坐标，如下移动到纵坐标1600像素位置  </span></span><br><span class="line">driver.execute_script(<span class="string">&quot;window.scrollTo(0, 1600)&quot;</span>)</span><br><span class="line"><span class="comment"># 结合上面的scrollTo语句，仍然移动到纵坐标1200像素位置  </span></span><br><span class="line">driver.execute_script(<span class="string">&quot;window.scrollTo(0, 1200)&quot;</span>)</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><h3 id="9-1-页面滚动案例"><a href="#9-1-页面滚动案例" class="headerlink" title="9.1 页面滚动案例"></a>9.1 页面滚动案例</h3><ul><li>对于某些操作，Selenium API 并没有提供。比如，下拉进度条，它可以直接模拟运行 JavaScript，此时使用 execute_script() 方法即可实现</li></ul><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># document.body.scrollHeight 获取页面高度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://36kr.com/&#x27;</span>)</span><br><span class="line"><span class="comment"># scrollTo  不叠加 200 200    scrollBy 叠加  200 300  500操作</span></span><br><span class="line"><span class="comment"># 慢慢的下拉</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">9</span>):</span><br><span class="line">    time.sleep(random.randint(<span class="number">100</span>, <span class="number">300</span>) / <span class="number">1000</span>)</span><br><span class="line">    browser.execute_script(<span class="string">&#x27;window.scrollTo(0,&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(i * <span class="number">700</span>)) <span class="comment"># scrollTo 不叠加 700 1400 2100</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><ul><li>这里就利用 execute_script() 方法将进度条下拉到最底部<br>所以说有了这个方法，基本上 API 没有提供的所有功能都可以用执行 JavaScript 的方式来实现了。</li></ul><h2 id="十-获取节点信息"><a href="#十-获取节点信息" class="headerlink" title="十. 获取节点信息"></a>十. 获取节点信息</h2><h3 id="获取标签属性"><a href="#获取标签属性" class="headerlink" title="获取标签属性"></a>获取标签属性</h3><ul><li>我们可以使用 get_attribute() 方法来获取节点的属性，但是其前提是先选中这个节点</li></ul><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">url = <span class="string">&#x27;https://pic.netbian.com/4kmeinv/index.html&#x27;</span></span><br><span class="line">browser.get(url)</span><br><span class="line">src = browser.find_elements(By.XPATH,<span class="string">&#x27;//ul[@class=&quot;clearfix&quot;]/li/a/img&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> src:</span><br><span class="line">    url = i.get_attribute(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(url)</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>通过 get_attribute() 方法，然后传入想要获取的属性名，就可以得到它的值</p><h2 id="十一-延时等待"><a href="#十一-延时等待" class="headerlink" title="十一. 延时等待"></a>十一. 延时等待</h2><ul><li>在 Selenium 中，get() 方法会在网页框架加载结束后结束执行，此时如果获取 page_source，可能并不是浏览器完全加载完成的页面，如果某些页面有额外的 Ajax 请求，我们在网页源代码中也不一定能成功获取到。所以，这里需要延时等待一定时间，确保节点已经加载出来</li></ul><p><strong>使用方法</strong><br>指定要查找的节点，然后指定一个最长等待时间。如果在规定时间内加载出来了这个节点，就返回查找的节点；如果到了规定时间依然没有加载出该节点，则抛出超时异常。</p><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line">wait = WebDriverWait(browser, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">input</span> = wait.until(EC.presence_of_element_located((By.ID, <span class="string">&#x27;kw&#x27;</span>)))</span><br><span class="line">button = wait.until(EC.element_to_be_clickable((By.ID, <span class="string">&#x27;su&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>, button)</span><br></pre></td></tr></table></figure><p><strong>补充解释</strong><br>这样可以做到的效果就是，在 10 秒内如果 ID 为 q 的节点（即搜索框）成功加载出来，就返回该节点；如果超过 10 秒还没有加载出来，就抛出异常。</p><p>对于按钮，可以更改一下等待条件，比如改为 element_to_be_clickable，也就是可点击，所以查找按钮时查找 CSS 选择器为.btn-search 的按钮，如果 10 秒内它是可点击的，也就是成功加载出来了，就返回这个按钮节点；如果超过 10 秒还不可点击，也就是没有加载出来，就抛出异常。</p><ul><li>等待条件及其含义</li></ul><table><thead><tr><th>等待条件</th><th>含义</th></tr></thead><tbody><tr><td>title_is</td><td>标题是某内容</td></tr><tr><td>title_contains</td><td>标题包含某内容</td></tr><tr><td>presence_of_element_located</td><td>节点加载出，传入定位元组，如 (By.ID, ‘p’)</td></tr><tr><td>visibility_of_element_located</td><td>节点可见，传入定位元组</td></tr><tr><td>visibility_of</td><td>可见，传入节点对象</td></tr><tr><td>presence_of_all_elements_located</td><td>所有节点加载出</td></tr><tr><td>text_to_be_present_in_element</td><td>某个节点文本包含某文字</td></tr><tr><td>text_to_be_present_in_element_value</td><td>某个节点值包含某文字</td></tr><tr><td>frame_to_be_available_and_switch_to_it frame</td><td>加载并切换</td></tr><tr><td>invisibility_of_element_located</td><td>节点不可见</td></tr><tr><td>element_to_be_clickable</td><td>节点可点击</td></tr><tr><td>staleness_of</td><td>判断一个节点是否仍在 DOM，可判断页面是否已经刷新</td></tr><tr><td>element_to_be_selected</td><td>节点可选择，传节点对象</td></tr><tr><td>element_located_to_be_selected</td><td>节点可选择，传入定位元组</td></tr><tr><td>element_selection_state_to_be</td><td>传入节点对象以及状态，相等返回 True，否则返回 False</td></tr><tr><td>element_located_selection_state_to_be</td><td>传入定位元组以及状态，相等返回 True，否则返回 False</td></tr><tr><td>alert_is_present</td><td>是否出现 Alert</td></tr></tbody></table><h2 id="十二-选项卡管理"><a href="#十二-选项卡管理" class="headerlink" title="十二. 选项卡管理"></a>十二. 选项卡管理</h2><ul><li>在访问网页的时候，会开启一个个选项卡。在 Selenium 中，我们也可以对选项卡进行操作</li></ul><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">browser.execute_script(<span class="string">&#x27;window.open()&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.window_handles)</span><br><span class="line">browser.switch_to.window(browser.window_handles[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">browser.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">browser.switch_to.window(browser.window_handles[<span class="number">0</span>])</span><br><span class="line">browser.get(<span class="string">&#x27;https://pic.netbian.com&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>补充解释</strong><br>控制台输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;CDwindow-4f58e3a7-7167-4587-bedf-9cd8c867f435&#x27;</span><br><span class="line">, &#x27;CDwindow-6e05f076-6d77-453a-a36c-32baacc447df&#x27;]</span><br></pre></td></tr></table></figure><ul><li>首先访问了百度，然后调用了 execute_script() 方法，这里传入 window.open() 这个 JavaScript 语句新开启一个选项卡。接下来，我们想切换到该选项卡。这里调用 window_handles 属性获取当前开启的所有选项卡，返回的是选项卡的代号列表。要想切换选项卡，只需要调用 switch_to_window() 方法即可，其中参数是选项卡的代号。这里我们将第二个选项卡代号传入，即跳转到第二个选项卡，接下来在第二个选项卡下打开一个新页面，然后切换回第一个选项卡重新调用 switch_to_window() 方法，再执行其他操作即可。</li></ul><h2 id="十三-异常处理"><a href="#十三-异常处理" class="headerlink" title="十三. 异常处理"></a>十三. 异常处理</h2><ul><li>在使用 Selenium 的过程中，难免会遇到一些异常，例如超时、节点未找到等错误，一旦出现此类错误，程序便不会继续运行。这里我们可以使用 try except 语句来捕获各种异常。</li></ul><p><strong>代码实现</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> TimeoutException, NoSuchElementException</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> TimeoutException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Time Out&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser.find_element(By.ID,<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;No Element&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure><p><strong>补充解释</strong><br>这里我们使用 try except 来捕获各类异常。比如，我们对 find_element_by_id() 查找节点的方法捕获 NoSuchElementException 异常，这样一旦出现这样的错误，就进行异常处理，程序也不会中断了。</p><p>控制台的输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No Element</span><br></pre></td></tr></table></figure><h2 id="十四-绕过检测"><a href="#十四-绕过检测" class="headerlink" title="十四. 绕过检测"></a>十四. 绕过检测</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无处理</span></span><br><span class="line">browser.get(<span class="string">&#x27;https://bot.sannysoft.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置屏蔽</span></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(<span class="string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>)</span><br><span class="line">browsers = webdriver.Chrome(chrome_options=options)</span><br><span class="line">browsers.get(<span class="string">&#x27;https://bot.sannysoft.com/&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="十五-selenium实例"><a href="#十五-selenium实例" class="headerlink" title="十五. selenium实例"></a>十五. selenium实例</h2><ul><li>采集某品会商品</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WeiPin</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.client = MongoClient(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">27017</span>)</span><br><span class="line">        self.col = self.client[<span class="string">&#x27;spiders&#x27;</span>][<span class="string">&#x27;weipinhui&#x27;</span>]</span><br><span class="line">        options = webdriver.ChromeOptions()</span><br><span class="line">        options.add_experimental_option(<span class="string">&#x27;useAutomationExtension&#x27;</span>, <span class="literal">False</span>)  <span class="comment"># 去掉开发者警告</span></span><br><span class="line">        options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line">        <span class="comment"># 不加载图片</span></span><br><span class="line">        prefs = &#123;<span class="string">&quot;profile.managed_default_content_settings.images&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">        options.add_experimental_option(<span class="string">&quot;prefs&quot;</span>, prefs)</span><br><span class="line">        self.browser = webdriver.Chrome(options=options)</span><br><span class="line">        self.browser.maximize_window()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">base</span>(<span class="params">self</span>):</span><br><span class="line">        self.browser.get(<span class="string">&#x27;https://www.vip.com/&#x27;</span>)</span><br><span class="line">        wait = WebDriverWait(self.browser, <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">input</span> = wait.until(EC.element_to_be_clickable((By.XPATH, <span class="string">&#x27;//input[@class=&quot;c-search-input  J-search-input&quot;]&#x27;</span>)))</span><br><span class="line">        button = wait.until(</span><br><span class="line">            EC.element_to_be_clickable((By.XPATH, <span class="string">&#x27;//a[@class=&quot;c-search-button  J-search-button  J_fake_a&quot;]&#x27;</span>)))</span><br><span class="line">        <span class="built_in">input</span>.send_keys(<span class="string">&#x27;口红&#x27;</span>)</span><br><span class="line">        time.sleep(random.randint(<span class="number">3000</span>, <span class="number">3400</span>) / <span class="number">1000</span>)</span><br><span class="line">        button.click()</span><br><span class="line">        time.sleep(random.randint(<span class="number">1000</span>, <span class="number">1400</span>) / <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spider</span>(<span class="params">self</span>):</span><br><span class="line">        self.drop_down()</span><br><span class="line">        <span class="comment"># print(self.browser.page_source)</span></span><br><span class="line">        node_list = self.browser.find_elements(By.XPATH,</span><br><span class="line">                                               <span class="string">&#x27;//section[@id=&quot;J_searchCatList&quot;]/div[@class=&quot;c-goods-item  J-goods-item c-goods-item--auto-width&quot;]&#x27;</span>)</span><br><span class="line">        <span class="comment"># print(node_list)</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> node_list:</span><br><span class="line">            price = node.find_element(By.XPATH,</span><br><span class="line">                                      <span class="string">&#x27;.//div[@class=&quot;c-goods-item__sale-price J-goods-item__sale-price&quot;]&#x27;</span>).text</span><br><span class="line">            title = node.find_element(By.XPATH, <span class="string">&#x27;.//div[2]/div[2]&#x27;</span>).text</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                discount = node.find_element(By.XPATH,</span><br><span class="line">                                             <span class="string">&#x27;.//div[@class=&quot;c-goods-item__main-price     J-goods-item__main-price&quot;]/div[@class=&quot;c-goods-item__discount  J-goods-item__discount&quot;]&#x27;</span>).text</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;数据为空&#x27;</span>)</span><br><span class="line">                discount = <span class="string">&#x27;空&#x27;</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                market_price = node.find_element(By.XPATH,</span><br><span class="line">                                                 <span class="string">&#x27;.//div[@class=&quot;c-goods-item__market-price  J-goods-item__market-price&quot;]&#x27;</span>).text</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;数据为空&#x27;</span>)</span><br><span class="line">                market_price = <span class="string">&#x27;空&#x27;</span></span><br><span class="line"></span><br><span class="line">            item = &#123;</span><br><span class="line">                <span class="string">&#x27;title&#x27;</span>: title,</span><br><span class="line">                <span class="string">&#x27;price&#x27;</span>: price,</span><br><span class="line">                <span class="string">&#x27;discount&#x27;</span>: discount,</span><br><span class="line">                <span class="string">&#x27;market_price&#x27;</span>: market_price</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(item)</span><br><span class="line">            self.save_mongo(item)</span><br><span class="line">        self.page_next()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_mongo</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(item, <span class="built_in">dict</span>):</span><br><span class="line">            self.col.insert_one(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">page_next</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            next_button = self.browser.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;J_nextPage_link&quot;]&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> next_button:</span><br><span class="line">                next_button.click()</span><br><span class="line">                self.spider()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.browser.close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            self.browser.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drop_down</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            js = <span class="string">f&quot;document.documentElement.scrollTop = <span class="subst">&#123;x * <span class="number">1000</span>&#125;</span>&quot;</span></span><br><span class="line">            self.browser.execute_script(js)</span><br><span class="line">            time.sleep(random.randint(<span class="number">500</span>, <span class="number">800</span>) / <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    weipin = WeiPin()</span><br><span class="line">    weipin.base()</span><br><span class="line">    weipin.spider()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Matploblib</title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/Python/Python%E5%B7%A5%E5%85%B7%E5%8C%85/Matploblib/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/Python/Python%E5%B7%A5%E5%85%B7%E5%8C%85/Matploblib/</id>
    <published>2023-10-30T14:04:29.038Z</published>
    <updated>2023-10-30T14:04:29.039Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="一、初识Matploblib"><a href="#一、初识Matploblib" class="headerlink" title="一、初识Matploblib"></a>一、初识Matploblib</h2><p>Matplotlib是Python中的绘图库，类似于MATLAB，可以用来绘制各种静态，动态，交互式的图表。</p><h3 id="1-1-Figure"><a href="#1-1-Figure" class="headerlink" title="1.1 Figure"></a>1.1 Figure</h3><p> 在绘图之前，我们需要一个Figure对象，可以理解成我们需要一张画布才能开始绘图。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig = plt.figure()</span><br></pre></td></tr></table></figure><h3 id="1-2-Axes"><a href="#1-2-Axes" class="headerlink" title="1.2 Axes"></a>1.2 <a href="https://so.csdn.net/so/search?q=Axes&spm=1001.2101.3001.7020">Axes</a></h3><p>拥有Figure对象之后，我们还需要创建绘图区域，添加Axes。在绘制<a href="https://so.csdn.net/so/search?q=%E5%AD%90%E5%9B%BE&spm=1001.2101.3001.7020">子图</a>过程中，对于每一个子图可能有不同设置，而 Axes 可以直接实现对于单个子图的设定。figure、axes和axis（轴）的区别如下图所示。</p><img src="https://img-blog.csdnimg.cn/20210609155829318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDQ4NzU2,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 67%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.<span class="built_in">set</span>(xlim=[<span class="number">0.5</span>, <span class="number">4.5</span>], ylim=[-<span class="number">2</span>, <span class="number">8</span>], title=<span class="string">&#x27;An Example Axes&#x27;</span>,</span><br><span class="line">       ylabel=<span class="string">&#x27;Y-Axis&#x27;</span>, xlabel=<span class="string">&#x27;X-Axis&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>以上的代码，在一幅图上添加了一个Axes，然后设置了这个Axes的X轴以及Y轴的取值范围（这些设置并不是强制的，后面会再谈到关于这些设置），效果如下图：</p><img src="https://img-blog.csdnimg.cn/8fe8d5b843ba4ea3b98d10ab2956dadc.png" alt="img" style="zoom: 50%;" /><p><code>add_subplot(nrows, ncols, index, **kwargs)</code></p><p>说明：将整个Figure区域划分为$nrows * col$的网格，在索引号为index处创建一个Axes</p><p>我们要创建一个2*2的网格，参数和索引如下图所示：</p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzUwZDgzYmExMWM5MTRlZTk5YjdiNWZhODQ5OTM3ODc2?x-oss-process=image/format,png" alt="Matplotlib学习手册A006_Figure的add_subplot()方法" style="zoom:67%;" /><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">221</span>)</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">222</span>)</span><br><span class="line">ax3 = fig.add_subplot(<span class="number">224</span>)</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/52a3605f7c23415ebe078e8d9e60b892.png" alt="img" style="zoom: 67%;" /><p>可以发现我们上面添加 Axes 似乎有点弱鸡，所以提供了下面的<code>subplots()</code>方式一次性生成所有 Axes：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">2</span>)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">0</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Upper Left&#x27;</span>)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">1</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Upper Right&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">0</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Lower Left&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">1</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Lower Right&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一种写法</span></span><br><span class="line">fig, (ax1,ax2,ax3,ax4) = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">2</span>)</span><br><span class="line">ax1.<span class="built_in">set</span>(title=<span class="string">&#x27;Upper Left&#x27;</span>)</span><br><span class="line">ax2.<span class="built_in">set</span>(title=<span class="string">&#x27;Upper Right&#x27;</span>)</span><br><span class="line">ax3.<span class="built_in">set</span>(title=<span class="string">&#x27;Lower Left&#x27;</span>)</span><br><span class="line">ax4.<span class="built_in">set</span>(title=<span class="string">&#x27;Lower Right&#x27;</span>)</span><br></pre></td></tr></table></figure><p>fig 还是我们熟悉的画板， axes 成了我们常用二维数组的形式访问，这在循环绘图时，额外好用。</p><h3 id="1-3-设置画布大小"><a href="#1-3-设置画布大小" class="headerlink" title="1.3 设置画布大小"></a>1.3 设置画布大小</h3><p>在使用matplotlib作图时，会遇到图片显示不全或者图片大小不是我们想要的，这个时候就需要调整画布大小。下例左图为500<em>500像素，右图为1000</em>1000像素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 500 x 500 像素（先宽度 后高度）</span></span><br><span class="line"><span class="comment"># 注意这里的宽度和高度的单位是英寸，1英寸=100像素</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="1-4-plot-绘制线条"><a href="#1-4-plot-绘制线条" class="headerlink" title="1.4 plot()绘制线条"></a>1.4 plot()绘制线条</h3><h4 id="常用的调用方式"><a href="#常用的调用方式" class="headerlink" title="常用的调用方式"></a>常用的调用方式</h4><p><code>plt.plot()</code>函数是我们平时绘图的时候最常用的另外一个函数之一，先放一下<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot">官网上的介绍</a>，该函数的关键字参数不多，其中*<strong>*kwargs</strong>是将可变的关键字参数字典传给函数实参，该字典长度可为任意长度<a href="https://zhuanlan.zhihu.com/p/50804195">*args和**kwargs介绍</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.plot(*args, scalex=<span class="literal">True</span>, scaley=<span class="literal">True</span>, data=<span class="literal">None</span>, **kwargs)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用格式说明</span></span><br><span class="line">plot([x], y, [fmt], *, data=<span class="literal">None</span>, **kwargs)</span><br><span class="line">plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</span><br></pre></td></tr></table></figure><p>最简洁的调用方式是直接传入一个数组对象y，其他参数都是可选的。如下：先创建一个服从正态分布的数据，共100个点，直接传入plot()。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.normal(<span class="number">5</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.plot(data)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210102121704939.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZWZhbmpvZQ==,size_16,color_FFFFFF,t_70" alt="img"></p><p>当只传入绘制的数据列表时，<strong>默认数据作为Y轴值，而X轴的坐标则是由数据的下标组成的，共100个点对应X轴的100个坐标。</strong><code>plt.plot()</code>肯定也支持自定义X轴坐标，只需要调用的时候传入两个大小相同的数组即可，X坐标在前，Y坐标在后。<code>plt.plot()</code>默认是将每个点通过直线连接起来，所以当点比较少的时候就呈现下左图，当点较多时就呈现下右图，看似是曲线。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(-np.pi, np.pi, <span class="number">10</span>)   <span class="comment">#x = np.linspace(-np.pi, np.pi, 100)</span></span><br><span class="line">y = np.sin(x)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210102122258995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZWZhbmpvZQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" /><img src="https://img-blog.csdnimg.cn/20210102122312142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZWZhbmpvZQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" /><h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>格式fmt : 字符串str, [可选optional]，定义线条的颜色和样式的操作</p><p>如“ro”就是红色的圆圈，更多组合参见<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot">官网列表</a>，</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(-np.pi, np.pi, <span class="number">50</span>)   <span class="comment">#x = np.linspace(-np.pi, np.pi, 100)</span></span><br><span class="line">y = np.sin(x)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">fig.suptitle(<span class="string">&#x27;fmt: ro&#x27;</span>)</span><br><span class="line">plt.plot(x, y, <span class="string">&#x27;ro&#x27;</span>)     <span class="comment">#不可写成fmt=&#x27;ro&#x27;，目前不识别关键字fmt</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230914190819767.png" alt="image-20230914190819767"></p><p>注意上面这样每个点之间就不能连接起来了，plot()函数还定义了每个点之间的连接方式，如’-.’表示点画线、’-‘表示实线。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(-np.pi, np.pi, <span class="number">50</span>)   <span class="comment">#x = np.linspace(-np.pi, np.pi, 100)</span></span><br><span class="line">y = np.sin(x)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">fig.suptitle(<span class="string">&#x27;fmt: r-*&#x27;</span>)</span><br><span class="line">plt.plot(x, y, <span class="string">&#x27;r-*&#x27;</span>)     <span class="comment">#不可写成fmt=&#x27;ro&#x27;，目前不识别关键字fmt</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210102141914460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZWZhbmpvZQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" /><p><strong>详细的标记如下面三个表所示。</strong> </p><table><thead><tr><th><strong>标记character</strong></th><th><strong>描述description</strong></th><th><strong>标记character</strong></th><th><strong>描述description</strong></th></tr></thead><tbody><tr><td>‘o’</td><td>圆圈</td><td>‘.’</td><td>点</td></tr><tr><td>‘D’</td><td>菱形</td><td>‘s’</td><td>正方形</td></tr><tr><td>‘d’</td><td>小菱形</td><td>‘*’</td><td>星号</td></tr><tr><td>‘H’</td><td>六边形1</td><td>‘v’</td><td>一角朝下的三角形</td></tr><tr><td>‘h’</td><td>六边形2</td><td>‘&lt;’</td><td>一角朝左的三角形</td></tr><tr><td>‘_’</td><td>水平线</td><td>‘&gt;’</td><td>一角朝右的三角形</td></tr><tr><td>‘|’</td><td>竖线</td><td>‘^’</td><td>一角朝上的三角形</td></tr><tr><td>‘8’</td><td>八边形</td><td>‘+’</td><td>加号</td></tr><tr><td>‘p’</td><td>五边形</td><td>‘x’</td><td>X</td></tr><tr><td>‘,’</td><td>像素</td><td>‘None’, ‘’, ‘ ‘</td><td>无</td></tr></tbody></table><table><thead><tr><th><strong>线条风格</strong></th><th><strong>描述</strong></th><th><strong>线条风格</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>‘-‘</td><td>实线</td><td>‘:’</td><td>虚线</td></tr><tr><td>‘–’</td><td>破折线</td><td>‘None’, ‘ ‘, ‘’</td><td>什么都不画</td></tr><tr><td>‘-.’</td><td>点划线</td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>别名</strong></th><th><strong>颜色</strong></th><th><strong>别名</strong></th><th><strong>颜色</strong></th></tr></thead><tbody><tr><td>B</td><td>蓝色</td><td>G</td><td>绿色</td></tr><tr><td>R</td><td>红色</td><td>Y</td><td>黄色</td></tr><tr><td>C</td><td>青色</td><td>K</td><td>黑色</td></tr><tr><td>M</td><td>洋红色</td><td>W</td><td>白色</td></tr></tbody></table><h4 id="各种属性-kwargs：Line2D-properties"><a href="#各种属性-kwargs：Line2D-properties" class="headerlink" title="*各种属性*kwargs：Line2D properties"></a>*<em>各种属性*<em>kwargs：</em></em><a href="https://matplotlib.org/api/_as_gen/matplotlib.lines.Line2D.html#matplotlib.lines.Line2D"><code>Line2D</code></a> properties</h4><p>这个属性就相当之多了，借用官网一句话：<em>kwargs</em> are used to specify properties like a line label (for auto legends), linewidth, antialiasing, marker face color.就是说该参数主要用来指明绘线的一些属性，如标签、线宽、标记、背景颜色等。下面就介绍几个常用的properties，其他的可以去官网查。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">第一个是label，表示标签，如图就是说画的线的标签，通过调用plt.legend()之后会显示出来；</span><br><span class="line">fig = plt.figure()</span><br><span class="line">fig.suptitle(<span class="string">&#x27;Figure: example for label&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], label=<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], label=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">第二个是linewidth，表示线宽，也可以调用缩写lw=<span class="number">1</span>等价于lienwidth=<span class="number">1</span>；</span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], linewidth=<span class="number">1</span>)</span><br><span class="line">plt.plot([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], linewidth=<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">第三个是color，表示颜色，一般来说会自动分配合适的颜色，用户也可以自定义任意符合的颜色；</span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], color=<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">第四个是linestyle，表示线的类型，也可以调用缩写ls=<span class="string">&#x27;-.&#x27;</span>等价于linestyle=<span class="string">&#x27;-.&#x27;</span></span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], linestyle=<span class="string">&#x27;-.&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">第五个是alpha，表示透明度，浮点类型</span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], label=<span class="string">&#x27;a&#x27;</span>, alpha=<span class="number">0.8</span>)</span><br><span class="line">plt.plot([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], label=<span class="string">&#x27;b&#x27;</span>, alpha=<span class="number">0.2</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">第六个凑数的visible，表示是否显示</span><br><span class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], label=<span class="string">&#x27;a&#x27;</span>, visible=<span class="literal">True</span>)</span><br><span class="line">plt.plot([<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], label=<span class="string">&#x27;b&#x27;</span>, visible=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210102143446508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZWZhbmpvZQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 50%;" /><img src="https://img-blog.csdnimg.cn/20210102143720771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZWZhbmpvZQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210102143856204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZWZhbmpvZQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210102144756920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZWZhbmpvZQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210102145102244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZWZhbmpvZQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210102145246838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0ZWZhbmpvZQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" /></p><h3 id="1-5-设置网格线"><a href="#1-5-设置网格线" class="headerlink" title="1.5 设置网格线"></a>1.5 设置网格线</h3><p>通过 axes 对象提供的 grid() 方法可以开启或者关闭画布中的网格以及网格的主&#x2F;次刻度。除此之外，grid() 函数还可以设置网格的颜色、线型以及线宽等属性。</p><p>grid() 的函数使用格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grid(color=<span class="string">&#x27;b&#x27;</span>, ls = <span class="string">&#x27;-.&#x27;</span>, lw = <span class="number">0.25</span>)</span><br></pre></td></tr></table></figure><p>参数含义如下：</p><ul><li>color：表示网格线的颜色；</li><li>ls：表示网格线的样式；</li><li>lw：表示网格线的宽度；</li></ul><p>网格在默认状态下是关闭的，通过调用上述函数，网格会被自动开启，如果只是想开启不带任何样式的网格，可以通过 grid(True) 来实现。</p><p>实例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment"># fig画布；axes子图区域</span></span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">4</span>))</span><br><span class="line">x = np.arange(<span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line">axes[<span class="number">0</span>].plot(x, x ** <span class="number">3</span>, <span class="string">&#x27;g&#x27;</span>, lw=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 开启网格</span></span><br><span class="line">axes[<span class="number">0</span>].grid(<span class="literal">True</span>)</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&#x27;default grid&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>].plot(x, np.exp(x), <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置网格的颜色，线型，线宽</span></span><br><span class="line">axes[<span class="number">1</span>].grid(color=<span class="string">&#x27;b&#x27;</span>, ls=<span class="string">&#x27;-.&#x27;</span>, lw=<span class="number">0.25</span>)</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&#x27;custom grid&#x27;</span>)</span><br><span class="line">axes[<span class="number">2</span>].plot(x, x)</span><br><span class="line">axes[<span class="number">2</span>].set_title(<span class="string">&#x27;no grid&#x27;</span>)</span><br><span class="line">fig.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/81172cef8c034b9c8a4769f920d1163e.png" alt="img"></p><h3 id="1-6-设置坐标轴"><a href="#1-6-设置坐标轴" class="headerlink" title="1.6 设置坐标轴"></a>1.6 设置坐标轴</h3><p><code>set_xlabel</code> 用字符串列表来设置坐标轴的标签，<code>fontsize</code> 设置轴标签的字体和字号等参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">fontdict = &#123;<span class="string">&#x27;weight&#x27;</span>: <span class="string">&#x27;normal&#x27;</span>, <span class="string">&#x27;family&#x27;</span>: <span class="string">&#x27;Times New Roman&#x27;</span>, <span class="string">&#x27;size&#x27;</span>: <span class="number">20</span>&#125;</span><br><span class="line"> </span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">x = np.arange(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">axes.plot(x, np.exp(x))</span><br><span class="line">axes.plot(x, x ** <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置标题</span></span><br><span class="line">axes.set_title(<span class="string">&quot;Normal scale&quot;</span>, fontdict=fontdict)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置x、y轴标签</span></span><br><span class="line">axes.set_xlabel(<span class="string">&quot;x axis&quot;</span>, fontdict=fontdict)</span><br><span class="line">axes.set_ylabel(<span class="string">&quot;y axis&quot;</span>, fontdict=fontdict)</span><br><span class="line"> </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6121c443fc754563866e1690841ac05e.png" alt="img"></p><p>Matplotlib 可以根据自变量与因变量的取值范围，自动设置 x 轴与 y 轴的数值大小。当然，您也可以用自定义的方式，通过 set_xlim() 和 set_ylim() 对 x、y 轴的数值范围进行设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">fig, a1 = plt.subplots(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">x = np.arange(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">a1.plot(x, np.exp(x), <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">a1.set_title(<span class="string">&#x27;exp&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置y轴</span></span><br><span class="line">a1.set_ylim(<span class="number">0</span>, <span class="number">4000</span>)</span><br><span class="line"><span class="comment"># 设置x轴</span></span><br><span class="line">a1.set_xlim(<span class="number">0</span>, <span class="number">8</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/859c5939485d4a6c9c46865df3005fb6.png" alt="img"></p><p>移动坐标轴以及为坐标轴添加箭头可以通过mpl_toolkits.axisartist实现，如下例所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> mpl_toolkits.axisartist <span class="keyword">as</span> axisartist</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 新建一个画板（画图视窗）</span></span><br><span class="line">fig = plt.figure(<span class="string">&#x27;Sine Wave&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 新建一个绘图区对象ax,并添加到画板中</span></span><br><span class="line">ax = axisartist.Subplot(fig, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">fig.add_axes(ax)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 隐藏默认坐标轴（上下左右边框）</span></span><br><span class="line">ax.axis[:].set_visible(<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># ax.axis[&quot;top&quot;].set_visible(False)</span></span><br><span class="line"><span class="comment"># ax.axis[&quot;right&quot;].set_visible(False)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 新建可移动的坐标轴X-Y</span></span><br><span class="line">ax.axis[<span class="string">&quot;x&quot;</span>] = ax.new_floating_axis(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">ax.axis[<span class="string">&quot;y&quot;</span>] = ax.new_floating_axis(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置刻度标识方向</span></span><br><span class="line">ax.axis[<span class="string">&quot;x&quot;</span>].set_axis_direction(<span class="string">&#x27;top&#x27;</span>)</span><br><span class="line">ax.axis[<span class="string">&quot;y&quot;</span>].set_axis_direction(<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 加上坐标轴箭头，设置刻度标识位置</span></span><br><span class="line">ax.axis[<span class="string">&quot;x&quot;</span>].set_axisline_style(<span class="string">&quot;-&gt;&quot;</span>, size=<span class="number">2.0</span>)</span><br><span class="line">ax.axis[<span class="string">&quot;y&quot;</span>].set_axisline_style(<span class="string">&quot;-&gt;&quot;</span>, size=<span class="number">2.0</span>)</span><br><span class="line">ax.axis[<span class="string">&quot;x&quot;</span>].set_axis_direction(<span class="string">&#x27;top&#x27;</span>)</span><br><span class="line">ax.axis[<span class="string">&quot;y&quot;</span>].set_axis_direction(<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 画上y=sin(t)折线图，设置刻度范围，设置刻度标识，设置坐标轴位置</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi)</span><br><span class="line">y = np.sin(t)</span><br><span class="line">ax.plot(t, y, color=<span class="string">&#x27;red&#x27;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;y = 2sin(2t)&#x27;</span>, fontsize=<span class="number">14</span>, pad=<span class="number">20</span>)</span><br><span class="line"> </span><br><span class="line">ax.set_xticks(np.linspace(<span class="number">0.25</span>, <span class="number">1.25</span>, <span class="number">5</span>) * np.pi)</span><br><span class="line">ax.set_yticks([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置刻度标识显示</span></span><br><span class="line">ax.set_xlim(-<span class="number">0.5</span> * np.pi, <span class="number">1.5</span> * np.pi)</span><br><span class="line">ax.set_ylim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2727e1ac530f4dee8341e75dedeaf359.png" alt="img"></p><p>其中，创建坐标轴的方法有两种：</p><p><code>new_fixed_axis(self, loc, offset=None)</code>和<code>new_floating_axis(self, nth_coord, value, axis_direction=‘bottom’)</code>，而<code>new_floating_axis()</code>相对更加灵活。<br>（1）<strong>nth_coord：</strong>坐标轴方向，0代表X方向，1代表Y方向<br>（2）<strong>value：</strong>坐标轴处于位置，如果是平行与X轴的新坐标轴，则代表Y位置（即通过（0，value）），如果是平行与Y轴的新坐标轴，则代表X位置（即通过（value，0））。<br>（3）<strong>axis_direction：</strong>代表刻度标识字的方向，可选[‘top’, ‘bottom’, ‘left’, ‘right’]</p><h3 id="1-7-设置刻度和标签"><a href="#1-7-设置刻度和标签" class="headerlink" title="1.7 设置刻度和标签"></a>1.7 设置刻度和标签</h3><p>刻度指的是轴上数据点的标记，Matplotlib 能够自动的在 x 、y 轴上绘制出刻度。这一功能的实现得益于 Matplotlib 内置的刻度定位器和格式化器（两个内建类）。在大多数情况下，这两个内建类完全能够满足我们的绘图需求，但是在某些情况下，刻度标签或刻度也需要满足特定的要求，比如将刻度设置为“英文数字形式”或者“大写阿拉伯数字”，此时就需要对它们重新设置。</p><p>xticks() 和 yticks() 函数接受一个列表对象作为参数，列表中的元素表示对应数轴上要显示的刻度。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.set_xticks([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>])</span><br></pre></td></tr></table></figure><p>x 轴上的刻度标记，依次为 2，4，6，8，10。您也可以分别通过 set_xticklabels() 和 set_yticklabels() 函数设置与刻度线相对应的刻度标签。</p><p>下面示例介绍了刻度和标签的使用方法，其中对标签逆时针旋转了90°：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"> </span><br><span class="line">x = np.arange(<span class="number">0</span>, math.pi * <span class="number">2</span>, <span class="number">0.05</span>)</span><br><span class="line"> </span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">1</span>, figsize=(<span class="number">5</span>, <span class="number">6</span>))</span><br><span class="line"> </span><br><span class="line">y = np.sin(x)</span><br><span class="line">ax.plot(x, y)</span><br><span class="line"><span class="comment"># 设置x轴标签</span></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;angle&#x27;</span>)</span><br><span class="line"><span class="comment"># ax.set_title(&#x27;sine&#x27;)</span></span><br><span class="line">ax.set_xticks([<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line"><span class="comment"># 设置x轴刻度标签,并旋转90°</span></span><br><span class="line">ax.set_xticklabels([<span class="string">&#x27;zero&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;six&#x27;</span>], rotation=<span class="number">90</span>)</span><br><span class="line"><span class="comment"># 设置y轴刻度</span></span><br><span class="line">ax.set_yticks([-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/0e4f7e928ce94422a6f5c5f76c7b3467.png" alt="img"></p><h3 id="1-8-添加图例和标题"><a href="#1-8-添加图例和标题" class="headerlink" title="1.8 添加图例和标题"></a>1.8 添加图例和标题</h3><p>图例通过<code>ax.legend</code>或者<code>plt.legend()</code>实现，标题通过<code>ax.set_title()</code>或者<code>plt.title()</code>实现，基本用法如下例所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"> </span><br><span class="line">mpl.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>] = [<span class="string">&quot;SimHei&quot;</span>]</span><br><span class="line">mpl.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>] = <span class="literal">False</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">x = np.linspace(-<span class="number">2</span> * np.pi, <span class="number">2</span> * np.pi, <span class="number">200</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">y1 = np.cos(x)</span><br><span class="line"> </span><br><span class="line">ax.plot(x, y, label=<span class="string">r&quot;$\sin(x)$&quot;</span>)</span><br><span class="line">ax.plot(x, y1, label=<span class="string">r&quot;$\cos(x)$&quot;</span>)</span><br><span class="line"> </span><br><span class="line">ax.legend(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">ax.set_title(<span class="string">&quot;正弦函数和余弦函数的折线图&quot;</span>)</span><br><span class="line"> </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f03409b8592b4307b55ce191da7fbbc9.png" alt="img"></p><p><strong>调整图例</strong></p><p>对于图例，我们还可以通过改变legend()的参数来改变图例的显示位置，展示样式（包括图例的外边框、图例中的文本标签的排列位置和图例的投影效果等方面）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">2.1</span>, <span class="number">0.1</span>)</span><br><span class="line">y = np.power(x, <span class="number">3</span>)</span><br><span class="line">y1 = np.power(x, <span class="number">2</span>)</span><br><span class="line">y2 = np.power(x, <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">plt.plot(x, y, ls=<span class="string">&quot;-&quot;</span>, lw=<span class="number">2</span>, label=<span class="string">&quot;$x^&#123;3&#125;$&quot;</span>)</span><br><span class="line">plt.plot(x, y1, c=<span class="string">&quot;r&quot;</span>, ls=<span class="string">&quot;-&quot;</span>, lw=<span class="number">2</span>, label=<span class="string">&quot;$x^&#123;2&#125;$&quot;</span>)</span><br><span class="line">plt.plot(x, y2, c=<span class="string">&quot;y&quot;</span>, ls=<span class="string">&quot;-&quot;</span>, lw=<span class="number">2</span>, label=<span class="string">&quot;$x^&#123;1&#125;$&quot;</span>)</span><br><span class="line"> </span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper left&quot;</span>, bbox_to_anchor=(<span class="number">0.05</span>, <span class="number">0.95</span>),</span><br><span class="line">           ncol=<span class="number">3</span>, title=<span class="string">&quot;power function&quot;</span>, shadow=<span class="literal">True</span>,</span><br><span class="line">           fancybox=<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/143fa867ac8b4e16b43a2a2fbf386a4d.png" alt="img"></p><p><code> plt.legend()</code>的位置参数loc也可以使用数字，其对应如下：</p><table><thead><tr><th align="center">字符串</th><th align="center">位置编号</th><th align="center">位置表述</th></tr></thead><tbody><tr><td align="center"><strong><code>best</code></strong></td><td align="center">0</td><td align="center">最佳位置</td></tr><tr><td align="center"><strong><code>upper right</code></strong></td><td align="center">1</td><td align="center">右上角</td></tr><tr><td align="center"><strong><code>upper left</code></strong></td><td align="center">2</td><td align="center">左上角</td></tr><tr><td align="center"><strong><code>lower left</code></strong></td><td align="center">3</td><td align="center">右下角</td></tr><tr><td align="center"><strong><code>lower right</code></strong></td><td align="center">4</td><td align="center">左下角</td></tr><tr><td align="center"><strong><code>right</code></strong></td><td align="center">5</td><td align="center">右侧</td></tr><tr><td align="center"><strong><code>center left</code></strong></td><td align="center">6</td><td align="center">左侧垂直居中</td></tr><tr><td align="center"><strong><code>center right</code></strong></td><td align="center">7</td><td align="center">右侧垂直居中</td></tr><tr><td align="center"><strong><code>lower center</code></strong></td><td align="center">8</td><td align="center">下方水平居中</td></tr><tr><td align="center"><strong><code>upper center</code></strong></td><td align="center">9</td><td align="center">上方水平居中</td></tr><tr><td align="center"><strong><code>center</code></strong></td><td align="center">10</td><td align="center">正中间</td></tr></tbody></table><p>此外还用到了线框位置参数bbox_to_anchor，它的参数值是一个四元元组，且使用Axes坐标系统。也就是说第一个元素代表距离画布左侧的x轴长度的倍速的距离；第二个元素代表距离画布底部的y轴长度的倍数的距离；第三个元素代表元素x轴长度的倍数的线框长度；第四个元素代表y轴长度的倍数的线框宽度。plt.legend(loc &#x3D; “upper left”,bbox_to_anchor&#x3D;(0.05,0.95),ncol &#x3D; 3,title &#x3D; “power function”,shadow&#x3D;True,fancybox&#x3D;True)会把图例放在上方左手边拐角处的距离坐标轴左边0.1，底部7.6的位置。关键字参数shadow控制线框是否添加阴影；fancybox控制线框是直角还是圆角。 </p><p><strong>调整标题</strong></p><p>对于标题，也可以通过参数控制各种文本属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">x = np.linspace(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">1000</span>)</span><br><span class="line">y = np.exp(x)</span><br><span class="line"> </span><br><span class="line">plt.plot(x, y, ls=<span class="string">&quot;-&quot;</span>, lw=<span class="number">2</span>, color=<span class="string">&quot;g&quot;</span>)</span><br><span class="line"> </span><br><span class="line">plt.title(<span class="string">&quot;center demo&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Left Demo&quot;</span>, loc=<span class="string">&quot;left&quot;</span>,</span><br><span class="line">          fontdict=&#123;<span class="string">&quot;size&quot;</span>: <span class="string">&quot;xx-large&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;color&quot;</span>: <span class="string">&quot;r&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;family&quot;</span>: <span class="string">&quot;Times New Roman&quot;</span>&#125;)</span><br><span class="line">plt.title(<span class="string">&quot;Right Demo&quot;</span>, loc=<span class="string">&quot;right&quot;</span>,</span><br><span class="line">          size=<span class="number">20</span>, color=<span class="string">&quot;c&quot;</span>,</span><br><span class="line">          style=<span class="string">&quot;oblique&quot;</span>,</span><br><span class="line">          family=<span class="string">&quot;Comic Sans MS&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/9bdf76a7becf40588d6eb8e38314f728.png" alt="img"></p><p>上面展示了plt.title()中参数的两种使用方法。其中位置参数loc可以选择“left”，“center”和“right”。family控制的是字体类别，size控制字体大小，color控制字体颜色，style控制字体风格。</p><h3 id="1-9-设置中文显示"><a href="#1-9-设置中文显示" class="headerlink" title="1.9 设置中文显示"></a>1.9 设置中文显示</h3><p>Matplotlib 默认不支持中文字体，只支持 ASCII 字符，但中文标注更加符合中国人的阅读习惯。</p><p>当直接使用中文时，Matplotlib 绘制的图像会出现中文乱码，如左图所示。通过临时重写配置文件的方法，可以解决 Matplotlib 显示中文乱码的问题，代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">plt.rcParams[<span class="string">&quot;font.sans-serif&quot;</span>] = [<span class="string">&quot;SimHei&quot;</span>]  <span class="comment"># 设置字体</span></span><br><span class="line">plt.rcParams[<span class="string">&quot;axes.unicode_minus&quot;</span>] = <span class="literal">False</span>  <span class="comment"># 正常显示负号</span></span><br><span class="line">year = [<span class="number">2017</span>, <span class="number">2018</span>, <span class="number">2019</span>, <span class="number">2020</span>]</span><br><span class="line">people = [<span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>, <span class="number">70</span>]</span><br><span class="line"><span class="comment"># 生成图表</span></span><br><span class="line">plt.plot(year, people)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;年份&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;人口&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;人口增长&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置纵坐标刻度</span></span><br><span class="line">plt.yticks([<span class="number">0</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">60</span>, <span class="number">80</span>])</span><br><span class="line"><span class="comment"># 设置填充选项：参数分别对应横坐标，纵坐标，纵坐标填充起始值，填充颜色</span></span><br><span class="line">plt.fill_between(year, people, <span class="number">20</span>, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"><span class="comment"># 显示图表</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5a959b0060214ef4a17221eee131e7e1.png" alt="img"><img src="https://img-blog.csdnimg.cn/3f25e2d0719c4b87816440c1a288fb28.png" alt="img"></p><h3 id="1-10-设置数学表达式显示"><a href="#1-10-设置数学表达式显示" class="headerlink" title="1.10 设置数学表达式显示"></a>1.10 设置数学表达式显示</h3><p>Matplotlib中的文本字符串都可以使用 Latex 格式显现出来，具体的使用方法是将文本标记符放在一对美元符号<code>$</code>内，语法格式如下： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制表达式 r&#x27;$\alpha_i&gt; \beta_i$&#x27;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">t = np.arange(<span class="number">0.0</span>, <span class="number">2.0</span>, <span class="number">0.01</span>)</span><br><span class="line">s = np.sin(<span class="number">2</span> * np.pi * t)</span><br><span class="line"><span class="comment"># 绘制函数图像</span></span><br><span class="line">plt.plot(t, s)</span><br><span class="line"><span class="comment"># 设置标题</span></span><br><span class="line">plt.title(<span class="string">r&#x27;$\alpha_i&gt; \beta_i$&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 设置数学表达式</span></span><br><span class="line">plt.text(<span class="number">0.6</span>, <span class="number">0.6</span>, <span class="string">r&#x27;$\mathcal&#123;A&#125;\mathrm&#123;sin&#125;(2 \omega t)$&#x27;</span>, fontsize=<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 设置数学表达式</span></span><br><span class="line">plt.text(<span class="number">0.1</span>, -<span class="number">0.5</span>, <span class="string">r&#x27;$\sqrt&#123;2&#125;$&#x27;</span>, fontsize=<span class="number">10</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;time (s)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;volts (mV)&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/84086091cf4147e1a216af975a9ca454.png" alt="img"></p><h3 id="1-11-调整子图布局"><a href="#1-11-调整子图布局" class="headerlink" title="1.11 调整子图布局"></a>1.11 调整子图布局</h3><p>在pyplot模块中，与调整子图布局的函数主要为subplots_adjust和tight_layout，其中subplots_adjust是修改子图间距的通用函数，tight_layout默认执行一种固定的间距配置，也可以自定义间距配置，底层原理类似于subplots_adjust函数。</p><p><strong>subplots_adjust</strong></p><p>subplots_adjust函数的功能为调整子图的布局参数。对于没有设置的参数保持不变，初始值由rcParams[“figure.subplot.[name]”]提供。</p><blockquote><p><strong>用法：</strong>matplotlib.pyplot.subplots_adjust(left&#x3D;None, bottom&#x3D;None, right&#x3D;None, top&#x3D;None, wspace&#x3D;None, hspace&#x3D;None)</p></blockquote><p><strong>参数：</strong></p><ul><li><strong>left：</strong>所有子图整体相对于图像的左外边距，距离单位为图像宽度的比例（小数）。可选参数。浮点数。默认值为0.125。</li><li><strong>right：</strong>所有子图整体相对于图像的右外边距，距离单位为图像宽度的比例（小数）。可选参数。浮点数。默认值为0.0。</li><li><strong>bottom：</strong>所有子图整体相对于图像的下外边距，距离单位为图像高度的比例（小数）。可选参数。浮点数。默认值为0.11。</li><li><strong>top：</strong>所有子图整体相对于图像的上外边距，距离单位为图像高度的比例（小数）。可选参数。浮点数。默认值为0.88。</li><li><strong>wspace：</strong>子图间宽度内边距，距离单位为子图平均宽度的比例（小数）。浮点数。默认值为0.2。</li><li><strong>hspace：</strong>子图间高度内边距，距离单位为子图平均高度的比例（小数）。可选参数。浮点数。默认值为0.2。</li></ul><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 原始间距配置</span></span><br><span class="line">fig, ax = plt.subplots(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">vars</span>(fig.subplotpars))</span><br><span class="line"><span class="comment"># 通过subplots_adjust()设置间距配置</span></span><br><span class="line">plt.subplots_adjust(left=<span class="number">0.1</span>, bottom=<span class="number">0.1</span>, right=<span class="number">0.9</span>, top=<span class="number">0.9</span>, wspace=<span class="number">0.5</span>, hspace=<span class="number">0.5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">vars</span>(fig.subplotpars))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>原始间距：<img src="https://img-blog.csdnimg.cn/e496616ffb4f4e4480e2d1980c84d298.png" alt="img"></p><p>修改间距后（wspace&#x3D;0.5, hspace&#x3D;0.5）： </p><p><img src="https://img-blog.csdnimg.cn/da6a3386872a434688a088500e12ccfb.png" alt="img"></p><p><strong>tight_layout</strong></p><p>pyplot模块中的tight_layout()函数可用于自动调整子图参数或按指定参数填充。通过设置rcParams[‘figure.autolayout’]&#x3D;True可图像自动应用tight_layout。</p><blockquote><p><strong>用法：</strong> matplotlib.pyplot.tight_layout(pad&#x3D;1.08, h_pad&#x3D;None, w_pad&#x3D;None, rect&#x3D;None)</p></blockquote><p><strong>参数</strong>：</p><ul><li><strong>pad：</strong>此参数用于在图形边和子图的边之间进行填充，以字体大小的一部分表示。</li><li><strong>h_pad，w_pad：</strong>这些参数用于相邻子图的边之间的填充(高度&#x2F;宽度)，作为字体大小的一部分。</li><li><strong>rect：</strong>此参数是整个子图区域将适合的归一化图形坐标中的矩形。</li></ul><h3 id="1-12-保存图片"><a href="#1-12-保存图片" class="headerlink" title="1.12 保存图片"></a>1.12 保存图片</h3><p> 使用savefig()函数可将图片保存在指定目录下，在show()前插入，如果在show()后面会出现保存图片为空白现象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.savefig(<span class="string">&quot;example.png&quot;</span>)</span><br></pre></td></tr></table></figure><p>采用下面的方法可以保存去除旁边空白区域和坐标轴的图片，论文绘图时常用。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pyplot.axis(<span class="string">&#x27;off&#x27;</span>) <span class="comment">#增加这行关闭坐标轴显示</span></span><br><span class="line"><span class="comment">#关键在于bbox_inches = &#x27;tight&#x27;,pad_inches = 0，去掉空白区域</span></span><br><span class="line">pyplot.savefig(save_dir,bbox_inches = <span class="string">&#x27;tight&#x27;</span>,pad_inches = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="二、常见绘图属性"><a href="#二、常见绘图属性" class="headerlink" title="二、常见绘图属性"></a>二、常见绘图属性</h2><h3 id="2-1-绘图标记"><a href="#2-1-绘图标记" class="headerlink" title="2.1 绘图标记"></a>2.1 绘图标记</h3><p>绘图过程如果我们想要给坐标自定义一些不一样的标记，就可以使用 <strong>plot()</strong> 方法的 marker 参数来定义。</p><p>以下实例定义了实心圆标记：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">ypoints = np.array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"> </span><br><span class="line">plt.plot(ypoints, marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d66d0f964c474973a9f13063903bd434.png" alt="img"></p><p> marker 可以定义的符号如下：</p><p>以下实例定义了 * 标记：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">ypoints = np.array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"> </span><br><span class="line">plt.plot(ypoints, marker=<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/db64f14b1c1e497984d20d5a58407da9.png" alt="img"></p><p><strong>fmt 参数</strong></p><p>fmt 参数定义了基本格式，如标记、线条样式和颜色。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt = <span class="string">&#x27;[marker][line][color]&#x27;</span></span><br></pre></td></tr></table></figure><p>例如 o:r，o 表示实心圆标记，: 表示虚线，r 表示颜色为红色。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">ypoints = np.array([<span class="number">6</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">10</span>])</span><br><span class="line"> </span><br><span class="line">plt.plot(ypoints, <span class="string">&#x27;o:r&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5e510d6ea32542ae9a2bd0d231954c4d.png" alt="img"></p><p>线类型：</p><table><thead><tr><th align="center">线类型标记</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">‘-‘</td><td align="center">实线</td></tr><tr><td align="center">‘:’</td><td align="center">虚线</td></tr><tr><td align="center">‘–’</td><td align="center">破折线</td></tr><tr><td align="center">‘-.’</td><td align="center">点划线</td></tr></tbody></table><p>颜色类型：</p><table><thead><tr><th align="center">颜色标记</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">‘r’</td><td align="center">红色</td></tr><tr><td align="center">‘g’</td><td align="center">绿色</td></tr><tr><td align="center">‘b’</td><td align="center">蓝色</td></tr><tr><td align="center">‘c’</td><td align="center">青色</td></tr><tr><td align="center">‘m’</td><td align="center">品红</td></tr><tr><td align="center">‘y’</td><td align="center">黄色</td></tr><tr><td align="center">‘k’</td><td align="center">黑色</td></tr><tr><td align="center">‘w’</td><td align="center">白色</td></tr></tbody></table><p><strong>详细颜色对照表</strong> </p><p><img src="https://img-blog.csdnimg.cn/img_convert/109fa03e9a1a0ef1d53f8999766ddd56.png" alt="109fa03e9a1a0ef1d53f8999766ddd56.png"></p><p><strong>颜色及十六进制对应</strong></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">cnames = &#123;</span><br><span class="line">&#x27;aliceblue&#x27;:            &#x27;#F0F8FF&#x27;,</span><br><span class="line">&#x27;antiquewhite&#x27;:         &#x27;#FAEBD7&#x27;,</span><br><span class="line">&#x27;aqua&#x27;:                 &#x27;#00FFFF&#x27;,</span><br><span class="line">&#x27;aquamarine&#x27;:           &#x27;#7FFFD4&#x27;,</span><br><span class="line">&#x27;azure&#x27;:                &#x27;#F0FFFF&#x27;,</span><br><span class="line">&#x27;beige&#x27;:                &#x27;#F5F5DC&#x27;,</span><br><span class="line">&#x27;bisque&#x27;:               &#x27;#FFE4C4&#x27;,</span><br><span class="line">&#x27;black&#x27;:                &#x27;#000000&#x27;,</span><br><span class="line">&#x27;blanchedalmond&#x27;:       &#x27;#FFEBCD&#x27;,</span><br><span class="line">&#x27;blue&#x27;:                 &#x27;#0000FF&#x27;,</span><br><span class="line">&#x27;blueviolet&#x27;:           &#x27;#8A2BE2&#x27;,</span><br><span class="line">&#x27;brown&#x27;:                &#x27;#A52A2A&#x27;,</span><br><span class="line">&#x27;burlywood&#x27;:            &#x27;#DEB887&#x27;,</span><br><span class="line">&#x27;cadetblue&#x27;:            &#x27;#5F9EA0&#x27;,</span><br><span class="line">&#x27;chartreuse&#x27;:           &#x27;#7FFF00&#x27;,</span><br><span class="line">&#x27;chocolate&#x27;:            &#x27;#D2691E&#x27;,</span><br><span class="line">&#x27;coral&#x27;:                &#x27;#FF7F50&#x27;,</span><br><span class="line">&#x27;cornflowerblue&#x27;:       &#x27;#6495ED&#x27;,</span><br><span class="line">&#x27;cornsilk&#x27;:             &#x27;#FFF8DC&#x27;,</span><br><span class="line">&#x27;crimson&#x27;:              &#x27;#DC143C&#x27;,</span><br><span class="line">&#x27;cyan&#x27;:                 &#x27;#00FFFF&#x27;,</span><br><span class="line">&#x27;darkblue&#x27;:             &#x27;#00008B&#x27;,</span><br><span class="line">&#x27;darkcyan&#x27;:             &#x27;#008B8B&#x27;,</span><br><span class="line">&#x27;darkgoldenrod&#x27;:        &#x27;#B8860B&#x27;,</span><br><span class="line">&#x27;darkgray&#x27;:             &#x27;#A9A9A9&#x27;,</span><br><span class="line">&#x27;darkgreen&#x27;:            &#x27;#006400&#x27;,</span><br><span class="line">&#x27;darkkhaki&#x27;:            &#x27;#BDB76B&#x27;,</span><br><span class="line">&#x27;darkmagenta&#x27;:          &#x27;#8B008B&#x27;,</span><br><span class="line">&#x27;darkolivegreen&#x27;:       &#x27;#556B2F&#x27;,</span><br><span class="line">&#x27;darkorange&#x27;:           &#x27;#FF8C00&#x27;,</span><br><span class="line">&#x27;darkorchid&#x27;:           &#x27;#9932CC&#x27;,</span><br><span class="line">&#x27;darkred&#x27;:              &#x27;#8B0000&#x27;,</span><br><span class="line">&#x27;darksalmon&#x27;:           &#x27;#E9967A&#x27;,</span><br><span class="line">&#x27;darkseagreen&#x27;:         &#x27;#8FBC8F&#x27;,</span><br><span class="line">&#x27;darkslateblue&#x27;:        &#x27;#483D8B&#x27;,</span><br><span class="line">&#x27;darkslategray&#x27;:        &#x27;#2F4F4F&#x27;,</span><br><span class="line">&#x27;darkturquoise&#x27;:        &#x27;#00CED1&#x27;,</span><br><span class="line">&#x27;darkviolet&#x27;:           &#x27;#9400D3&#x27;,</span><br><span class="line">&#x27;deeppink&#x27;:             &#x27;#FF1493&#x27;,</span><br><span class="line">&#x27;deepskyblue&#x27;:          &#x27;#00BFFF&#x27;,</span><br><span class="line">&#x27;dimgray&#x27;:              &#x27;#696969&#x27;,</span><br><span class="line">&#x27;dodgerblue&#x27;:           &#x27;#1E90FF&#x27;,</span><br><span class="line">&#x27;firebrick&#x27;:            &#x27;#B22222&#x27;,</span><br><span class="line">&#x27;floralwhite&#x27;:          &#x27;#FFFAF0&#x27;,</span><br><span class="line">&#x27;forestgreen&#x27;:          &#x27;#228B22&#x27;,</span><br><span class="line">&#x27;fuchsia&#x27;:              &#x27;#FF00FF&#x27;,</span><br><span class="line">&#x27;gainsboro&#x27;:            &#x27;#DCDCDC&#x27;,</span><br><span class="line">&#x27;ghostwhite&#x27;:           &#x27;#F8F8FF&#x27;,</span><br><span class="line">&#x27;gold&#x27;:                 &#x27;#FFD700&#x27;,</span><br><span class="line">&#x27;goldenrod&#x27;:            &#x27;#DAA520&#x27;,</span><br><span class="line">&#x27;gray&#x27;:                 &#x27;#808080&#x27;,</span><br><span class="line">&#x27;green&#x27;:                &#x27;#008000&#x27;,</span><br><span class="line">&#x27;greenyellow&#x27;:          &#x27;#ADFF2F&#x27;,</span><br><span class="line">&#x27;honeydew&#x27;:             &#x27;#F0FFF0&#x27;,</span><br><span class="line">&#x27;hotpink&#x27;:              &#x27;#FF69B4&#x27;,</span><br><span class="line">&#x27;indianred&#x27;:            &#x27;#CD5C5C&#x27;,</span><br><span class="line">&#x27;indigo&#x27;:               &#x27;#4B0082&#x27;,</span><br><span class="line">&#x27;ivory&#x27;:                &#x27;#FFFFF0&#x27;,</span><br><span class="line">&#x27;khaki&#x27;:                &#x27;#F0E68C&#x27;,</span><br><span class="line">&#x27;lavender&#x27;:             &#x27;#E6E6FA&#x27;,</span><br><span class="line">&#x27;lavenderblush&#x27;:        &#x27;#FFF0F5&#x27;,</span><br><span class="line">&#x27;lawngreen&#x27;:            &#x27;#7CFC00&#x27;,</span><br><span class="line">&#x27;lemonchiffon&#x27;:         &#x27;#FFFACD&#x27;,</span><br><span class="line">&#x27;lightblue&#x27;:            &#x27;#ADD8E6&#x27;,</span><br><span class="line">&#x27;lightcoral&#x27;:           &#x27;#F08080&#x27;,</span><br><span class="line">&#x27;lightcyan&#x27;:            &#x27;#E0FFFF&#x27;,</span><br><span class="line">&#x27;lightgoldenrodyellow&#x27;: &#x27;#FAFAD2&#x27;,</span><br><span class="line">&#x27;lightgreen&#x27;:           &#x27;#90EE90&#x27;,</span><br><span class="line">&#x27;lightgray&#x27;:            &#x27;#D3D3D3&#x27;,</span><br><span class="line">&#x27;lightpink&#x27;:            &#x27;#FFB6C1&#x27;,</span><br><span class="line">&#x27;lightsalmon&#x27;:          &#x27;#FFA07A&#x27;,</span><br><span class="line">&#x27;lightseagreen&#x27;:        &#x27;#20B2AA&#x27;,</span><br><span class="line">&#x27;lightskyblue&#x27;:         &#x27;#87CEFA&#x27;,</span><br><span class="line">&#x27;lightslategray&#x27;:       &#x27;#778899&#x27;,</span><br><span class="line">&#x27;lightsteelblue&#x27;:       &#x27;#B0C4DE&#x27;,</span><br><span class="line">&#x27;lightyellow&#x27;:          &#x27;#FFFFE0&#x27;,</span><br><span class="line">&#x27;lime&#x27;:                 &#x27;#00FF00&#x27;,</span><br><span class="line">&#x27;limegreen&#x27;:            &#x27;#32CD32&#x27;,</span><br><span class="line">&#x27;linen&#x27;:                &#x27;#FAF0E6&#x27;,</span><br><span class="line">&#x27;magenta&#x27;:              &#x27;#FF00FF&#x27;,</span><br><span class="line">&#x27;maroon&#x27;:               &#x27;#800000&#x27;,</span><br><span class="line">&#x27;mediumaquamarine&#x27;:     &#x27;#66CDAA&#x27;,</span><br><span class="line">&#x27;mediumblue&#x27;:           &#x27;#0000CD&#x27;,</span><br><span class="line">&#x27;mediumorchid&#x27;:         &#x27;#BA55D3&#x27;,</span><br><span class="line">&#x27;mediumpurple&#x27;:         &#x27;#9370DB&#x27;,</span><br><span class="line">&#x27;mediumseagreen&#x27;:       &#x27;#3CB371&#x27;,</span><br><span class="line">&#x27;mediumslateblue&#x27;:      &#x27;#7B68EE&#x27;,</span><br><span class="line">&#x27;mediumspringgreen&#x27;:    &#x27;#00FA9A&#x27;,</span><br><span class="line">&#x27;mediumturquoise&#x27;:      &#x27;#48D1CC&#x27;,</span><br><span class="line">&#x27;mediumvioletred&#x27;:      &#x27;#C71585&#x27;,</span><br><span class="line">&#x27;midnightblue&#x27;:         &#x27;#191970&#x27;,</span><br><span class="line">&#x27;mintcream&#x27;:            &#x27;#F5FFFA&#x27;,</span><br><span class="line">&#x27;mistyrose&#x27;:            &#x27;#FFE4E1&#x27;,</span><br><span class="line">&#x27;moccasin&#x27;:             &#x27;#FFE4B5&#x27;,</span><br><span class="line">&#x27;navajowhite&#x27;:          &#x27;#FFDEAD&#x27;,</span><br><span class="line">&#x27;navy&#x27;:                 &#x27;#000080&#x27;,</span><br><span class="line">&#x27;oldlace&#x27;:              &#x27;#FDF5E6&#x27;,</span><br><span class="line">&#x27;olive&#x27;:                &#x27;#808000&#x27;,</span><br><span class="line">&#x27;olivedrab&#x27;:            &#x27;#6B8E23&#x27;,</span><br><span class="line">&#x27;orange&#x27;:               &#x27;#FFA500&#x27;,</span><br><span class="line">&#x27;orangered&#x27;:            &#x27;#FF4500&#x27;,</span><br><span class="line">&#x27;orchid&#x27;:               &#x27;#DA70D6&#x27;,</span><br><span class="line">&#x27;palegoldenrod&#x27;:        &#x27;#EEE8AA&#x27;,</span><br><span class="line">&#x27;palegreen&#x27;:            &#x27;#98FB98&#x27;,</span><br><span class="line">&#x27;paleturquoise&#x27;:        &#x27;#AFEEEE&#x27;,</span><br><span class="line">&#x27;palevioletred&#x27;:        &#x27;#DB7093&#x27;,</span><br><span class="line">&#x27;papayawhip&#x27;:           &#x27;#FFEFD5&#x27;,</span><br><span class="line">&#x27;peachpuff&#x27;:            &#x27;#FFDAB9&#x27;,</span><br><span class="line">&#x27;peru&#x27;:                 &#x27;#CD853F&#x27;,</span><br><span class="line">&#x27;pink&#x27;:                 &#x27;#FFC0CB&#x27;,</span><br><span class="line">&#x27;plum&#x27;:                 &#x27;#DDA0DD&#x27;,</span><br><span class="line">&#x27;powderblue&#x27;:           &#x27;#B0E0E6&#x27;,</span><br><span class="line">&#x27;purple&#x27;:               &#x27;#800080&#x27;,</span><br><span class="line">&#x27;red&#x27;:                  &#x27;#FF0000&#x27;,</span><br><span class="line">&#x27;rosybrown&#x27;:            &#x27;#BC8F8F&#x27;,</span><br><span class="line">&#x27;royalblue&#x27;:            &#x27;#4169E1&#x27;,</span><br><span class="line">&#x27;saddlebrown&#x27;:          &#x27;#8B4513&#x27;,</span><br><span class="line">&#x27;salmon&#x27;:               &#x27;#FA8072&#x27;,</span><br><span class="line">&#x27;sandybrown&#x27;:           &#x27;#FAA460&#x27;,</span><br><span class="line">&#x27;seagreen&#x27;:             &#x27;#2E8B57&#x27;,</span><br><span class="line">&#x27;seashell&#x27;:             &#x27;#FFF5EE&#x27;,</span><br><span class="line">&#x27;sienna&#x27;:               &#x27;#A0522D&#x27;,</span><br><span class="line">&#x27;silver&#x27;:               &#x27;#C0C0C0&#x27;,</span><br><span class="line">&#x27;skyblue&#x27;:              &#x27;#87CEEB&#x27;,</span><br><span class="line">&#x27;slateblue&#x27;:            &#x27;#6A5ACD&#x27;,</span><br><span class="line">&#x27;slategray&#x27;:            &#x27;#708090&#x27;,</span><br><span class="line">&#x27;snow&#x27;:                 &#x27;#FFFAFA&#x27;,</span><br><span class="line">&#x27;springgreen&#x27;:          &#x27;#00FF7F&#x27;,</span><br><span class="line">&#x27;steelblue&#x27;:            &#x27;#4682B4&#x27;,</span><br><span class="line">&#x27;tan&#x27;:                  &#x27;#D2B48C&#x27;,</span><br><span class="line">&#x27;teal&#x27;:                 &#x27;#008080&#x27;,</span><br><span class="line">&#x27;thistle&#x27;:              &#x27;#D8BFD8&#x27;,</span><br><span class="line">&#x27;tomato&#x27;:               &#x27;#FF6347&#x27;,</span><br><span class="line">&#x27;turquoise&#x27;:            &#x27;#40E0D0&#x27;,</span><br><span class="line">&#x27;violet&#x27;:               &#x27;#EE82EE&#x27;,</span><br><span class="line">&#x27;wheat&#x27;:                &#x27;#F5DEB3&#x27;,</span><br><span class="line">&#x27;white&#x27;:                &#x27;#FFFFFF&#x27;,</span><br><span class="line">&#x27;whitesmoke&#x27;:           &#x27;#F5F5F5&#x27;,</span><br><span class="line">&#x27;yellow&#x27;:               &#x27;#FFFF00&#x27;,</span><br><span class="line">&#x27;yellowgreen&#x27;:          &#x27;#9ACD32&#x27;&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>标记大小与颜色</strong></p><p>我们可以自定义标记的大小与颜色，使用的参数分别是：</p><ul><li>markersize，简写为 <strong>ms</strong>：定义标记的大小。</li><li>markerfacecolor，简写为 <strong>mfc</strong>：定义标记内部的颜色。</li><li>markeredgecolor，简写为 <strong>mec</strong>：定义标记边框的颜色。</li></ul><p>设置标记大小：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">ypoints = np.array([<span class="number">6</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">10</span>])</span><br><span class="line"> </span><br><span class="line">plt.plot(ypoints, marker=<span class="string">&#x27;o&#x27;</span>, ms=<span class="number">20</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/abd593a5c05c425fb32f2d22a8330012.png" alt="img"></p><p> 设置标记外边框颜色：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">ypoints = np.array([<span class="number">6</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">10</span>])</span><br><span class="line"> </span><br><span class="line">plt.plot(ypoints, marker=<span class="string">&#x27;o&#x27;</span>, ms=<span class="number">20</span>, mec=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b5a92bf7a3d24958a97dad4bff724ae4.png" alt="img"></p><p> 设置标记内部颜色：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">ypoints = np.array([<span class="number">6</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">10</span>])</span><br><span class="line"> </span><br><span class="line">plt.plot(ypoints, marker=<span class="string">&#x27;o&#x27;</span>, ms=<span class="number">20</span>, mfc=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7232c3cacfd9461b815af404cc7fd2ec.png" alt="img"></p><p> 自定义标记内部与边框的颜色：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">ypoints = np.array([<span class="number">6</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">10</span>])</span><br><span class="line">plt.plot(ypoints, marker=<span class="string">&#x27;o&#x27;</span>, ms=<span class="number">20</span>, mec=<span class="string">&#x27;r&#x27;</span>, mfc=<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f7b2defff22d40b0b7f8e1225d96b82b.png" alt="img"></p><h3 id="2-2-Windows字体中英文名称对照"><a href="#2-2-Windows字体中英文名称对照" class="headerlink" title="2.2 Windows字体中英文名称对照"></a>2.2 Windows字体中英文名称对照</h3><table><thead><tr><th><strong>中文名称</strong></th><th><strong>英文名称</strong></th></tr></thead><tbody><tr><td>黑体</td><td>SimHei</td></tr><tr><td>微软雅黑</td><td>Microsoft YaHei</td></tr><tr><td>微软雅黑</td><td>Microsoft YaHei</td></tr><tr><td>新宋体</td><td>NSimSun</td></tr><tr><td>新细明体</td><td>PMingLiU</td></tr><tr><td>细明体</td><td>MingLiU</td></tr><tr><td>标楷体</td><td>DFKai-SB</td></tr><tr><td>仿宋</td><td>FangSong</td></tr><tr><td>楷体</td><td>KaiTi</td></tr><tr><td>仿宋_GB2312</td><td>FangSong_GB2312</td></tr><tr><td>楷体_GB2312</td><td>KaiTi_GB2312</td></tr></tbody></table><h2 id="三、基本绘图"><a href="#三、基本绘图" class="headerlink" title="三、基本绘图"></a>三、基本绘图</h2><h3 id="3-1-折线图"><a href="#3-1-折线图" class="headerlink" title="3.1 折线图"></a>3.1 <a href="https://so.csdn.net/so/search?q=%E6%8A%98%E7%BA%BF%E5%9B%BE&spm=1001.2101.3001.7020">折线图</a></h3><p><a href="https://so.csdn.net/so/search?q=plot&spm=1001.2101.3001.7020">plot</a>()函数画出一系列的点，并且用线将它们连接起来。看下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, np.pi)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create the figure and axes objects</span></span><br><span class="line">fig, (ax1, ax2, ax3) = plt.subplots(<span class="number">3</span>, <span class="number">1</span>, figsize=(<span class="number">8</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot y_sin on ax1</span></span><br><span class="line">ax1.plot(x, y_sin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot y_sin on ax2 with green circles, dashed lines, and larger markers</span></span><br><span class="line">ax2.plot(x, y_sin, <span class="string">&#x27;go--&#x27;</span>, linewidth=<span class="number">2</span>, markersize=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot y_cos on ax3 with red plus markers and dashed lines</span></span><br><span class="line">ax3.plot(x, y_cos, color=<span class="string">&#x27;red&#x27;</span>, marker=<span class="string">&#x27;+&#x27;</span>, linestyle=<span class="string">&#x27;dashed&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Display the plots</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230914193259068.png" alt="image-20230914193259068"></p><p>在上面的三个Axes上作画。plot，前面两个参数为x轴、y轴数据。ax2的第三个参数是 MATLAB风格的绘图，对应ax3上的颜色，marker，线型。</p><p> 另外，我们可以通过关键字参数的方式绘图，如下例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">200</span>)</span><br><span class="line">data_obj = &#123;<span class="string">&#x27;x&#x27;</span>: x,</span><br><span class="line">            <span class="string">&#x27;y1&#x27;</span>: <span class="number">2</span> * x + <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;y2&#x27;</span>: <span class="number">3</span> * x + <span class="number">1.2</span>,</span><br><span class="line">            <span class="string">&#x27;mean&#x27;</span>: <span class="number">0.5</span> * x * np.cos(<span class="number">2</span>*x) + <span class="number">2.5</span> * x + <span class="number">1.1</span>&#125;</span><br><span class="line"> </span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"> </span><br><span class="line"><span class="comment">#填充两条线之间的颜色</span></span><br><span class="line">ax.fill_between(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y1&#x27;</span>, <span class="string">&#x27;y2&#x27;</span>, color=<span class="string">&#x27;yellow&#x27;</span>, data=data_obj)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Plot the &quot;centerline&quot; with `plot`</span></span><br><span class="line">ax.plot(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>, color=<span class="string">&#x27;black&#x27;</span>, data=data_obj)</span><br><span class="line"> </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c2810644cd574927a15be41722ace8e1.png" alt="img"></p><p>发现上面的作图，在数据部分只传入了字符串，这些字符串对一个这 data_obj 中的关键字，当以这种方式作画时，将会在传入给 data 中寻找对应关键字的数据来绘图。 </p><h3 id="3-2-散点图"><a href="#3-2-散点图" class="headerlink" title="3.2 散点图"></a>3.2 散点图</h3><p>只画点，不用线连接起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">x = np.arange(<span class="number">10</span>)</span><br><span class="line">y = np.random.randn(<span class="number">10</span>)</span><br><span class="line">plt.scatter(x, y, color=<span class="string">&#x27;red&#x27;</span>, marker=<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7d2af83e021844b8b477e8ed681157ce.png" alt="img"></p><h3 id="3-3-双轴图"><a href="#3-3-双轴图" class="headerlink" title="3.3 双轴图"></a>3.3 双轴图</h3><p>在一些应用场景中，有时需要绘制两个 x 轴或两个 y 轴，这样可以更直观地显现图像，从而获取更有效的数据。Matplotlib 提供的 twinx() 和 twiny() 函数，除了可以实现绘制双轴的功能外，还可以使用不同的单位来绘制曲线，比如一个轴绘制对函数，另外一个轴绘制指数函数。 </p><p>下面示例绘制了一个具有两个 y 轴的图形，一个显示正弦函数 sin(x)，另一个显示对数函数 log(x)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 准备数据</span></span><br><span class="line">t = np.arange(<span class="number">0.01</span>, <span class="number">10.0</span>, <span class="number">0.01</span>)</span><br><span class="line">data1 = np.exp(t)</span><br><span class="line">data2 = np.sin(<span class="number">2</span> * np.pi * t)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置主轴</span></span><br><span class="line">fig, ax1 = plt.subplots()</span><br><span class="line"> </span><br><span class="line">color = <span class="string">&#x27;tab:red&#x27;</span></span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;time (s)&#x27;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&#x27;exp&#x27;</span>, color=color)</span><br><span class="line">ax1.plot(t, data1, color=color)</span><br><span class="line">ax1.tick_params(axis=<span class="string">&#x27;y&#x27;</span>, labelcolor=color)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置次轴</span></span><br><span class="line">ax2 = ax1.twinx()</span><br><span class="line"> </span><br><span class="line">color = <span class="string">&#x27;tab:blue&#x27;</span></span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;sin&#x27;</span>, color=color)</span><br><span class="line">ax2.plot(t, data2, color=color)</span><br><span class="line">ax2.tick_params(axis=<span class="string">&#x27;y&#x27;</span>, labelcolor=color)</span><br><span class="line"> </span><br><span class="line">fig.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7b394f20476748538f5d60541dcf546e.png" alt="img"></p><h3 id="3-4-条形图"><a href="#3-4-条形图" class="headerlink" title="3.4 条形图"></a>3.4 条形图</h3><p> 条形图分两种，一种是水平的，一种是垂直的，见下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">x = np.arange(<span class="number">5</span>)</span><br><span class="line">y = np.random.randn(<span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, figsize=plt.figaspect(<span class="number">1.</span>/<span class="number">2</span>))</span><br><span class="line"> </span><br><span class="line">vert_bars = axes[<span class="number">0</span>].bar(x, y, color=<span class="string">&#x27;lightblue&#x27;</span>, align=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">horiz_bars = axes[<span class="number">1</span>].barh(x, y, color=<span class="string">&#x27;lightblue&#x27;</span>, align=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"><span class="comment">#在水平或者垂直方向上画线</span></span><br><span class="line">axes[<span class="number">0</span>].axhline(<span class="number">0</span>, color=<span class="string">&#x27;gray&#x27;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">axes[<span class="number">1</span>].axvline(<span class="number">0</span>, color=<span class="string">&#x27;gray&#x27;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f974b4cf7fa2466eb2a71980aba1f24a.png" alt="img"></p><p>条形图还返回了一个Artists 数组，对应着每个条形，例如上图 Artists 数组的大小为5，我们可以通过这些 Artists 对条形图的样式进行更改，如下例： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line">vert_bars = ax.bar(x, y, color=<span class="string">&#x27;lightblue&#x27;</span>, align=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># We could have also done this with two separate calls to `ax.bar` and numpy boolean indexing.</span></span><br><span class="line"><span class="keyword">for</span> bar, height <span class="keyword">in</span> <span class="built_in">zip</span>(vert_bars, y):</span><br><span class="line">    <span class="keyword">if</span> height &lt; <span class="number">0</span>:</span><br><span class="line">        bar.<span class="built_in">set</span>(edgecolor=<span class="string">&#x27;darkred&#x27;</span>, color=<span class="string">&#x27;salmon&#x27;</span>, linewidth=<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f764d1ee17974ad38bd2b033482a9ac8.png" alt="img"></p><h3 id="3-5-直方图"><a href="#3-5-直方图" class="headerlink" title="3.5 直方图"></a>3.5 直方图</h3><p> 直方图用于统计数据出现的次数或者频率，有多种参数可以调整，见下例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">np.random.seed(<span class="number">19680801</span>)</span><br><span class="line"> </span><br><span class="line">n_bins = <span class="number">10</span></span><br><span class="line">x = np.random.randn(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">fig, axes = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">2</span>)</span><br><span class="line">ax0, ax1, ax2, ax3 = axes.flatten()</span><br><span class="line"> </span><br><span class="line">colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;tan&#x27;</span>, <span class="string">&#x27;lime&#x27;</span>]</span><br><span class="line">ax0.hist(x, n_bins, density=<span class="literal">True</span>, histtype=<span class="string">&#x27;bar&#x27;</span>, color=colors, label=colors)</span><br><span class="line">ax0.legend(prop=&#123;<span class="string">&#x27;size&#x27;</span>: <span class="number">10</span>&#125;)</span><br><span class="line">ax0.set_title(<span class="string">&#x27;bars with legend&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">ax1.hist(x, n_bins, density=<span class="literal">True</span>, histtype=<span class="string">&#x27;barstacked&#x27;</span>)</span><br><span class="line">ax1.set_title(<span class="string">&#x27;stacked bar&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">ax2.hist(x,  histtype=<span class="string">&#x27;barstacked&#x27;</span>, rwidth=<span class="number">0.9</span>)</span><br><span class="line"> </span><br><span class="line">ax3.hist(x[:, <span class="number">0</span>], rwidth=<span class="number">0.9</span>)</span><br><span class="line">ax3.set_title(<span class="string">&#x27;different sample sizes&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">fig.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>参数中density控制Y轴是概率还是数量，与返回的第一个的变量对应。histtype控制着直方图的样式，默认是 ‘bar’，对于多个条形时就相邻的方式呈现如子图1， ‘barstacked’ 就是叠在一起，如子图2、3。 rwidth 控制着宽度，这样可以空出一些间隙，比较图2、3. 图4是只有一条数据时。<br><img src="https://img-blog.csdnimg.cn/260f1fdc61f64205ae96e21ec0920ab0.png" alt="img">​</p><h3 id="3-6-饼图"><a href="#3-6-饼图" class="headerlink" title="3.6 饼图"></a>3.6 饼图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">labels = <span class="string">&#x27;Frogs&#x27;</span>, <span class="string">&#x27;Hogs&#x27;</span>, <span class="string">&#x27;Dogs&#x27;</span>, <span class="string">&#x27;Logs&#x27;</span></span><br><span class="line">sizes = [<span class="number">15</span>, <span class="number">30</span>, <span class="number">45</span>, <span class="number">10</span>]</span><br><span class="line">explode = (<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># only &quot;explode&quot; the 2nd slice (i.e. &#x27;Hogs&#x27;)</span></span><br><span class="line"> </span><br><span class="line">fig1, (ax1, ax2) = plt.subplots(<span class="number">2</span>)</span><br><span class="line">ax1.pie(sizes, labels=labels, autopct=<span class="string">&#x27;%1.1f%%&#x27;</span>, shadow=<span class="literal">True</span>)</span><br><span class="line">ax1.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">ax2.pie(sizes, autopct=<span class="string">&#x27;%1.2f%%&#x27;</span>, shadow=<span class="literal">True</span>, startangle=<span class="number">90</span>, explode=explode,</span><br><span class="line">    pctdistance=<span class="number">1.12</span>)</span><br><span class="line">ax2.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">ax2.legend(labels=labels, loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/348bb127e6dc47d6ae91e6db4d79c719.png" alt="img"></p><h3 id="3-7-箱形图"><a href="#3-7-箱形图" class="headerlink" title="3.7 箱形图"></a>3.7 箱形图</h3><p>箱型图（也称为盒须图）于 1977 年由美国著名统计学家<strong>约翰·图基</strong>（John Tukey）发明。它能显示出一组数据的最大值、最小值、中位数、及上下四分位数。</p><p>在箱型图中，我们从上四分位数到下四分位数绘制一个盒子，然后用一条垂直触须（形象地称为“盒须”）穿过盒子的中间。上垂线延伸至上边缘（最大值），下垂线延伸至下边缘（最小值）。箱型图结构如下所示：</p><p><img src="https://img-blog.csdnimg.cn/2311b20338304d9aa4d1bbe1adc31f0d.png" alt="img"></p><p>首先准备创建箱型图所需数据：可以使用<code>numpy.random.normal()</code>函数来创建一组基于正态分布的随机数据，该函数有三个参数，分别是正态分布的平均值、标准差以及期望值的数量然后用 data_to_plot 变量指定创建箱型图所需的数据序列，最后用 boxplot() 函数绘制箱型图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 利用随机数种子使每次生成的随机数相同</span></span><br><span class="line">np.random.seed(<span class="number">10</span>)</span><br><span class="line">collectn_1 = np.random.normal(<span class="number">100</span>, <span class="number">10</span>, <span class="number">200</span>)</span><br><span class="line">collectn_2 = np.random.normal(<span class="number">80</span>, <span class="number">30</span>, <span class="number">200</span>)</span><br><span class="line">collectn_3 = np.random.normal(<span class="number">90</span>, <span class="number">20</span>, <span class="number">200</span>)</span><br><span class="line">collectn_4 = np.random.normal(<span class="number">70</span>, <span class="number">25</span>, <span class="number">200</span>)</span><br><span class="line">data_to_plot = [collectn_1, collectn_2, collectn_3, collectn_4]</span><br><span class="line"> </span><br><span class="line">fig = plt.figure()</span><br><span class="line"><span class="comment"># 创建绘图区域</span></span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"><span class="comment"># 创建箱型图</span></span><br><span class="line">bp = ax.boxplot(data_to_plot)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/8e54f554d3ba49469e9733b138a3ce87.png" alt="img"></p><h3 id="3-8-泡泡图"><a href="#3-8-泡泡图" class="headerlink" title="3.8 泡泡图"></a>3.8 泡泡图</h3><p>散点图的一种，加入了第三个值 s 可以理解成普通散点，画的是二维，泡泡图体现了Z的大小，如下例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">np.random.seed(<span class="number">19680801</span>)</span><br><span class="line"> </span><br><span class="line">N = <span class="number">50</span></span><br><span class="line">x = np.random.rand(N)</span><br><span class="line">y = np.random.rand(N)</span><br><span class="line">colors = np.random.rand(N)</span><br><span class="line">area = (<span class="number">30</span> * np.random.rand(N))**<span class="number">2</span>  <span class="comment"># 0 to 15 point radii</span></span><br><span class="line"> </span><br><span class="line">plt.scatter(x, y, s=area, c=colors, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/98995ca3c24143e8bf6a8acaa6de8176.png" alt="img"></p><h3 id="3-9-等高线图（轮廓图）"><a href="#3-9-等高线图（轮廓图）" class="headerlink" title="3.9 等高线图（轮廓图）"></a>3.9 等高线图（轮廓图）</h3><p>等高线图（也称“水平图”）是一种在二维平面上显示 3D 图像的方法。等高线有时也被称为 “Z 切片”，如果您想要查看因变量 Z 与自变量 X、Y 之间的函数图像变化（即 Z&#x3D;f(X,Y)），那么采用等高线图最为直观。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">np.linspace()在指定的大间隔内[-4.0,4.0]，返回固定间隔100个数据</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">x = np.linspace(-<span class="number">4.0</span>, <span class="number">4.0</span>, <span class="number">100</span>)</span><br><span class="line">y = np.linspace(-<span class="number">4.0</span>, <span class="number">4.0</span>, <span class="number">100</span>)</span><br><span class="line"> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">np.meshgrid()两个坐标轴上的点在平面上画格,产生一个以向量x为行，向量y为列的矩</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义Z与X,Y之间的关系,即原方程x²+y²=r²</span></span><br><span class="line">Z = np.sqrt(X ** <span class="number">2</span> + Y ** <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">16</span>, <span class="number">9</span>))</span><br><span class="line"> </span><br><span class="line">axes[<span class="number">0</span>].contour(X, Y, Z, alpha=<span class="number">0.75</span>, cmap=plt.cm.hot)</span><br><span class="line"> </span><br><span class="line">cp = axes[<span class="number">1</span>].contourf(X, Y, Z, cmap=plt.cm.hot)</span><br><span class="line"> </span><br><span class="line">fig.colorbar(cp)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/cf6723c75f1543aeb82eac3e2f58b373.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;一、初识Matploblib&quot;&gt;&lt;a href=&quot;#一、初识Matploblib&quot; class=&quot;headerlink&quot; title=&quot;一、初识Matploblib&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="后端" scheme="http://cjx_0723.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Python" scheme="http://cjx_0723.gitee.io/tags/Python/"/>
    
    <category term="Python工具包" scheme="http://cjx_0723.gitee.io/tags/Python%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记</title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/Python/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/Python/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-30T14:04:29.037Z</published>
    <updated>2023-10-30T14:04:29.037Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://www.runoob.com/python/python-operators.html">笔记原地址</a></p><h1 id="Python运算符"><a href="#Python运算符" class="headerlink" title="Python运算符"></a>Python运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>以下假设变量： <strong>a&#x3D;10，b&#x3D;20</strong>：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加 - 两个对象相加</td><td align="left">a + b 输出结果 30</td></tr><tr><td align="left">-</td><td align="left">减 - 得到负数或是一个数减去另一个数</td><td align="left">a - b 输出结果 -10</td></tr><tr><td align="left">*</td><td align="left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td align="left">a * b 输出结果 200</td></tr><tr><td align="left">&#x2F;</td><td align="left">除 - x除以y</td><td align="left">b &#x2F; a 输出结果 2</td></tr><tr><td align="left">%</td><td align="left">取模 - 返回除法的余数</td><td align="left">b % a 输出结果 0</td></tr><tr><td align="left"><font color='red'>**</font></td><td align="left">幂 - 返回x的y次幂</td><td align="left">a**b 为10的20次方， 输出结果 100000000000000000000</td></tr><tr><td align="left"><strong><font color='red'>&#x2F;&#x2F;</font></strong></td><td align="left">取整除 - 返回商的整数部分（<strong>向下取整</strong>）</td><td align="left">&gt;&gt;&gt; 9&#x2F;&#x2F;2 <br />4 <br />&gt;&gt;&gt; -9&#x2F;&#x2F;2<br />-5</td></tr></tbody></table><blockquote><p><strong>注意：</strong>Python2.x 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1/2</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; 1.0/2</span><br><span class="line">0.5</span><br><span class="line">&gt;&gt;&gt; 1/float(2)</span><br><span class="line">0.5</span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>以下假设变量a为10，变量b为20：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&#x3D;&#x3D;</td><td align="left">等于 - 比较对象是否相等</td><td align="left">(a &#x3D;&#x3D; b) 返回 False。</td></tr><tr><td align="left">!&#x3D;</td><td align="left">不等于 - 比较两个对象是否不相等</td><td align="left">(a !&#x3D; b) 返回 True。</td></tr><tr><td align="left">&lt;&gt;</td><td align="left">不等于 - 比较两个对象是否不相等。**<font color='red'>python3 已废弃</font>。**</td><td align="left">(a &lt;&gt; b) 返回 True。这个运算符类似 !&#x3D; 。</td></tr><tr><td align="left">&gt;</td><td align="left">大于 - 返回x是否大于y</td><td align="left">(a &gt; b) 返回 False。</td></tr><tr><td align="left">&lt;</td><td align="left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量 True 和 False 等价。</td><td align="left">(a &lt; b) 返回 True。</td></tr><tr><td align="left">&gt;&#x3D;</td><td align="left">大于等于 - 返回x是否大于等于y。</td><td align="left">(a &gt;&#x3D; b) 返回 False。</td></tr><tr><td align="left">&lt;&#x3D;</td><td align="left">小于等于 - 返回x是否小于等于y。</td><td align="left">(a &lt;&#x3D; b) 返回 True。</td></tr></tbody></table><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>以下假设变量a为10，变量b为20：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left">简单的赋值运算符</td><td align="left">c &#x3D; a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td align="left">+&#x3D;</td><td align="left">加法赋值运算符</td><td align="left">c +&#x3D; a 等效于 c &#x3D; c + a</td></tr><tr><td align="left">-&#x3D;</td><td align="left">减法赋值运算符</td><td align="left">c -&#x3D; a 等效于 c &#x3D; c - a</td></tr><tr><td align="left">*&#x3D;</td><td align="left">乘法赋值运算符</td><td align="left">c *&#x3D; a 等效于 c &#x3D; c * a</td></tr><tr><td align="left">&#x2F;&#x3D;</td><td align="left">除法赋值运算符</td><td align="left">c &#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F; a</td></tr><tr><td align="left">%&#x3D;</td><td align="left">取模赋值运算符</td><td align="left">c %&#x3D; a 等效于 c &#x3D; c % a</td></tr><tr><td align="left">**&#x3D;</td><td align="left">幂赋值运算符</td><td align="left">c **&#x3D; a 等效于 c &#x3D; c ** a</td></tr><tr><td align="left">&#x2F;&#x2F;&#x3D;</td><td align="left">取整除赋值运算符</td><td align="left">c &#x2F;&#x2F;&#x3D; a 等效于 c &#x3D; c &#x2F;&#x2F; a</td></tr></tbody></table><blockquote><p>注意：**<font color='red'>Python 中没有 ++ 或 – 自运算符</font>**</p><p>因为在 Python 里的数值和字符串之类的都是不可变对象，对不可变对象操作的结果都会生成一个新的对象。</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br><span class="line">a += 1</span><br></pre></td></tr></table></figure><p>在 C&#x2F;java 之类的语言中，把 a 指向内存地址单元数据值由 1 改成了 2。</p><p>但是在 Python 中是完全不同的另一套机制。</p><p>解释器创建一个新的整数对象 2。</p><p>然后把这个对象的地址再次分配给 a。</p><p>见下面代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; id(1)</span><br><span class="line">41116008L</span><br><span class="line">&gt;&gt;&gt; a = 1</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">41116008L</span><br><span class="line">&gt;&gt;&gt; id(2)</span><br><span class="line">41115984L</span><br><span class="line">&gt;&gt;&gt;a += 1</span><br><span class="line">&gt;&gt;&gt; id(a)</span><br><span class="line">41115984L</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure><p>所以在 Python 中不可能出现C&#x2F;java 之类那种单独一行一个 <strong>i++<strong>，</strong>i–</strong> 的。</p></blockquote><hr><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：</p><p>下表中变量 a 为 60，b 为 13，二进制格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = 0011 1100</span><br><span class="line"></span><br><span class="line">b = 0000 1101</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">a&amp;b = 0000 1100</span><br><span class="line"></span><br><span class="line">a|b = 0011 1101</span><br><span class="line"></span><br><span class="line">a^b = 0011 0001</span><br><span class="line"></span><br><span class="line">~a  = 1100 0011</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td><td align="left">(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr><td align="left">|</td><td align="left">按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td><td align="left">(a | b) 输出结果 61 ，二进制解释： 0011 1101</td></tr><tr><td align="left">^</td><td align="left">按位异或运算符：当两对应的二进位相异时，结果为1</td><td align="left">(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr><td align="left">~</td><td align="left">按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。**~x** 类似于 <strong>-x-1</strong></td><td align="left">(~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移动运算符：运算数的各二进位全部左移若干位，由 <strong>&lt;&lt;</strong> 右边的数字指定了移动的位数，高位丢弃，低位补0。</td><td align="left">a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移动运算符：把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，**&gt;&gt;** 右边的数字指定了移动的位数</td><td align="left">a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td></tr></tbody></table><hr><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p><table><thead><tr><th align="left">运算符</th><th align="left">逻辑表达式</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">and</td><td align="left">x and y</td><td align="left">布尔”与” - 如果 x 为 False，x and y 返回 False，否则它<strong>返回 y 的计算</strong>值。</td><td align="left">(a and b) 返回 20。</td></tr><tr><td align="left">or</td><td align="left">x or y</td><td align="left">布尔”或” - 如果 x 是非 0，它返回 x 的计算值，否则它<strong>返回 y 的计算值</strong>。</td><td align="left">(a or b) 返回 10。</td></tr><tr><td align="left">not</td><td align="left">not x</td><td align="left">布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td align="left">not(a and b) 返回 False</td></tr></tbody></table><p>Python中并没有<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>逻辑符号</p><hr><h2 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h2><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">in</td><td align="left">如果在指定的序列中找到值返回 True，否则返回 False。</td><td align="left">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td align="left">not in</td><td align="left">如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td align="left">x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><p>以下实例演示了Python所有成员运算符的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">in</span> <span class="built_in">list</span> ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;1 - 变量 a 在给定的列表中 list 中&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;1 - 变量 a 不在给定的列表中 list 中&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( b <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span> ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;2 - 变量 b 不在给定的列表中 list 中&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;2 - 变量 b 在给定的列表中 list 中&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 修改变量 a 的值</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">in</span> <span class="built_in">list</span> ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;3 - 变量 a 在给定的列表中 list 中&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;3 - 变量 a 不在给定的列表中 list 中&quot;</span></span><br></pre></td></tr></table></figure><h2 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h2><p>身份运算符用于比较两个对象的存储单元</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">is</td><td align="left">is 是判断两个标识符是不是引用自一个对象</td><td align="left"><strong>x is y</strong>, 类似 <strong>id(x) &#x3D;&#x3D; id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td align="left">is not</td><td align="left">is not 是判断两个标识符是不是引用自不同对象</td><td align="left"><strong>x is not y</strong> ， 类似 **id(a) !&#x3D; id(b)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table><p><strong>注：</strong> <a href="https://www.runoob.com/python/python-func-id.html">id()</a> 函数用于返回对象内存地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> b ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;1 - a 和 b 有相同的标识&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;1 - a 和 b 没有相同的标识&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> <span class="keyword">not</span> b ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;2 - a 和 b 没有相同的标识&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;2 - a 和 b 有相同的标识&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 修改变量 b 的值</span></span><br><span class="line">b = <span class="number">30</span></span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> b ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;3 - a 和 b 有相同的标识&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;3 - a 和 b 没有相同的标识&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> <span class="keyword">not</span> b ):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;4 - a 和 b 没有相同的标识&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;4 - a 和 b 有相同的标识&quot;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 - a 和 b 有相同的标识</span><br><span class="line">2 - a 和 b 有相同的标识</span><br><span class="line">3 - a 和 b 没有相同的标识</span><br><span class="line">4 - a 和 b 没有相同的标识</span><br></pre></td></tr></table></figure><p>不难发现，对于基础类型变量，使用<code>=</code>的赋值其实是传递右侧变量的引用，没有创建新的数据。</p><blockquote><p>is 与 &#x3D;&#x3D; 区别：</p><p>is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， &#x3D;&#x3D; 用于判断引用变量的值是否相等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; b = a</span><br><span class="line">&gt;&gt;&gt; b is a </span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; b == a</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; b = a[:]</span><br><span class="line">&gt;&gt;&gt; b is a</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; b == a</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>主要：<code>b = a</code> 传递引用，而 <code>b = a[:]</code>拷贝了列表a的值，产生了新的对象。</p></blockquote><hr><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>以下表格列出了从最高到最低优先级的所有运算符：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">**</td><td align="left">指数 (最高优先级)</td></tr><tr><td align="left">~ + -</td><td align="left">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td></tr><tr><td align="left">* &#x2F; % &#x2F;&#x2F;</td><td align="left">乘，除，取模和取整除</td></tr><tr><td align="left">+ -</td><td align="left">加法减法</td></tr><tr><td align="left">&gt;&gt; &lt;&lt;</td><td align="left">右移，左移运算符</td></tr><tr><td align="left">&amp;</td><td align="left">位 ‘AND’</td></tr><tr><td align="left">^ |</td><td align="left">位运算符</td></tr><tr><td align="left">&lt;&#x3D; &lt; &gt; &gt;&#x3D;</td><td align="left">比较运算符</td></tr><tr><td align="left">&lt;&gt; &#x3D;&#x3D; !&#x3D;</td><td align="left">等于运算符</td></tr><tr><td align="left">&#x3D; %&#x3D; &#x2F;&#x3D; &#x2F;&#x2F;&#x3D; -&#x3D; +&#x3D; *&#x3D; **&#x3D;</td><td align="left">赋值运算符</td></tr><tr><td align="left">is is not</td><td align="left">身份运算符</td></tr><tr><td align="left">in not in</td><td align="left">成员运算符</td></tr><tr><td align="left">not and or</td><td align="left">逻辑运算符</td></tr></tbody></table><h1 id="Python程序控制符"><a href="#Python程序控制符" class="headerlink" title="Python程序控制符"></a>Python程序控制符</h1><h2 id="if-and-else"><a href="#if-and-else" class="headerlink" title="if and else"></a>if and else</h2><p>Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false。</p><p>Python 编程中 if 语句用于控制程序的执行，基本形式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 判断条件：</span><br><span class="line">    执行语句……</span><br><span class="line">else：</span><br><span class="line">    执行语句……</span><br></pre></td></tr></table></figure><p>其中”判断条件”成立时（非零），则执行后面的语句，而执行内容可以多行，以缩进来区分表示同一范围。</p><p>else 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句。</p><p>Gif 演示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/05/006faQNTgw1f5wnm0mcxrg30ci07o47l.gif" alt="img"></p><p>具体例子如下：</p><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 例1：if 基本用法</span></span><br><span class="line"> </span><br><span class="line">flag = <span class="literal">False</span></span><br><span class="line">name = <span class="string">&#x27;luren&#x27;</span></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&#x27;python&#x27;</span>:         <span class="comment"># 判断变量是否为 python </span></span><br><span class="line">    flag = <span class="literal">True</span>              <span class="comment"># 条件成立时设置标志为真</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;welcome boss&#x27;</span>     <span class="comment"># 并输出欢迎信息</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> name               <span class="comment"># 条件不成立时输出变量名称</span></span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">luren            # 输出结果</span><br></pre></td></tr></table></figure><p>if 语句的判断条件可以用&gt;（大于）、&lt;(小于)、&#x3D;&#x3D;（等于）、&gt;&#x3D;（大于等于）、&lt;&#x3D;（小于等于）来表示其关系。</p><p>当判断条件为多个值时，可以使用以下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if 判断条件1:</span><br><span class="line">    执行语句1……</span><br><span class="line">elif 判断条件2:</span><br><span class="line">    执行语句2……</span><br><span class="line">elif 判断条件3:</span><br><span class="line">    执行语句3……</span><br><span class="line">else:</span><br><span class="line">    执行语句4……</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment"># 例2：elif用法</span></span><br><span class="line"> </span><br><span class="line">num = <span class="number">5</span>     </span><br><span class="line"><span class="keyword">if</span> num == <span class="number">3</span>:            <span class="comment"># 判断num的值</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;boss&#x27;</span>        </span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;user&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;worker&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> num &lt; <span class="number">0</span>:           <span class="comment"># 值小于零时输出</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;error&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;roadman&#x27;</span>     <span class="comment"># 条件均不成立时输出</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roadman        # 输出结果</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。</p></blockquote><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>for循环的语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> iterating_var <span class="keyword">in</span> sequence:</span><br><span class="line">   statements(s)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">&#x27;Python&#x27;</span>:     <span class="comment"># 第一个实例</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;当前字母: %s&quot;</span> % letter)</span><br><span class="line"> </span><br><span class="line">fruits = [<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>,  <span class="string">&#x27;mango&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> fruits:        <span class="comment"># 第二个实例</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&#x27;当前水果: %s&#x27;</span>% fruit)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Good bye!&quot;</span>)</span><br></pre></td></tr></table></figure><p>以上实例输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">当前字母: P</span><br><span class="line">当前字母: y</span><br><span class="line">当前字母: t</span><br><span class="line">当前字母: h</span><br><span class="line">当前字母: o</span><br><span class="line">当前字母: n</span><br><span class="line">当前水果: banana</span><br><span class="line">当前水果: apple</span><br><span class="line">当前水果: mango</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>Python 编程中 while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。其基本形式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while 判断条件(condition)：</span><br><span class="line">    执行语句(statements)……</span><br></pre></td></tr></table></figure><p>执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空（null）的值均为true。</p><p>当判断条件假 false 时，循环结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"> </span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">9</span>):</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&#x27;The count is:&#x27;</span>, count</span><br><span class="line">   count = count + <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Good bye!&quot;</span></span><br></pre></td></tr></table></figure><p>以上代码执行输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">The count is: 0</span><br><span class="line">The count is: 1</span><br><span class="line">The count is: 2</span><br><span class="line">The count is: 3</span><br><span class="line">The count is: 4</span><br><span class="line">The count is: 5</span><br><span class="line">The count is: 6</span><br><span class="line">The count is: 7</span><br><span class="line">The count is: 8</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure><p>while 语句时还有另外两个重要的命令 continue，break 来跳过循环，continue 用于跳过该次循环，break 则是用于退出循环，此外”判断条件”还可以是个常值，表示循环必定成立.</p><p>在 python 中，while … else 在循环条件为 false 时执行 else 语句块：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"> </span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">   <span class="built_in">print</span> count, <span class="string">&quot; is  less than 5&quot;</span></span><br><span class="line">   count = count + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span> count, <span class="string">&quot; is not less than 5&quot;</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 is less than 5</span><br><span class="line">1 is less than 5</span><br><span class="line">2 is less than 5</span><br><span class="line">3 is less than 5</span><br><span class="line">4 is less than 5</span><br><span class="line">5 is not less than 5</span><br></pre></td></tr></table></figure><h2 id="Pass"><a href="#Pass" class="headerlink" title="Pass"></a>Pass</h2><p>Python pass 是空语句，是为了保持程序结构的完整性。</p><p><strong>pass</strong> 不做任何事情，一般用做占位语句。</p><p>Python 语言 pass 语句语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pass</span><br></pre></td></tr></table></figure><p>测试实例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*- </span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出 Python 的每个字母</span></span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">&#x27;Python&#x27;</span>:</span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;这是 pass 块&#x27;</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&#x27;当前字母 :&#x27;</span>, letter</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Good bye!&quot;</span></span><br></pre></td></tr></table></figure><p>以上实例执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当前字母 : P</span><br><span class="line">当前字母 : y</span><br><span class="line">当前字母 : t</span><br><span class="line">这是 pass 块</span><br><span class="line">当前字母 : h</span><br><span class="line">当前字母 : o</span><br><span class="line">当前字母 : n</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure><p>在 Python 中有时候会看到一个 def 函数:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sample</span>(<span class="params">n_samples</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>该处的 pass 便是占据一个位置，因为如果定义一个空函数程序会报错，当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。</p><h1 id="Python变量及其操作"><a href="#Python变量及其操作" class="headerlink" title="Python变量及其操作"></a>Python变量及其操作</h1><p>Python有五个标准的数据类型：</p><ul><li>Numbers（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Dictionary（字典）</li></ul><p>可以使用<code>del</code>语句删除一些 对象引用。</p><p>del语句的语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del var1[,var2[,var3[....,varN]]]]</span><br></pre></td></tr></table></figure><p>可以通过使用del语句删除单个或多个对象，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">del var</span><br><span class="line">del var_a, var_b</span><br></pre></td></tr></table></figure><h2 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h2><h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><p>Python 支持四种不同的数值类型：</p><ul><li><strong>整型(Int)</strong> - 通常被称为是整型或整数，是正或负整数，不带小数点。</li><li><strong>长整型(long integers)</strong> - 无限大小的整数，整数最后是一个大写或小写的<strong>L</strong>。</li><li><strong>浮点型(floating point real values)</strong> - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 &#x3D; 2.5 x $10^2$ &#x3D; 250）。</li><li><strong>复数(complex numbers)</strong> - 复数由实数部分和虚数部分构成，可以用<strong>a + bj</strong>,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</li></ul><h3 id="数字函数汇总"><a href="#数字函数汇总" class="headerlink" title="数字函数汇总"></a>数字函数汇总</h3><h4 id="math-模块、cmath-模块"><a href="#math-模块、cmath-模块" class="headerlink" title="math 模块、cmath 模块"></a>math 模块、cmath 模块</h4><p>Python 中数学运算常用的函数基本都在 math 模块、cmath 模块中。</p><p>cmath 模块的函数跟 math 模块函数基本一致，区别是 <strong>cmath 模块运算的是复数，math 模块运算的是数学运算</strong>。</p><p>要使用 math 或 cmath 函数必须先导入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import math,cmath</span><br></pre></td></tr></table></figure><p>查看 math 查看包中的内容:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(math)</span><br><span class="line">[<span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__file__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;acos&#x27;</span>, <span class="string">&#x27;acosh&#x27;</span>, <span class="string">&#x27;asin&#x27;</span>, <span class="string">&#x27;asinh&#x27;</span>, <span class="string">&#x27;atan&#x27;</span>, <span class="string">&#x27;atan2&#x27;</span>, <span class="string">&#x27;atanh&#x27;</span>, <span class="string">&#x27;ceil&#x27;</span>, <span class="string">&#x27;copysign&#x27;</span>, <span class="string">&#x27;cos&#x27;</span>, <span class="string">&#x27;cosh&#x27;</span>, <span class="string">&#x27;degrees&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;erf&#x27;</span>, <span class="string">&#x27;erfc&#x27;</span>, <span class="string">&#x27;exp&#x27;</span>, <span class="string">&#x27;expm1&#x27;</span>, <span class="string">&#x27;fabs&#x27;</span>, <span class="string">&#x27;factorial&#x27;</span>, <span class="string">&#x27;floor&#x27;</span>, <span class="string">&#x27;fmod&#x27;</span>, <span class="string">&#x27;frexp&#x27;</span>, <span class="string">&#x27;fsum&#x27;</span>, <span class="string">&#x27;gamma&#x27;</span>, <span class="string">&#x27;gcd&#x27;</span>, <span class="string">&#x27;hypot&#x27;</span>, <span class="string">&#x27;inf&#x27;</span>, <span class="string">&#x27;isclose&#x27;</span>, <span class="string">&#x27;isfinite&#x27;</span>, <span class="string">&#x27;isinf&#x27;</span>, <span class="string">&#x27;isnan&#x27;</span>, <span class="string">&#x27;ldexp&#x27;</span>, <span class="string">&#x27;lgamma&#x27;</span>, <span class="string">&#x27;log&#x27;</span>, <span class="string">&#x27;log10&#x27;</span>, <span class="string">&#x27;log1p&#x27;</span>, <span class="string">&#x27;log2&#x27;</span>, <span class="string">&#x27;modf&#x27;</span>, <span class="string">&#x27;nan&#x27;</span>, <span class="string">&#x27;pi&#x27;</span>, <span class="string">&#x27;pow&#x27;</span>, <span class="string">&#x27;radians&#x27;</span>, <span class="string">&#x27;sin&#x27;</span>, <span class="string">&#x27;sinh&#x27;</span>, <span class="string">&#x27;sqrt&#x27;</span>, <span class="string">&#x27;tan&#x27;</span>, <span class="string">&#x27;tanh&#x27;</span>, <span class="string">&#x27;tau&#x27;</span>, <span class="string">&#x27;trunc&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>查看 cmath 查看包中的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cmath</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(cmath)</span><br><span class="line">[<span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__file__&#x27;</span>, <span class="string">&#x27;__loader__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__package__&#x27;</span>, <span class="string">&#x27;__spec__&#x27;</span>, <span class="string">&#x27;acos&#x27;</span>, <span class="string">&#x27;acosh&#x27;</span>, <span class="string">&#x27;asin&#x27;</span>, <span class="string">&#x27;asinh&#x27;</span>, <span class="string">&#x27;atan&#x27;</span>, <span class="string">&#x27;atanh&#x27;</span>, <span class="string">&#x27;cos&#x27;</span>, <span class="string">&#x27;cosh&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;exp&#x27;</span>, <span class="string">&#x27;inf&#x27;</span>, <span class="string">&#x27;infj&#x27;</span>, <span class="string">&#x27;isclose&#x27;</span>, <span class="string">&#x27;isfinite&#x27;</span>, <span class="string">&#x27;isinf&#x27;</span>, <span class="string">&#x27;isnan&#x27;</span>, <span class="string">&#x27;log&#x27;</span>, <span class="string">&#x27;log10&#x27;</span>, <span class="string">&#x27;nan&#x27;</span>, <span class="string">&#x27;nanj&#x27;</span>, <span class="string">&#x27;phase&#x27;</span>, <span class="string">&#x27;pi&#x27;</span>, <span class="string">&#x27;polar&#x27;</span>, <span class="string">&#x27;rect&#x27;</span>, <span class="string">&#x27;sin&#x27;</span>, <span class="string">&#x27;sinh&#x27;</span>, <span class="string">&#x27;sqrt&#x27;</span>, <span class="string">&#x27;tan&#x27;</span>, <span class="string">&#x27;tanh&#x27;</span>, <span class="string">&#x27;tau&#x27;</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cmath</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmath.sqrt(-<span class="number">1</span>)</span><br><span class="line"><span class="number">1j</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmath.sqrt(<span class="number">9</span>)</span><br><span class="line">(<span class="number">3</span>+<span class="number">0j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmath.sin(<span class="number">1</span>)</span><br><span class="line">(<span class="number">0.8414709848078965</span>+<span class="number">0j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cmath.log10(<span class="number">100</span>)</span><br><span class="line">(<span class="number">2</span>+<span class="number">0j</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><table><thead><tr><th align="left">函数</th><th align="left">返回值 ( 描述 )</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python/func-number-abs.html">abs(x)</a></td><td align="left">返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-ceil.html">ceil(x)</a></td><td align="left">返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-cmp.html">cmp(x, y)</a></td><td align="left">如果 x &lt; y 返回 -1, 如果 x &#x3D;&#x3D; y 返回 0, 如果 x &gt; y 返回 1</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-exp.html">exp(x)</a></td><td align="left">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-fabs.html">fabs(x)</a></td><td align="left">以浮点数形式返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-floor.html">floor(x)</a></td><td align="left">返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-log.html">log(x)</a></td><td align="left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-log10.html">log10(x)</a></td><td align="left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-max.html">max(x1, x2,…)</a></td><td align="left">返回给定参数的最大值，参数可以为序列。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-min.html">min(x1, x2,…)</a></td><td align="left">返回给定参数的最小值，参数可以为序列。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-modf.html">modf(x)</a></td><td align="left">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-pow.html">pow(x, y)</a></td><td align="left">x**y 运算后的值。</td></tr><tr><td align="left">[round(x <a href="https://www.runoob.com/python/func-number-round.html">,n])</a></td><td align="left">返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-sqrt.html">sqrt(x)</a></td><td align="left">返回数字x的平方根</td></tr></tbody></table><h4 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h4><p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。</p><p>Python包含以下常用随机数函数：</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python/func-number-choice.html">choice(seq)</a></td><td align="left">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td></tr><tr><td align="left">[randrange (<a href="https://www.runoob.com/python/func-number-randrange.html">start,] stop [,step])</a></td><td align="left">从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-random.html">random()</a></td><td align="left">随机生成下一个实数，它在[0,1)范围内。</td></tr><tr><td align="left">[seed(<a href="https://www.runoob.com/python/func-number-seed.html">x])</a></td><td align="left">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-shuffle.html">shuffle(lst)</a></td><td align="left">将序列的所有元素随机排序</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-uniform.html">uniform(x, y)</a></td><td align="left">随机生成下一个实数，它在[x,y]范围内。</td></tr></tbody></table><h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python/func-number-acos.html">acos(x)</a></td><td align="left">返回x的反余弦弧度值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-asin.html">asin(x)</a></td><td align="left">返回x的反正弦弧度值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-atan.html">atan(x)</a></td><td align="left">返回x的反正切弧度值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-atan2.html">atan2(y, x)</a></td><td align="left">返回给定的 X 及 Y 坐标值的反正切值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-cos.html">cos(x)</a></td><td align="left">返回x的弧度的余弦值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-hypot.html">hypot(x, y)</a></td><td align="left">返回欧几里德范数 sqrt(x<em>x + y</em>y)。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-sin.html">sin(x)</a></td><td align="left">返回的x弧度的正弦值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-tan.html">tan(x)</a></td><td align="left">返回x弧度的正切值。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-degrees.html">degrees(x)</a></td><td align="left">将弧度转换为角度,如degrees(math.pi&#x2F;2) ， 返回90.0</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/func-number-radians.html">radians(x)</a></td><td align="left">将角度转换为弧度</td></tr></tbody></table><h4 id="数学常量"><a href="#数学常量" class="headerlink" title="数学常量"></a>数学常量</h4><table><thead><tr><th align="left">常量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">pi</td><td align="left">数学常量 pi（圆周率，一般以π来表示）</td></tr><tr><td align="left">e</td><td align="left">数学常量 e，e即自然常数（自然常数）。</td></tr></tbody></table><h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><h3 id="索引与切片"><a href="#索引与切片" class="headerlink" title="索引与切片"></a>索引与切片</h3><p>python的字串列表有2种取值顺序:</p><ul><li>从左到右索引默认0开始的，最大范围是字符串长度少1</li><li>从右到左索引默认-1开始的，最大范围是字符串开头</li></ul><p><img src="https://www.runoob.com/wp-content/uploads/2013/11/python-string-slice.png" alt="img"></p><p>如果你要实现从字符串中获取一段子字符串的话，可以使用 <strong>[头下标:尾下标:步长]</strong> 来截取相应的字符串，即**[start:stop:step]**。其中 <code>start</code> 表示起始索引，<code>stop</code> 表示结束索引（不包含在结果中），<code>step</code> 表示步长（可选，默认为1）。注意，切片操作是左闭右开的，即起始索引处的元素包含在结果中，但结束索引处的元素不包含在结果中。当我们将切片参数省略时，Python会使用默认值：<code>start=0</code>，<code>stop=len(obj)</code>，<code>step=1</code>。因此，<code>obj[::]</code>代表选择整个对象。</p><p>比如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &#x27;abcdef&#x27;</span><br><span class="line">&gt;&gt;&gt; s[1:5]</span><br><span class="line">&#x27;bcde&#x27;</span><br></pre></td></tr></table></figure><p>当使用以冒号分隔的字符串，python 返回一个新的对象，结果包含了以这对偏移标识的连续的内容，左边的开始是包含了下边界。</p><p>上面的结果包含了 <strong>s[1]</strong> 的值 b，而取到的最大范围不包括<strong>尾下标</strong>，就是 <strong>s[5]</strong> 的值 f。</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/11/o99aU.png" alt="img"></p><p>加号（+）是字符串连接运算符，星号（*）是重复操作。如下实例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>           <span class="comment"># 输出完整字符串</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[:]        <span class="comment"># 输出完整字符串</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[::]<span class="comment"># 输出完整字符串</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">0</span>]        <span class="comment"># 输出字符串中的第一个字符</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>]      <span class="comment"># 输出字符串中第三个至第六个之间的字符串</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>[<span class="number">2</span>:]       <span class="comment"># 输出从第三个字符开始的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span> * <span class="number">2</span>       <span class="comment"># 输出字符串两次</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span> + <span class="string">&quot;TEST&quot;</span>  <span class="comment"># 输出连接的字符串</span></span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">Hello World!</span><br><span class="line">Hello World!</span><br><span class="line">H</span><br><span class="line">llo</span><br><span class="line">llo World!</span><br><span class="line"></span><br><span class="line">Hello World!Hello World!</span><br><span class="line">Hello World!TEST</span><br></pre></td></tr></table></figure><p>Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：</p><p><img src="https://www.runoob.com/wp-content/uploads/2013/11/python_list_slice_2.png" alt="img"></p><p>特殊情况下，步长可以为负数，为负数时代表截取从后向前遍历，这意味着它会以相反的顺序返回切片范围内的元素。</p><p>例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;1234567&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">6</span>:<span class="number">1</span>:-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">76543</span></span><br></pre></td></tr></table></figure><p>遍历从6到1，此时下标为1的’2’无法被取到。</p><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。</p><p>在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。</p><p>如下实例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;My name is %s and weight is %d kg!&quot;</span> % (<span class="string">&#x27;Zara&#x27;</span>, <span class="number">21</span>) )</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My name <span class="keyword">is</span> Zara <span class="keyword">and</span> weight <span class="keyword">is</span> <span class="number">21</span> kg!</span><br></pre></td></tr></table></figure><p>python 字符串格式化符号:</p><table><thead><tr><th align="left">符  号</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">%c</td><td align="left">格式化字符及其ASCII码</td></tr><tr><td align="left">%s</td><td align="left">格式化字符串</td></tr><tr><td align="left">%d</td><td align="left">格式化整数</td></tr><tr><td align="left">%u</td><td align="left">格式化无符号整型</td></tr><tr><td align="left">%o</td><td align="left">格式化无符号八进制数</td></tr><tr><td align="left">%x</td><td align="left">格式化无符号十六进制数</td></tr><tr><td align="left">%X</td><td align="left">格式化无符号十六进制数（大写）</td></tr><tr><td align="left">%f</td><td align="left">格式化浮点数字，可指定小数点后的精度</td></tr><tr><td align="left">%e</td><td align="left">用科学计数法格式化浮点数</td></tr><tr><td align="left">%E</td><td align="left">作用同%e，用科学计数法格式化浮点数</td></tr><tr><td align="left">%g</td><td align="left">%f和%e的简写</td></tr><tr><td align="left">%G</td><td align="left">%F 和 %E 的简写</td></tr><tr><td align="left">%p</td><td align="left">用十六进制数格式化变量的地址</td></tr></tbody></table><h3 id="三引号"><a href="#三引号" class="headerlink" title="三引号"></a>三引号</h3><p>Python 中三引号可以将复杂的字符串进行赋值。</p><p><strong>Python 三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。</strong></p><p>三引号的语法是一对连续的单引号或者双引号（通常都是成对的用）。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &gt;&gt;&gt; hi = <span class="string">&#x27;&#x27;&#x27;hi </span></span><br><span class="line"><span class="string">there&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hi   <span class="comment"># repr()</span></span><br><span class="line"><span class="string">&#x27;hi\nthere&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> hi  <span class="comment"># str()</span></span><br><span class="line">hi </span><br><span class="line">there  </span><br></pre></td></tr></table></figure><p>三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。</p><p>一个典型的用例是，当你需要一块HTML或者SQL时，这时当用三引号标记，使用传统的转义字符体系将十分费神。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> errHTML = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;</span></span><br><span class="line"><span class="string">Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;</span></span><br><span class="line"><span class="string">&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;</span></span><br><span class="line"><span class="string">&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;</span></span><br><span class="line"><span class="string">&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back</span></span><br><span class="line"><span class="string">ONCLICK=&quot;window.history.back()&quot;&gt;&lt;/FORM&gt;</span></span><br><span class="line"><span class="string">&lt;/BODY&gt;&lt;/HTML&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">cursor.execute(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">CREATE TABLE users (  </span></span><br><span class="line"><span class="string">login VARCHAR(8), </span></span><br><span class="line"><span class="string">uid INTEGER,</span></span><br><span class="line"><span class="string">prid INTEGER)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="字符串内建函数"><a href="#字符串内建函数" class="headerlink" title="字符串内建函数"></a>字符串内建函数</h3><p>这些方法实现了 string 模块的大部分方法，如下表所示列出了目前字符串内建支持的方法，所有的方法都包含了对 Unicode 的支持，有一些甚至是专门用于 Unicode 的。</p><table><thead><tr><th align="left"><strong>方法</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python/att-string-capitalize.html">string.capitalize()</a></td><td align="left">把字符串的第一个字符大写</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-center.html">string.center(width)</a></td><td align="left">返回一个原字符串居中,并使用空格填充至长度 width 的新字符串</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-count.html">string.count(str, beg&#x3D;0, end&#x3D;len(string))</a></strong></td><td align="left">返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-decode.html">string.decode(encoding&#x3D;’UTF-8’, errors&#x3D;’strict’)</a></td><td align="left">以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 ‘ignore’ 或 者’replace’</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-encode.html">string.encode(encoding&#x3D;’UTF-8’, errors&#x3D;’strict’)</a></td><td align="left">以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-endswith.html">string.endswith(obj, beg&#x3D;0, end&#x3D;len(string))</a></strong></td><td align="left">检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-expandtabs.html">string.expandtabs(tabsize&#x3D;8)</a></td><td align="left">把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-find.html">string.find(str, beg&#x3D;0, end&#x3D;len(string))</a></strong></td><td align="left">检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-format.html">string.format()</a></strong></td><td align="left">格式化字符串</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-index.html">string.index(str, beg&#x3D;0, end&#x3D;len(string))</a></strong></td><td align="left">跟find()方法一样，只不过如果str不在 string中会报一个异常.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isalnum.html">string.isalnum()</a></td><td align="left">如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isalpha.html">string.isalpha()</a></td><td align="left">如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isdecimal.html">string.isdecimal()</a></td><td align="left">如果 string 只包含十进制数字则返回 True 否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isdigit.html">string.isdigit()</a></td><td align="left">如果 string 只包含数字则返回 True 否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-islower.html">string.islower()</a></td><td align="left">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isnumeric.html">string.isnumeric()</a></td><td align="left">如果 string 中只包含数字字符，则返回 True，否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isspace.html">string.isspace()</a></td><td align="left">如果 string 中只包含空格，则返回 True，否则返回 False.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-istitle.html">string.istitle()</a></td><td align="left">如果 string 是标题化的(见 title())则返回 True，否则返回 False</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-isupper.html">string.isupper()</a></td><td align="left">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-join.html">string.join(seq)</a></strong></td><td align="left">以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-ljust.html">string.ljust(width)</a></td><td align="left">返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-lower.html">string.lower()</a></td><td align="left">转换 string 中所有大写字符为小写.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-lstrip.html">string.lstrip()</a></td><td align="left">截掉 string 左边的空格</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-maketrans.html">string.maketrans(intab, outtab)</a></td><td align="left">maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-max.html">max(str)</a></td><td align="left">返回字符串 <em>str</em> 中最大的字母。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-min.html">min(str)</a></td><td align="left">返回字符串 <em>str</em> 中最小的字母。</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-partition.html">string.partition(str)</a></strong></td><td align="left">有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str &#x3D;&#x3D; string.</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-replace.html">string.replace(str1, str2, num&#x3D;string.count(str1))</a></strong></td><td align="left">把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rfind.html">string.rfind(str, beg&#x3D;0,end&#x3D;len(string) )</a></td><td align="left">类似于 find() 函数，返回字符串最后一次出现的位置，如果没有匹配项则返回 -1。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rindex.html">string.rindex( str, beg&#x3D;0,end&#x3D;len(string))</a></td><td align="left">类似于 index()，不过是返回最后一个匹配到的子字符串的索引号。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rjust.html">string.rjust(width)</a></td><td align="left">返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rpartition.html">string.rpartition(str)</a></td><td align="left">类似于 partition()函数,不过是从右边开始查找</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-rstrip.html">string.rstrip()</a></td><td align="left">删除 string 字符串末尾的空格.</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-split.html">string.split(str&#x3D;””, num&#x3D;string.count(str))</a></strong></td><td align="left">以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 <strong>num+1</strong> 个子字符串</td></tr><tr><td align="left">[string.splitlines(<a href="https://www.runoob.com/python/att-string-splitlines.html">keepends])</a></td><td align="left">按照行(‘\r’, ‘\r\n’, ‘\n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-startswith.html">string.startswith(obj, beg&#x3D;0,end&#x3D;len(string))</a></td><td align="left">检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查.</td></tr><tr><td align="left"><strong>[string.strip(<a href="https://www.runoob.com/python/att-string-strip.html">obj])</a></strong></td><td align="left">在 string 上执行 lstrip()和 rstrip()</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-swapcase.html">string.swapcase()</a></td><td align="left">翻转 string 中的大小写</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-title.html">string.title()</a></td><td align="left">返回”标题化”的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td></tr><tr><td align="left"><strong><a href="https://www.runoob.com/python/att-string-translate.html">string.translate(str, del&#x3D;””)</a></strong></td><td align="left">根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-upper.html">string.upper()</a></td><td align="left">转换 string 中的小写字母为大写</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-string-zfill.html">string.zfill(width)</a></td><td align="left">返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0</td></tr></tbody></table><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>List（列表） 是 Python 中使用最频繁的数据类型。</p><p>列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。</p><p>列表用 <strong>[ ]</strong> 标识，是 python 最通用的复合数据类型。</p><p>列表中值的切割也可以用到变量 <strong>[头下标:尾下标]</strong> ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/list_slicing1_new1.png" alt="img"></p><h3 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h3><p>可以使用 <code>del </code>语句来删除列表的元素，如下实例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"> </span><br><span class="line">list1 = [<span class="string">&#x27;physics&#x27;</span>, <span class="string">&#x27;chemistry&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> list1</span><br><span class="line"><span class="keyword">del</span> list1[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;After deleting value at index 2 : &quot;</span></span><br><span class="line"><span class="built_in">print</span> list1</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;physics&#x27;, &#x27;chemistry&#x27;, 1997, 2000]</span><br><span class="line">After deleting value at index 2 :</span><br><span class="line">[&#x27;physics&#x27;, &#x27;chemistry&#x27;, 2000]</span><br></pre></td></tr></table></figure><h3 id="列表函数-amp-方法"><a href="#列表函数-amp-方法" class="headerlink" title="列表函数&amp;方法"></a>列表函数&amp;方法</h3><p>Python包含以下函数:</p><table><thead><tr><th align="left">序号</th><th align="left">函数</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python/att-list-cmp.html">cmp(list1, list2)</a> 比较两个列表的元素</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python/att-list-len.html">len(list)</a> 列表元素个数</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python/att-list-max.html">max(list)</a> 返回列表元素最大值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python/att-list-min.html">min(list)</a> 返回列表元素最小值</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python/att-list-list.html">list(seq)</a> 将元组转换为列表</td></tr></tbody></table><p>Python包含以下方法:</p><table><thead><tr><th align="left">序号</th><th align="left">方法</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python/att-list-append.html">list.append(obj)</a> 在列表末尾添加新的对象</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python/att-list-count.html">list.count(obj)</a> 统计某个元素在列表中出现的次数</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python/att-list-extend.html">list.extend(seq)</a> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python/att-list-index.html">list.index(obj)</a> 从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python/att-list-insert.html">list.insert(index, obj)</a> 将对象插入列表</td></tr><tr><td align="left">6</td><td align="left">[list.pop([index&#x3D;-1])](<a href="https://www.runoob.com/python/att-list-pop.html">https://www.runoob.com/python/att-list-pop.html</a>) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python/att-list-remove.html">list.remove(obj)</a> 移除列表中某个值的第一个匹配项</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python/att-list-reverse.html">list.reverse()</a> 反向列表中元素</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python/att-list-sort.html">list.sort(cmp&#x3D;None, key&#x3D;None, reverse&#x3D;False)</a> 对原列表进行排序</td></tr></tbody></table><h2 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h2><p>元组是另一个数据类型，类似于 List（列表）。</p><p>元组用 <strong>()</strong> 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。</p><p>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p><p>如下实例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (<span class="string">&#x27;physics&#x27;</span>, <span class="string">&#x27;chemistry&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line">tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> )</span><br><span class="line">tup3 = <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span></span><br></pre></td></tr></table></figure><p>创建空元组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tup1 = ()</span><br></pre></td></tr></table></figure><p><strong>元组中只包含一个元素时，需要在元素后面添加逗号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tup1 = (50,) </span><br></pre></td></tr></table></figure><p>元组与字符串类似，下标索引从0开始，可以进行截取，组合等。</p><h3 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h3><p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，组合后的元组会新分配空间，如下实例:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line">tup1 = (<span class="number">12</span>, <span class="number">34.56</span>)</span><br><span class="line">tup2 = (<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 以下修改元组元素操作是非法的。</span></span><br><span class="line"><span class="comment"># tup1[0] = 100</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个新的元组</span></span><br><span class="line">tup3 = tup1 + tup2</span><br><span class="line"><span class="built_in">print</span> tup3</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(12, 34.56, &#x27;abc&#x27;, &#x27;xyz&#x27;)</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：通过<code>+</code>实现元组切片时，需要符号两侧元素均为元组，这点与列表相同。</strong></p><p>例如：<code>(1,2,3) + (1)</code> 会报错，因为<code>(1)</code>并非一个元组而是一个数字，正确的写法是：<code>(1,2,3) + (1,)</code></p><p>再比如下面这个例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=a[<span class="number">1</span>:<span class="number">4</span>]+a[<span class="number">5</span>]    <span class="comment"># 报错, a[5] 被当成了整型</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only concatenate <span class="built_in">tuple</span> (<span class="keyword">not</span> <span class="string">&quot;int&quot;</span>) to <span class="built_in">tuple</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=a[<span class="number">1</span>:<span class="number">4</span>]+a[<span class="number">2</span>:<span class="number">4</span>]   <span class="comment"># 这样可以</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><code>a[5]</code>截取的是一个数字，如果需要截取到一个元组，正确的截取方法是：<code>a[5:6]</code> 或<code>a[5:]</code></p></blockquote><h3 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h3><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"> </span><br><span class="line">tup = (<span class="string">&#x27;physics&#x27;</span>, <span class="string">&#x27;chemistry&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> tup</span><br><span class="line"><span class="keyword">del</span> tup</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;After deleting tup : &quot;</span></span><br><span class="line"><span class="built_in">print</span> tup</span><br></pre></td></tr></table></figure><p>以上实例元组被删除后，输出变量会有异常信息，输出如下所示：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;physics&#x27;</span>, <span class="string">&#x27;chemistry&#x27;</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line">After deleting tup :</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">9</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span> tup</span><br><span class="line">NameError: name <span class="string">&#x27;tup&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><h3 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h3><table><thead><tr><th align="left">序号</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python/att-tuple-cmp.html">cmp(tuple1, tuple2)</a> 比较两个元组元素。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python/att-tuple-len.html">len(tuple)</a> 计算元组元素个数。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python/att-tuple-max.html">max(tuple)</a> 返回元组中元素最大值。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python/att-tuple-min.html">min(tuple)</a> 返回元组中元素最小值。</td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python/att-tuple-tuple.html">tuple(seq)</a> 将列表转换为元组。</td></tr></tbody></table><h2 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h2><p>**字典(dictionary)**是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p><p>字典用”{ }”标识。字典由索引(key)和它对应的值value组成。字典的每个键值 <strong>key:value</strong> 对用冒号 <strong>:</strong> 分割，每个键值对之间用逗号 <strong>,</strong> 分割，整个字典包括在花括号 <strong>{}</strong> 中 ,格式如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;key1 : value1, key2 : value2 &#125;</span><br></pre></td></tr></table></figure><h3 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h3><p>显示删除一个字典用del命令，如下实例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Zara&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">del</span> tinydict[<span class="string">&#x27;Name&#x27;</span>]  <span class="comment"># 删除键是&#x27;Name&#x27;的条目</span></span><br><span class="line">tinydict.clear()      <span class="comment"># 清空字典所有条目</span></span><br><span class="line"><span class="keyword">del</span> tinydict          <span class="comment"># 删除字典</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>] </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;tinydict[&#x27;School&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;School&#x27;</span>]</span><br></pre></td></tr></table></figure><p>但这会引发一个异常，因为用del后字典不再存在：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tinydict[<span class="string">&#x27;Age&#x27;</span>]: </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">10</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;tinydict[&#x27;Age&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Age&#x27;</span>] </span><br><span class="line">NameError: name <span class="string">&#x27;tinydict&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><h3 id="字典键值的特性"><a href="#字典键值的特性" class="headerlink" title="字典键值的特性"></a>字典键值的特性</h3><p>字典值可以没有限制地取任何 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p><p>字典键两个重要的点需要记住：</p><p><strong>1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Manni&#x27;</span>&#125; </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tinydict[&#x27;Name&#x27;]:  Manni</span><br></pre></td></tr></table></figure><p><strong>2）键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行，如下实例：</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;[<span class="string">&#x27;Name&#x27;</span>]: <span class="string">&#x27;Zara&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>&#125; </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;tinydict[&#x27;Name&#x27;]: &quot;</span>, tinydict[<span class="string">&#x27;Name&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    tinydict = &#123;[<span class="string">&#x27;Name&#x27;</span>]: <span class="string">&#x27;Zara&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>&#125; </span><br><span class="line">TypeError: unhashable <span class="built_in">type</span>: <span class="string">&#x27;list&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="字典内置函数-amp-方法"><a href="#字典内置函数-amp-方法" class="headerlink" title="字典内置函数&amp;方法"></a>字典内置函数&amp;方法</h3><p>Python字典包含了以下内置函数：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-cmp.html">cmp(dict1, dict2)</a> 比较两个字典元素。</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-len.html">len(dict)</a> 计算字典元素个数，即键的总数。</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-str.html">str(dict)</a> 输出字典可打印的字符串表示。</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-type.html">type(variable)</a> 返回输入的变量类型，如果变量是字典就返回字典类型。</td></tr></tbody></table><p>Python字典包含了以下内置方法：</p><table><thead><tr><th align="left">序号</th><th align="left">函数及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-clear.html">dict.clear()</a> 删除字典内所有元素</td></tr><tr><td align="left">2</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-copy.html">dict.copy()</a> 返回一个字典的浅复制</td></tr><tr><td align="left">3</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-fromkeys.html">dict.fromkeys(seq[, val])</a> 创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</td></tr><tr><td align="left">4</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-get.html">dict.get(key, default&#x3D;None)</a> 返回指定键的值，如果值不在字典中返回default值      <em>注：使用[]访问字典不存在的键会报错，而dict.get()方法不会</em></td></tr><tr><td align="left">5</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-has_key.html">dict.has_key(key)</a> 如果键在字典dict里返回true，否则返回false                                       <em>注：python3中已经移除，改为使用 in 和 not in 判断键是否在字典中</em></td></tr><tr><td align="left">6</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-items.html">dict.items()</a> 以列表返回可遍历的(键, 值) 元组数组</td></tr><tr><td align="left">7</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-keys.html">dict.keys()</a> 以列表返回一个字典所有的键</td></tr><tr><td align="left">8</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-setdefault.html">dict.setdefault(key, default&#x3D;None)</a> 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td align="left">9</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-update.html">dict.update(dict2)</a> 把字典dict2的键&#x2F;值对更新到dict里</td></tr><tr><td align="left">10</td><td align="left"><a href="https://www.runoob.com/python/att-dictionary-values.html">dict.values()</a> 以列表返回字典中的所有值</td></tr><tr><td align="left">11</td><td align="left"><a href="https://www.runoob.com/python/python-att-dictionary-pop.html">pop(key[,default])</a> 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td align="left">12</td><td align="left"><a href="https://www.runoob.com/python/python-att-dictionary-popitem.html">popitem()</a> 返回并删除字典中的最后一对键和值。</td></tr></tbody></table><h2 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h2><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p><p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/python/python-func-int.html">int(x [,base])</a></td><td align="left">将x转换为一个整数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/python-func-long.html">long(x [,base] )</a></td><td align="left">将x转换为一个长整数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/python-func-float.html">float(x)</a></td><td align="left">将x转换到一个浮点数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/python-func-complex.html">complex(real [,imag])</a></td><td align="left">创建一个复数</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/python-func-str.html">str(x)</a></td><td align="left">将对象 x 转换为字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/python-func-repr.html">repr(x)</a></td><td align="left">将对象 x 转换为表达式字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/python-func-eval.html">eval(str)</a></td><td align="left">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-tuple-tuple.html">tuple(s)</a></td><td align="left">将序列 s 转换为一个元组</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/att-list-list.html">list(s)</a></td><td align="left">将序列 s 转换为一个列表</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/python-func-set.html">set(s)</a></td><td align="left">转换为可变集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/python-func-dict.html">dict(d)</a></td><td align="left">创建一个字典。d 必须是一个序列 (key,value)元组。</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/python-func-frozenset.html">frozenset(s)</a></td><td align="left">转换为不可变集合</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/python-func-chr.html">chr(x)</a></td><td align="left">将一个整数转换为一个字符</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/python-func-unichr.html">unichr(x)</a></td><td align="left">将一个整数转换为Unicode字符</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/python-func-ord.html">ord(x)</a></td><td align="left">将一个字符转换为它的整数值</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/python-func-hex.html">hex(x)</a></td><td align="left">将一个整数转换为一个十六进制字符串</td></tr><tr><td align="left"><a href="https://www.runoob.com/python/python-func-oct.html">oct(x)</a></td><td align="left">将一个整数转换为一个八进制字符串</td></tr></tbody></table><h1 id="Python函数"><a href="#Python函数" class="headerlink" title="Python函数"></a>Python函数</h1><h2 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h2><p>你可以定义一个由自己想要功能的函数，以下是简单的规则：</p><ul><li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称和圆括号**()**。</li><li>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。</li><li>函数的第一行语句可以选择性地使用<strong>文档字符串</strong>—用于存放函数说明。</li><li>函数内容以冒号起始，并且缩进。</li><li><strong>return [表达式]</strong> 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</li></ul><p>例如下面这个函数的定义与调用：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">writeAndAdd</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;传入字符串：&quot;</span>,s)</span><br><span class="line">    <span class="keyword">return</span> s + <span class="string">&quot;456&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">retS = writeAndAdd(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;返回字符串：&quot;</span>,retS)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">传入字符串： <span class="number">123</span></span><br><span class="line">返回字符串： <span class="number">123456</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>DocStrings</strong> 文档字符串是一个重要工具，用于解释文档程序，帮助你的程序文档更加简单易懂。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function</span>():</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27; say something here！</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (function.__doc__) <span class="comment"># 调用 doc</span></span><br></pre></td></tr></table></figure><p><strong>DocStrings</strong> 文档字符串使用惯例：它的首行简述函数功能，第二行空行，第三行为函数的具体描述。</p><p>更多内容可参考：<a href="https://www.runoob.com/w3cnote/python-docstrings.html">Python 文档字符串(DocStrings)</a></p></blockquote><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>Python 在 heap 中分配的对象分成两类：可变对象和不可变对象。所谓可变对象是指，对象的内容是可变的，例如 list。而不可变的对象则相反，表示其内容不可变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不可变对象 ：int，string，float，tuple   -- 可理解为C中，该参数为值传递</span><br><span class="line">可变对象   ：list，dictionary           -- 可理解为C中，该参数为指针传递</span><br></pre></td></tr></table></figure><h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><p>由于 Python 中的变量存放的是对象引用，所以对于不可变对象而言，尽管对象本身不可变，但变量的对象引用是可变的。运用这样的机制，有时候会让人产生糊涂，似乎可变对象变化了。如下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = 73  </span><br><span class="line">i += 2</span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2013/11/ecaa0811-5af3-3893-a26a-951bbf22a571.png" alt="img"></p><p>从上面得知，不可变的对象的特征没有变，依然是不可变对象，变的只是创建了新对象，改变了变量的对象引用。</p><p>不可变对象的参数传递类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</p><p>看看下面的代码，更能体现这点的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ChangeInt</span>(<span class="params"> a </span>):</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">ChangeInt(b)</span><br><span class="line"><span class="built_in">print</span> b <span class="comment"># 结果是 2</span></span><br></pre></td></tr></table></figure><h3 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h3><p>其对象的内容是可以变化的。当对象的内容发生变化时，变量的对象引用是不会变化的。如下面的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m=[5,9]  </span><br><span class="line">m+=[6] </span><br></pre></td></tr></table></figure><p><img src="https://www.runoob.com/wp-content/uploads/2013/11/562fc52b-a7cb-36e2-936e-a03e7a62268e.png" alt="img"></p><p>可变对象的参数传递类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">changeme</span>(<span class="params"> mylist </span>):</span><br><span class="line">   <span class="string">&quot;修改传入的列表&quot;</span></span><br><span class="line">   mylist.append([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;函数内取值: &quot;</span>, mylist</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用changeme函数</span></span><br><span class="line">mylist = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line">changeme( mylist )</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;函数外取值: &quot;</span>, mylist</span><br></pre></td></tr></table></figure><p>实例中传入函数的和在末尾添加新内容的对象用的是同一个引用，故输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数内取值:  [10, 20, 30, [1, 2, 3, 4]]</span><br><span class="line">函数外取值:  [10, 20, 30, [1, 2, 3, 4]]</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="必备参数"><a href="#必备参数" class="headerlink" title="必备参数"></a>必备参数</h3><p>必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p><p>调用printme()函数，你必须传入一个参数，不然会出现语法错误：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printme</span>(<span class="params"> <span class="built_in">str</span> </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> <span class="built_in">str</span></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printme函数</span></span><br><span class="line">printme()</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;test.py&quot;</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    printme()</span><br><span class="line">TypeError: printme() takes exactly <span class="number">1</span> argument (<span class="number">0</span> given)</span><br></pre></td></tr></table></figure><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p><p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> name, age </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;Name: &quot;</span>, name</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;Age &quot;</span>, age</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;miki&quot;</span> )</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Name:  miki</span><br><span class="line">Age  <span class="number">50</span></span><br></pre></td></tr></table></figure><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>调用函数时，默认参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> name, age = <span class="number">35</span> </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;Name: &quot;</span>, name</span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;Age &quot;</span>, age</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;miki&quot;</span> )</span><br><span class="line">printinfo( name=<span class="string">&quot;miki&quot;</span> )</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name:  miki</span><br><span class="line">Age  <span class="number">50</span></span><br><span class="line">Name:  miki</span><br><span class="line">Age  <span class="number">35</span></span><br></pre></td></tr></table></figure><h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params">[formal_args,] *var_args_tuple </span>):</span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure><p>加了星号（*）的变量名会存放所有未命名的变量参数。不定长参数实例如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> arg1, *vartuple </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;输出: &quot;</span></span><br><span class="line">   <span class="built_in">print</span> arg1</span><br><span class="line">   <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</span><br><span class="line">      <span class="built_in">print</span> var</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">10</span> )</span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> )</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输出:</span><br><span class="line"><span class="number">10</span></span><br><span class="line">输出:</span><br><span class="line"><span class="number">70</span></span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：函数内部的不定长参数会被当做tuple类型，即使只传入一个参数，例如下面这个例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function1</span>(<span class="params">*var1</span>):</span><br><span class="line">    data1 = (<span class="number">1</span>,)</span><br><span class="line">    <span class="built_in">print</span>(operator.eq(var1,data1))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function2</span>(<span class="params">*var2</span>):</span><br><span class="line">    data2 = (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span> (operator.eq(data2,var2))</span><br><span class="line"></span><br><span class="line">function1(<span class="number">1</span>)</span><br><span class="line">function2(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>python 使用 lambda 来创建匿名函数。</p><ul><li>lambda只是一个表达式，函数体比def简单很多。</li><li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</li><li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>lambda函数的语法只包含一个语句，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda [arg1 [,arg2,.....argn]]:expression</span><br></pre></td></tr></table></figure><p>如下实例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;相加后的值为 : &quot;</span>, <span class="built_in">sum</span>( <span class="number">20</span>, <span class="number">20</span> )</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">相加后的值为 :  <span class="number">30</span></span><br><span class="line">相加后的值为 :  <span class="number">40</span></span><br></pre></td></tr></table></figure><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。</p><p>变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下：</p><ul><li>全局变量</li><li>局部变量</li></ul><hr><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p><strong>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</strong></p><p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line">total = <span class="number">0</span> <span class="comment"># 这是一个全局变量</span></span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params"> arg1, arg2 </span>):</span><br><span class="line">   <span class="comment">#返回2个参数的和.&quot;</span></span><br><span class="line">   total = arg1 + arg2 <span class="comment"># total在这里是局部变量，相当于是新定义的变量</span></span><br><span class="line">   <span class="built_in">print</span> <span class="string">&quot;函数内是局部变量 : &quot;</span>, total</span><br><span class="line">   <span class="keyword">return</span> total</span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用sum函数</span></span><br><span class="line"><span class="built_in">sum</span>( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;函数外是全局变量 : &quot;</span>, total</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数内是局部变量 :  <span class="number">30</span></span><br><span class="line">函数外是全局变量 :  <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="函数内部使用全局变量"><a href="#函数内部使用全局变量" class="headerlink" title="函数内部使用全局变量"></a>函数内部使用全局变量</h3><p>全局变量想作用于函数内，需加 <strong>global</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line">globvar = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_globvar_to_one</span>():</span><br><span class="line">    <span class="keyword">global</span> globvar    <span class="comment"># 使用 global 声明全局变量</span></span><br><span class="line">    globvar = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_globvar</span>():</span><br><span class="line">    <span class="built_in">print</span>(globvar)     <span class="comment"># 没有使用 global</span></span><br><span class="line"></span><br><span class="line">set_globvar_to_one()</span><br><span class="line"><span class="built_in">print</span>  globvar        <span class="comment"># 输出 1</span></span><br><span class="line">print_globvar()       <span class="comment"># 输出 1，函数内的 globvar 已经是全局变量</span></span><br></pre></td></tr></table></figure><p>1、global—将变量定义为全局变量。可以通过定义为全局变量，实现在函数内部改变变量值。</p><p>2、一个global语句可以同时定义多个变量，如 global x, y, z。</p><h2 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h2><h3 id="系统自带的模块"><a href="#系统自带的模块" class="headerlink" title="系统自带的模块"></a>系统自带的模块</h3><p>以正则表达式模块为例，我们经常这样写代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line">target = <span class="string">&#x27;abc1234xyz&#x27;</span></span><br><span class="line">re.search(<span class="string">&#x27;(\d+)&#x27;</span>, target)</span><br></pre></td></tr></table></figure><p>但有时候，你可能会看到某些人这样写代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> re <span class="keyword">import</span> search</span><br><span class="line"></span><br><span class="line">target = <span class="string">&#x27;abc1234xyz&#x27;</span></span><br><span class="line">search(<span class="string">&#x27;(\d+)&#x27;</span>, target)</span><br></pre></td></tr></table></figure><p>那么这两种导入方式有什么区别呢？</p><p>我们分别使用<code>type</code>函数来看看他们的类型：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(re)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;module&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> re <span class="keyword">import</span> search</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(search)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;function&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-13-30-59.png" alt="img"></p><p>可以看到，直接使用<code>import re</code>导入的<code>re</code>它是一个<code>module</code>类，也就是模块。我们把它成为<code>正则表达式模块</code>。而当我们<code>from re import search</code>时，这个<code>search</code>是一个<code>function</code>类，我们称呼它为<code>search 函数</code>。</p><p>一个模块里面可以包含多个函数。</p><p>如果在你的代码里面，你已经确定只使用<code>search</code>函数，不会再使用正则表达式里面的其他函数了，那么你使用两种方法都可以，没什么区别。</p><p>但是，如果你要使用正则表达式下面的多个函数，或者是一些常量，那么用第一种方案会更加简洁清晰。</p><p>例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line">re.search(<span class="string">&#x27;c(.*?)x&#x27;</span>, flags=re.S)</span><br><span class="line">re.sub(<span class="string">&#x27;[a-zA-Z0-9]&#x27;</span>, <span class="string">&#x27;***&#x27;</span>, target, flags=re.I)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，你分别使用了<code>re.search</code>，<code>re.sub</code>，<code>re.S</code>和<code>re.I</code>。后两者是常量，用于忽略换行符和大小写。</p><p>但是，如果你使用<code>from re import search, sub, S, I</code>来写代码，那么代码就会变成这样：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line">search(<span class="string">&#x27;c(.*?)x&#x27;</span>, flags=S)</span><br><span class="line">sub(<span class="string">&#x27;[a-zA-Z0-9]&#x27;</span>, <span class="string">&#x27;***&#x27;</span>, target, flags=I)</span><br></pre></td></tr></table></figure><p>看起来虽然简洁了，但是，一旦你的代码行数多了以后，你很容易忘记<code>S</code>和<code>I</code>这两个变量是什么东西。而且我们自己定义的函数，也很有可能取名为<code>sub</code>或者<code>search</code>，从而覆盖正则表达式模块下面的这两个同名函数。这就会导致很多难以觉察的潜在 bug。</p><p>再举一个例子。Python 的 <code>datetime</code>模块，我们可以直接<code>import datetime</code>，此时我们导入的是一个<code>datetime</code>模块，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-13-43-21.png" alt="img"></p><p>但是如果你写为<code>from datetime import datetime</code>，那么你导入的<code>datetime</code>是一个<code>type</code>类：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-13-45-07.png" alt="img"></p><p>因为这种方式导入的<code>datetime</code>，它就是Python 中的一种类型，用于表示包含日期和时间的数据。</p><p>这两种导入方式导入的<code>datetime</code>，虽然名字一样，但是他们的意义完全不一样，请大家观察下面两种写法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"> </span><br><span class="line">now = datetime.datetime.now()</span><br><span class="line">one_hour_ago = now - datetime.timedelta(hours=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line">now = datetime.now()</span><br><span class="line">one_hour_ago = now - timedelta(hours=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>第二种写法看似简单，但实则改动起来却更为麻烦。例如我还需要增加一个变量<code>today</code>用于记录今日的日期。</p><p>对于第一段代码，我们只需要增加一行即可：</p><p><code>today = datetime.date.today()</code></p><p>但对于第二行来说，我们需要首先修改导入部分的代码：</p><p><code>from datetime import datetime, timedelta, date</code></p><p>然后才能改代码：<code>today = date.today()</code></p><p>这样一来你就要修改两个地方，反倒增加了负担。</p><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><p>在使用某些第三方库的代码里面，我们会看到类似这样的写法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml.html <span class="keyword">import</span> fromstring</span><br><span class="line"> </span><br><span class="line">selector = fromstring(HTML)</span><br></pre></td></tr></table></figure><p>但是我们还可以写为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> html</span><br><span class="line"> </span><br><span class="line">selector = html.fromstring(HTML)</span><br></pre></td></tr></table></figure><p>但是，下面这种写法会导致报错：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lxml</span><br><span class="line">selector = lxml.html.fromstring(HTML)</span><br></pre></td></tr></table></figure><p>那么这里的<code>lxml.html</code>又是什么东西呢？</p><p>这种情况多常见于一些特别大型的第三方库中，这种库能处理多种类型的数据。例如<code>lxml</code>它既能处理<code>xml</code>的数据，又能处理<code>html</code>的数据，于是这种库会划分子模块，<code>lxml.html</code>模块专门负责<code>html</code>相关的数据。</p><h3 id="自己来实现多种导入方法"><a href="#自己来实现多种导入方法" class="headerlink" title="自己来实现多种导入方法"></a>自己来实现多种导入方法</h3><p>我们现在自己来写代码，实现这多种导入方法。</p><p>我们创建一个文件夹<code>DocParser</code>，在里面分别创建两个文件<code>main.py</code>和<code>util.py</code>，他们的内容如下：</p><p><code>util.py</code>文件:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;write 函数被调用！&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>main.py</code>文件：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> util</span><br><span class="line"> </span><br><span class="line">util.write()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-06-29.png" alt="img"></p><p>现在我们把<code>main.py</code>的导入方式修改一下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> write</span><br><span class="line"> </span><br><span class="line">write()</span><br></pre></td></tr></table></figure><p>依然正常运行，如下图所示</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-07-21.png" alt="img"></p><blockquote><p>当两个文件在同一个文件夹下面，并且该文件夹里面没有<strong>init</strong>.py 文件时，两种导入方式等价。</p></blockquote><p>现在，我们来创建一个文件夹<code>microsoft</code>，里面再添加一个文件<code>parse.py</code>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;我是 microsoft 文件夹下面的 parse.py 中的 read函数&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-11-17.png" alt="img"></p><p>此时我们在 <code>main.py</code>中对它进行调用：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> microsoft <span class="keyword">import</span> parse</span><br><span class="line"> </span><br><span class="line">parse.read()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-12-17.png" alt="img"></p><p>我们也可以用另一种方法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> microsoft.parse <span class="keyword">import</span> read</span><br><span class="line"> </span><br><span class="line">read()</span><br></pre></td></tr></table></figure><p>运行效果如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-13-17.png" alt="img"></p><p>但是，你不能直接导入<code>microsoft</code>，如下图所示：</p><p><img src="https://kingname-1257411235.cos.ap-chengdu.myqcloud.com/2019-12-28-14-15-35.png" alt="img"></p><blockquote><p>你只能导入一个模块或者导入一个函数或者类，你不能导入一个文件夹</p></blockquote><p>无论你使用的是<code>import xxx</code>还是<code>from xxx.yyy.zzz.www import qqq</code>，你导入进来的东西，要不就是一个模块(对应到.py 文件的文件名)，或者是某个.py 文件中的函数名、类名、变量名。</p><p>无论是<code>import xxx</code>还是<code>from xxx import yyy</code>，你导入进来的都不能是一个文件夹的名字。</p><p>可能有这样一种情况，就是某个函数名与文件的名字相同，例如：</p><p>在 <code>microsoft</code>文件夹里面有一个<code>microsoft.py</code>文件，这个文件里面有一个函数叫做<code>microsoft</code>，那么你的代码可以写为：</p><p>from microsoft import microsoft&#96;microsoft.microsoft()</p><p>但请注意分辨，这里你导入的还是模块，只不过<code>microsoft.py</code>文件名与它所在的文件夹名恰好相同而已。</p><p>而对于上级目录，可以使用下面的方式导入：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--|A</span><br><span class="line">----|E.py</span><br><span class="line">----|F</span><br><span class="line">------|G.py</span><br><span class="line">----|B</span><br><span class="line">------|C.py</span><br><span class="line">------|D.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># C.py中的代码：</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> D     <span class="comment"># 导入A.B.D</span></span><br><span class="line"><span class="keyword">from</span> .. <span class="keyword">import</span> E    <span class="comment"># 导入A.E</span></span><br><span class="line"><span class="keyword">from</span> ..F <span class="keyword">import</span> G    <span class="comment"># 导入A.F.G，.. 和 F是连着的，中间没有空格</span></span><br><span class="line"><span class="comment"># .代表当前目录，..代表上一层目录，...代表上上层目录。</span></span><br></pre></td></tr></table></figure><h1 id="Python异常处理"><a href="#Python异常处理" class="headerlink" title="Python异常处理"></a>Python异常处理</h1><h2 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h2><table><thead><tr><th align="left">异常名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">BaseException</td><td align="left">所有异常的基类</td></tr><tr><td align="left">SystemExit</td><td align="left">解释器请求退出</td></tr><tr><td align="left">KeyboardInterrupt</td><td align="left">用户中断执行(通常是输入^C</td></tr><tr><td align="left">Exception</td><td align="left">常规错误的基类</td></tr><tr><td align="left">StopIteration</td><td align="left">迭代器没有更多的值</td></tr><tr><td align="left">GeneratorExit</td><td align="left">生成器(generator)发生异常来通知退出</td></tr><tr><td align="left">StandardError</td><td align="left">所有的内建标准异常的基类</td></tr><tr><td align="left">ArithmeticError</td><td align="left">所有数值计算错误的基类</td></tr><tr><td align="left">FloatingPointError</td><td align="left">浮点计算错误</td></tr><tr><td align="left">OverflowError</td><td align="left">数值运算超出最大限制</td></tr><tr><td align="left">ZeroDivisionError</td><td align="left">除(或取模)零 (所有数据类型)</td></tr><tr><td align="left">AssertionError</td><td align="left">断言语句失败</td></tr><tr><td align="left">AttributeError</td><td align="left">对象没有这个属性</td></tr><tr><td align="left">EOFError</td><td align="left">没有内建输入,到达EOF 标记</td></tr><tr><td align="left">EnvironmentError</td><td align="left">操作系统错误的基类</td></tr><tr><td align="left">IOError</td><td align="left">输入&#x2F;输出操作失败</td></tr><tr><td align="left">OSError</td><td align="left">操作系统错误</td></tr><tr><td align="left">WindowsError</td><td align="left">系统调用失败</td></tr><tr><td align="left">ImportError</td><td align="left">导入模块&#x2F;对象失败</td></tr><tr><td align="left">LookupError</td><td align="left">无效数据查询的基类</td></tr><tr><td align="left">IndexError</td><td align="left">序列中没有此索引(index)</td></tr><tr><td align="left">KeyError</td><td align="left">映射中没有这个键</td></tr><tr><td align="left">MemoryError</td><td align="left">内存溢出错误(对于Python 解释器不是致命的)</td></tr><tr><td align="left">NameError</td><td align="left">未声明&#x2F;初始化对象 (没有属性)</td></tr><tr><td align="left">UnboundLocalError</td><td align="left">访问未初始化的本地变量</td></tr><tr><td align="left">ReferenceError</td><td align="left">弱引用(Weak reference)试图访问已经垃圾回收了的对象</td></tr><tr><td align="left">RuntimeError</td><td align="left">一般的运行时错误</td></tr><tr><td align="left">NotImplementedError</td><td align="left">尚未实现的方法</td></tr><tr><td align="left">SyntaxError</td><td align="left">Python 语法错误</td></tr><tr><td align="left">IndentationError</td><td align="left">缩进错误</td></tr><tr><td align="left">TabError</td><td align="left">Tab 和空格混用</td></tr><tr><td align="left">SystemError</td><td align="left">一般的解释器系统错误</td></tr><tr><td align="left">TypeError</td><td align="left">对类型无效的操作</td></tr><tr><td align="left">ValueError</td><td align="left">传入无效的参数</td></tr><tr><td align="left">UnicodeError</td><td align="left">Unicode 相关的错误</td></tr><tr><td align="left">UnicodeDecodeError</td><td align="left">Unicode 解码时的错误</td></tr><tr><td align="left">UnicodeEncodeError</td><td align="left">Unicode 编码时错误</td></tr><tr><td align="left">UnicodeTranslateError</td><td align="left">Unicode 转换时错误</td></tr><tr><td align="left">Warning</td><td align="left">警告的基类</td></tr><tr><td align="left">DeprecationWarning</td><td align="left">关于被弃用的特征的警告</td></tr><tr><td align="left">FutureWarning</td><td align="left">关于构造将来语义会有改变的警告</td></tr><tr><td align="left">OverflowWarning</td><td align="left">旧的关于自动提升为长整型(long)的警告</td></tr><tr><td align="left">PendingDeprecationWarning</td><td align="left">关于特性将会被废弃的警告</td></tr><tr><td align="left">RuntimeWarning</td><td align="left">可疑的运行时行为(runtime behavior)的警告</td></tr><tr><td align="left">SyntaxWarning</td><td align="left">可疑的语法的警告</td></tr><tr><td align="left">UserWarning</td><td align="left">用户代码生成的警告</td></tr></tbody></table><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>捕捉异常可以使用try&#x2F;except语句。</p><p>try&#x2F;except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。</p><p>如果你不想在异常发生时结束你的程序，只需在try里捕获它。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#运行别的代码</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字&gt;：</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果在try部份引发了&#x27;name&#x27;异常</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字&gt;，&lt;数据&gt;:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果引发了&#x27;name&#x27;异常，获得附加的数据</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">&lt;语句&gt;        <span class="comment">#如果没有异常发生</span></span><br></pre></td></tr></table></figure><p>try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。</p><ul><li>如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。</li><li>如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印默认的出错信息）。</li><li>如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。</li></ul><p>面是简单的例子，它打开一个文件，在该文件中的内容写入内容，但文件没有写入权限，发生了异常：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    fh = <span class="built_in">open</span>(<span class="string">&quot;testfile&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    fh.write(<span class="string">&quot;这是一个测试文件，用于测试异常!!&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> IOError:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Error: 没有找到文件或读取文件失败&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;内容写入文件成功&quot;</span></span><br><span class="line">    fh.close()</span><br></pre></td></tr></table></figure><p>再执行以上代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py </span><br><span class="line">Error: 没有找到文件或读取文件失败</span><br></pre></td></tr></table></figure><blockquote><p>注意：不要在 try 里写返回值。 try-except-else 里都是指做某事，而不是处理返回。如果在 try 里面写返回值，则 else 部分是 unreachable 的。</p></blockquote><p>你也可以使用相同的except语句来处理多个异常信息，如下所示：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    正常的操作</span><br><span class="line">   ......................</span><br><span class="line"><span class="keyword">except</span>(Exception1[, Exception2[,...ExceptionN]]):</span><br><span class="line">   发生以上多个异常中的一个，执行这块代码</span><br><span class="line">   ......................</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    如果没有异常执行这块代码</span><br></pre></td></tr></table></figure><p>你可以不带任何异常类型使用except来捕获所有的异常，如下实例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    正常的操作</span><br><span class="line">   ......................</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    发生异常，执行这块代码</span><br><span class="line">   ......................</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    如果没有异常执行这块代码</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="finnaly关键字"><a href="#finnaly关键字" class="headerlink" title="finnaly关键字"></a>finnaly关键字</h2><p>try-finally 与 Java 中类似，语句无论是否发生异常都会执行finally中的语句，如下面这个例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    fh = <span class="built_in">open</span>(<span class="string">&quot;testfile&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fh.write(<span class="string">&quot;这是一个测试文件，用于测试异常!!&quot;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;关闭文件&quot;</span></span><br><span class="line">        fh.close()</span><br><span class="line"><span class="keyword">except</span> IOError:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;Error: 没有找到文件或读取文件失败&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py </span><br><span class="line">Error: 没有找到文件或读取文件失败</span><br><span class="line">关闭文件</span><br></pre></td></tr></table></figure><h2 id="触发异常"><a href="#触发异常" class="headerlink" title="触发异常"></a>触发异常</h2><p>我们可以使用raise语句自己触发异常</p><p>raise语法格式如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> [Exception [, args [, traceback]]]</span><br></pre></td></tr></table></figure><p>语句中 Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数。</p><p>最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。</p><p>一个异常可以是一个字符串，类或对象。 Python的内核提供的异常，大多数都是实例化的类，这是一个类的实例的参数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    正常逻辑</span><br><span class="line"><span class="keyword">except</span> Exception,err:</span><br><span class="line">    触发自定义异常    </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    其余代码</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mye</span>(<span class="params"> level </span>):</span><br><span class="line">    <span class="keyword">if</span> level &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception,<span class="string">&quot;Invalid level!&quot;</span></span><br><span class="line">        <span class="comment"># 触发异常后，后面的代码就不会再执行</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    mye(<span class="number">0</span>)            <span class="comment"># 触发异常</span></span><br><span class="line"><span class="keyword">except</span> Exception,err:</span><br><span class="line">    <span class="built_in">print</span> <span class="number">1</span>,err</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py </span><br><span class="line">1 Invalid level!</span><br></pre></td></tr></table></figure><h2 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h2><p>通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。</p><p>以下为与RuntimeError相关的实例,实例中创建了一个类，基类为RuntimeError，用于在异常触发时输出更多的信息。</p><p>在try语句块中，用户自定义的异常后执行except块语句，变量 e 是用于创建Networkerror类的实例。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Networkerror</span>(<span class="title class_ inherited__">RuntimeError</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, arg</span>):</span><br><span class="line">        self.args = arg</span><br></pre></td></tr></table></figure><p>在你定义以上类后，你可以触发该异常，如下所示：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Networkerror(<span class="string">&quot;Bad hostname&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Networkerror,e:</span><br><span class="line">    <span class="built_in">print</span> e.args</span><br></pre></td></tr></table></figure><h1 id="Python面向对象"><a href="#Python面向对象" class="headerlink" title="Python面向对象"></a>Python面向对象</h1><h2 id="类及其结构"><a href="#类及其结构" class="headerlink" title="类及其结构"></a>类及其结构</h2><p>使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>:</span><br><span class="line">   <span class="string">&#x27;类的帮助信息&#x27;</span>   <span class="comment">#类文档字符串</span></span><br><span class="line">   class_suite  <span class="comment">#类体</span></span><br></pre></td></tr></table></figure><p>以下是一个简单的 Python 类的例子:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">   <span class="string">&#x27;所有员工的基类&#x27;</span></span><br><span class="line">   empCount = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, salary</span>):</span><br><span class="line">      self.name = name</span><br><span class="line">      self.salary = salary</span><br><span class="line">      Employee.empCount += <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">displayCount</span>(<span class="params">self</span>):</span><br><span class="line">     <span class="built_in">print</span> <span class="string">&quot;Total Employee %d&quot;</span> % Employee.empCount</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">displayEmployee</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&quot;Name : &quot;</span>, self.name,  <span class="string">&quot;, Salary: &quot;</span>, self.salary</span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h3><p>上例中，empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。可以在内部类或外部类使用<code> employee对象.empCount</code> 访问。</p><p>也可以使用下面函数的方式来访问属性：</p><ul><li>getattr(obj, name[, default]) : 访问对象的属性。</li><li>hasattr(obj,name) : 检查是否存在一个属性。</li><li>setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。</li><li>delattr(obj, name) : 删除属性。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hasattr</span>(emp1, <span class="string">&#x27;age&#x27;</span>)    <span class="comment"># 如果存在 &#x27;age&#x27; 属性返回 True。</span></span><br><span class="line"><span class="built_in">getattr</span>(emp1, <span class="string">&#x27;age&#x27;</span>)    <span class="comment"># 返回 &#x27;age&#x27; 属性的值</span></span><br><span class="line"><span class="built_in">setattr</span>(emp1, <span class="string">&#x27;age&#x27;</span>, <span class="number">8</span>) <span class="comment"># 添加属性 &#x27;age&#x27; 值为 8</span></span><br><span class="line"><span class="built_in">delattr</span>(emp1, <span class="string">&#x27;age&#x27;</span>)    <span class="comment"># 删除属性 &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="内置属性"><a href="#内置属性" class="headerlink" title="内置属性"></a>内置属性</h3><p>在Python中，一个类中默认存在内置类属性，如下所示：</p><ul><li><code>__dict__ </code>: 类的属性（包含一个字典，由类的数据属性组成）</li><li><code>__doc__</code> : 类的文档字符串</li><li><code>__name__</code>: 类名</li><li><code>__module__</code>：类定义所在的模块，（类的全名是<code>__main__.className</code>，如果类位于一个导入模块mymod中，那么<code>className.__module__ </code>等于 mymod）</li><li><code>__bases__ </code>: 类的所有父类构成元素（包含了一个由所有父类组成的元组）</li></ul><p>Python内置类属性调用实例如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">   <span class="string">&#x27;所有员工的基类&#x27;</span></span><br><span class="line">   empCount = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, salary</span>):</span><br><span class="line">      self.name = name</span><br><span class="line">      self.salary = salary</span><br><span class="line">      Employee.empCount += <span class="number">1</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">displayCount</span>(<span class="params">self</span>):</span><br><span class="line">     <span class="built_in">print</span> <span class="string">&quot;Total Employee %d&quot;</span> % Employee.empCount</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">displayEmployee</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&quot;Name : &quot;</span>, self.name,  <span class="string">&quot;, Salary: &quot;</span>, self.salary</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Employee.__doc__:&quot;</span>, Employee.__doc__</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Employee.__name__:&quot;</span>, Employee.__name__</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Employee.__module__:&quot;</span>, Employee.__module__</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Employee.__bases__:&quot;</span>, Employee.__bases__</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Employee.__dict__:&quot;</span>, Employee.__dict__</span><br></pre></td></tr></table></figure><p>执行以上代码输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Employee.__doc__: 所有员工的基类</span><br><span class="line">Employee.__name__: Employee</span><br><span class="line">Employee.__module__: __main__</span><br><span class="line">Employee.__bases__: ()</span><br><span class="line">Employee.__dict__: &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;displayCount&#x27;: &lt;function displayCount at 0x10a939c80&gt;, &#x27;empCount&#x27;: 0, &#x27;displayEmployee&#x27;: &lt;function displayEmployee at 0x10a93caa0&gt;, &#x27;__doc__&#x27;: &#x27;\xe6\x89\x80\xe6\x9c\x89\xe5\x91\x98\xe5\xb7\xa5\xe7\x9a\x84\xe5\x9f\xba\xe7\xb1\xbb&#x27;, &#x27;__init__&#x27;: &lt;function __init__ at 0x10a939578&gt;&#125;</span><br></pre></td></tr></table></figure><h3 id="公有、私有、保护属性"><a href="#公有、私有、保护属性" class="headerlink" title="公有、私有、保护属性"></a>公有、私有、保护属性</h3><ul><li><p><strong>public_attrs：</strong>没有下划线开头，声明该属性为公有，可以在类内部、外部均可被访问。</p></li><li><p><strong>__private_attrs</strong>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong>。</p></li><li><p><strong>_protect_attrs：</strong>以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 <strong>from module import *</strong></p></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>， 按照惯例它的名称是 self（当然这个名称并非固定）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prt</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        <span class="built_in">print</span>(self.__class__)</span><br><span class="line"> </span><br><span class="line">t = Test()</span><br><span class="line">t.prt()</span><br></pre></td></tr></table></figure><p>以上实例执行结果为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;__main__.Test instance at <span class="number">0x10d066878</span>&gt;</span><br><span class="line">__main__.Test</span><br></pre></td></tr></table></figure><p>与属性类似，两个下划线开头**__private_method**，声明该方法为私有方法，不能在类的外部调用。在类的内部调用 <strong>self.__private_methods</strong>。</p><h3 id="基础重载方法"><a href="#基础重载方法" class="headerlink" title="基础重载方法"></a>基础重载方法</h3><p>第一种方法<code>__init__()</code>方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法，Python的类中还有下面的基础重载方法：</p><table><thead><tr><th align="left">序号</th><th align="left">方法, 描述 &amp; 简单的调用</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong><strong>init</strong> ( self [,args…] )</strong> 构造函数 简单的调用方法: <em>obj &#x3D; className(args)</em></td></tr><tr><td align="left">2</td><td align="left"><strong><strong>del</strong>( self )</strong> 析构方法, 删除一个对象 简单的调用方法 : <em>del obj</em></td></tr><tr><td align="left">3</td><td align="left"><strong><strong>repr</strong>( self )</strong> 转化为供解释器读取的形式 简单的调用方法 : <em>repr(obj)</em></td></tr><tr><td align="left">4</td><td align="left"><strong><strong>str</strong>( self )</strong> 用于将值转化为适于人阅读的形式 简单的调用方法 : <em>str(obj)</em></td></tr><tr><td align="left">5</td><td align="left"><strong><strong>cmp</strong> ( self, x )</strong> 对象比较 简单的调用方法 : <em>cmp(obj, x)</em></td></tr></tbody></table><p>从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 <strong><code>self.__class__</code></strong> 则指向类。</p><h2 id="创建类的实例对象"><a href="#创建类的实例对象" class="headerlink" title="创建类的实例对象"></a>创建类的实例对象</h2><p>实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。</p><p>以下使用类的名称 Employee 来实例化，并通过<code>__init__</code>方法接收参数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;创建 Employee 类的第一个对象&quot;</span></span><br><span class="line">emp1 = Employee(<span class="string">&quot;Zara&quot;</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="string">&quot;创建 Employee 类的第二个对象&quot;</span></span><br><span class="line">emp2 = Employee(<span class="string">&quot;Manni&quot;</span>, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。</p><p>通过继承创建的新类称为<strong>子类</strong>或<strong>派生类</strong>，被继承的类称为<strong>基类</strong>、<strong>父类</strong>或<strong>超类</strong>。</p><p><strong>继承语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class 派生类名(基类名,...)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在python中继承中的一些特点：</p><ul><li>在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数</li><li>Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。</li></ul><p>对于子类继承父类构造函数说明：</p><ul><li><p>情况一：<strong>子类需要自动调用父类的方法：</strong>子类不重写__init__()方法，实例化子类后，会自动调用父类的__init__()的方法。</p></li><li><p>情况二：<strong>子类不需要自动调用父类的方法：</strong>子类重写__init__()方法，实例化子类后，将不会自动调用父类的__init__()的方法。</p></li><li><p>情况三：<strong>子类重写__init__()方法又需要调用父类的方法：</strong>使用super关键词：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">super(子类，self).__init__(参数1，参数2，....)</span><br><span class="line">class Son(Father):</span><br><span class="line">  def __init__(self, name):   </span><br><span class="line">    super(Son, self).__init__(name)</span><br></pre></td></tr></table></figure><p>如果在继承元组中列了一个以上的类，那么它就被称作”多重继承” 。</p><p><strong>语法：</strong></p><p>派生类的声明，与他们的父类类似，继承的基类列表跟在类名之后，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class SubClassName (ParentClass1[, ParentClass2, ...]):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>:        <span class="comment"># 定义父类</span></span><br><span class="line">   parentAttr = <span class="number">100</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&quot;调用父类构造函数&quot;</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">parentMethod</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;调用父类方法&#x27;</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">setAttr</span>(<span class="params">self, attr</span>):</span><br><span class="line">      Parent.parentAttr = attr</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">getAttr</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&quot;父类属性 :&quot;</span>, Parent.parentAttr</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>(<span class="title class_ inherited__">Parent</span>): <span class="comment"># 定义子类</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&quot;调用子类构造方法&quot;</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">childMethod</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="built_in">print</span> <span class="string">&#x27;调用子类方法&#x27;</span></span><br><span class="line"> </span><br><span class="line">c = Child()          <span class="comment"># 实例化子类</span></span><br><span class="line">c.childMethod()      <span class="comment"># 调用子类的方法</span></span><br><span class="line">c.parentMethod()     <span class="comment"># 调用父类方法</span></span><br><span class="line">c.setAttr(<span class="number">200</span>)       <span class="comment"># 再次调用父类的方法 - 设置属性值</span></span><br><span class="line">c.getAttr()          <span class="comment"># 再次调用父类的方法 - 获取属性值</span></span><br></pre></td></tr></table></figure><p>以上代码执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">调用子类构造方法</span><br><span class="line">调用子类方法</span><br><span class="line">调用父类方法</span><br><span class="line">父类属性 : 200</span><br></pre></td></tr></table></figure><p>你可以继承多个类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A:        # 定义类 A</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">class B:         # 定义类 B</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">class C(A, B):   # 继承类 A 和 B</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>你可以使用issubclass()或者isinstance()方法来检测。</p><ul><li>issubclass() - 布尔函数判断一个类是另一个类的子类或者子孙类，语法：issubclass(sub,sup)</li><li>isinstance(obj, Class) 布尔函数如果obj是Class类的实例对象或者是一个Class子类的实例对象则返回true。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/python/python-operators.html&quot;&gt;笔记原地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Python</summary>
      
    
    
    
    <category term="后端" scheme="http://cjx_0723.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Python" scheme="http://cjx_0723.gitee.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Websocket实现前后端实时通信</title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/Java/Websocket%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/Java/Websocket%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1/</id>
    <published>2023-10-30T14:04:29.034Z</published>
    <updated>2023-10-30T14:04:29.034Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="WebSocket简介"><a href="#WebSocket简介" class="headerlink" title="WebSocket简介"></a>WebSocket简介</h1><h3 id="什么是websocket"><a href="#什么是websocket" class="headerlink" title="什么是websocket"></a>什么是<a href="https://so.csdn.net/so/search?q=websocket&spm=1001.2101.3001.7020">websocket</a></h3><ul><li>WebSocket 是一种网络通信协议。RFC6455定义了它的通信标准。</li><li>WebSocket是HTML5下一种新的协议（websocket协议本质上是一个基于tcp的协议）</li><li>它实现了浏览器与服务器<a href="https://so.csdn.net/so/search?q=%E5%85%A8%E5%8F%8C%E5%B7%A5&spm=1001.2101.3001.7020">全双工</a>通信，能更好的节省服务器资源和带宽并达到实时通讯的目的</li><li>http是一种无状态，无连接，单向的<a href="https://so.csdn.net/so/search?q=%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE&spm=1001.2101.3001.7020">应用层协议</a>，它采用了请求&#x2F;响应模型，通信请求只能由客户端发起，服务端对请求做出应答处理。这样的弊端显然是很大的，只要服务端状态连续变化，客户端就必须实时响应，都是通过javascript与ajax进行轮询，这样显然是非常麻烦的，同时轮询的效率低，非常的浪费资源(http一直打开，一直重复的连接)。</li><li>于是就有了websocket，Websocket是一个持久化的协议，它是一种全面双工通讯的网络技术，任意一方都可以建立连接将数据推向另一方，websocket只需要建立一次连接，就可以一直保持</li></ul><h3 id="websocket-原理"><a href="#websocket-原理" class="headerlink" title="websocket 原理"></a>websocket 原理</h3><ul><li>websocket约定了一个通信的规范，通过一个握手的机制，客户端和服务器之间能建立一个类似tcp的连接，从而方便它们之间的通信</li><li>在websocket出现之前，web交互一般是基于http协议的短连接或者长连接</li><li>websocket是一种全新的协议，不属于http无状态协议，协议名为”ws”</li><li>说它是TCP传输，主要体现在建立长连接后，浏览器是可以给服务器发送数据，服务器也可以给浏览器发送请求的。当然它的数据格式并不是自己定义的，是在要传输的数据外层有ws协议规定的外层包的。</li></ul><h3 id="websocket与http的关系"><a href="#websocket与http的关系" class="headerlink" title="websocket与http的关系"></a>websocket与http的关系</h3><ul><li><strong>相同点：</strong></li><li><strong>都是基于tcp的，都是可靠性传输协议，都是应用层协议</strong></li><li><strong>不同点：</strong></li><li><strong>WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息</strong></li><li><strong>HTTP是单向的</strong></li><li><strong>WebSocket是需要浏览器和服务器握手进行建立连接的</strong></li><li><strong>而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接</strong></li><li><strong>联系</strong></li><li><strong>WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的</strong></li><li><strong>关系图</strong></li></ul><p><strong><img src="https://img-blog.csdnimg.cn/11cd72c1e9434dcda18a1dbf059f5fb1.png" alt="img"></strong></p><p><img src="https://img-blog.csdnimg.cn/ed6e4f8cf2ea4de7a33ccc282f18a0f1.png" alt="img"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dce.blockchain.websocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.PathParam;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 定义连接时候的 url</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/websocket/&#123;key&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与某个客户端的连接会话，需要通过它来给客户端发送数据</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;WebSocketServer&gt; webSockets = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArraySet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//用来存放每个客户端对应的WebSocket对象。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Session&gt; sessionPool = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接成功后调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key用来标记一个对话，一个对话对应一个key，key通过路径变量传递</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session, <span class="meta">@PathParam(&quot;key&quot;)</span> String key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//key为前端传给后端的token</span></span><br><span class="line">        <span class="built_in">this</span>.session = session;</span><br><span class="line">        <span class="comment">// 从token中获取到userid当做区分websocket客户端的key</span></span><br><span class="line">        sessionPool.put(String.valueOf(key), session);</span><br><span class="line">        <span class="keyword">if</span> (sessionPool.get(String.valueOf(key)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            webSockets.add(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        webSockets.add(<span class="built_in">this</span>);</span><br><span class="line">        log.info(<span class="string">&quot;webSocket连接成功&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;WebSocket有新的连接，连接总数为：&quot;</span> + webSockets.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">()</span> &#123;</span><br><span class="line">        webSockets.remove(<span class="built_in">this</span>);</span><br><span class="line">        log.info(<span class="string">&quot;webSocket连接关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法，根据业务要求进行处理，这里就简单地将收到的消息直接群发推送出去</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;WebSocket收到客户端消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生错误时的回调函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> error</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable error)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;发生错误&quot;</span>);</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单点消息发送</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 发送session 对应的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendTextMessage</span><span class="params">(String key, String message)</span> &#123;</span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> sessionPool.get(key);</span><br><span class="line">        <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                session.getBasicRemote().sendText(message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提示信息</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Message</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="comment">// 引入token 解析用户id在后端处理</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/auth&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后端ip端口</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;ws://localhost:8090/websocket/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ws</span><br><span class="line"><span class="keyword">var</span> tt</span><br><span class="line"><span class="keyword">var</span> lockReconnect = <span class="literal">false</span> <span class="comment">// 避免重复连接</span></span><br><span class="line"><span class="keyword">var</span> clientId = <span class="title function_">getToken</span>() <span class="comment">// cookies中获取token值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> websocket = &#123;</span><br><span class="line"><span class="comment">// 建立连接</span></span><br><span class="line">  <span class="title class_">Init</span>: <span class="keyword">function</span>(<span class="params">clientId</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&#x27;WebSocket&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span><br><span class="line">      ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(url + clientId)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;MozWebSocket&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span><br><span class="line">      ws = <span class="keyword">new</span> <span class="title class_">MozWebSocket</span>(url + clientId)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(&#x27;您的浏览器不支持 WebSocket!&#x27;)</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// websocket 生命周期根据websocket状态自己会执行</span></span><br><span class="line">    <span class="comment">// websocket 成功 失败 错误 断开 这里会自动执行</span></span><br><span class="line">    <span class="comment">// 这个方法后端通过send调用 这个方法会执行和接收参数</span></span><br><span class="line">    ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="comment">// console.log(&#x27;接收消息:&#x27; + e.data)</span></span><br><span class="line">      <span class="keyword">var</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(e.<span class="property">data</span>)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">      heartCheck.<span class="title function_">start</span>()</span><br><span class="line">      <span class="keyword">if</span> (data.<span class="property">msg</span> !== <span class="string">&#x27;&#x27;</span> &amp;&amp; data.<span class="property">msg</span> !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="title class_">Message</span>(&#123;</span><br><span class="line">          <span class="attr">message</span>: e.<span class="property">data</span>.<span class="property">msg</span>,</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// messageHandle(e.data)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接已关闭&#x27;</span>)</span><br><span class="line">      <span class="title class_">Message</span>(&#123;</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;webSocket连接已经关闭&#x27;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="title function_">reconnect</span>(clientId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// console.log(&#x27;连接成功&#x27;)</span></span><br><span class="line">      <span class="title class_">Message</span>(&#123;</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;webSocket连接成功&#x27;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      heartCheck.<span class="title function_">start</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ws.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="comment">// console.log(&#x27;数据传输发生错误&#x27;)</span></span><br><span class="line">      <span class="title class_">Message</span>(&#123;</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;数据传输发生错误&#x27;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="title function_">reconnect</span>(clientId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 我们单独写了一个方法 调用ws的关闭方法，这样就可以在退出登录的时候主动关闭连接</span></span><br><span class="line">  <span class="comment">// 关闭连接</span></span><br><span class="line">  <span class="attr">onClose</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;主动关闭连接！&#x27;</span>)</span><br><span class="line">    <span class="comment">// 关闭websocket连接和关闭断开重连机制</span></span><br><span class="line">    lockReconnect = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 调用 上面的websocket关闭方法</span></span><br><span class="line">    ws.<span class="title function_">close</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 前端的send给后端发信息</span></span><br><span class="line">  <span class="title class_">Send</span>: <span class="keyword">function</span>(<span class="params">sender, reception, body, flag</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">      <span class="attr">sender</span>: sender,</span><br><span class="line">      <span class="attr">reception</span>: reception,</span><br><span class="line">      <span class="attr">body</span>: body,</span><br><span class="line">      <span class="attr">flag</span>: flag</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> msg = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)</span><br><span class="line">    <span class="comment">// console.log(&#x27;发送消息：&#x27; + msg)</span></span><br><span class="line">    ws.<span class="title function_">send</span>(msg)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 返回ws对象</span></span><br><span class="line">  <span class="title function_">getWebSocket</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ws</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// websocket 自带的状态码意思提示</span></span><br><span class="line">  <span class="title function_">getStatus</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ws.<span class="property">readyState</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;未连接&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ws.<span class="property">readyState</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;已连接&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ws.<span class="property">readyState</span> === <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;连接正在关闭&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ws.<span class="property">readyState</span> === <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;连接已关闭&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新页面后需要重连</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">performance</span>.<span class="property">navigation</span>.<span class="property">type</span> === <span class="number">1</span> &amp;&amp; <span class="title function_">getToken</span>() != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 刷新后重连</span></span><br><span class="line">  <span class="comment">// reconnect(clientId);</span></span><br><span class="line">  websocket.<span class="title class_">Init</span>(clientId)</span><br><span class="line">  <span class="comment">// 如果websocket没连接成功，则开始延迟连接</span></span><br><span class="line">  <span class="keyword">if</span> (ws == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">reconnect</span>(clientId)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> websocket</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据消息标识做不同的处理</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">messageHandle</span>(<span class="params">message</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> msg = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(message)</span><br><span class="line">  <span class="keyword">switch</span> (msg.<span class="property">flag</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;command&#x27;</span>:</span><br><span class="line">      <span class="comment">// console.log(&#x27;指令消息类型&#x27;)</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;inform&#x27;</span>:</span><br><span class="line">      <span class="comment">// console.log(&#x27;通知&#x27;)</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">    <span class="comment">// console.log(&#x27;未知消息类型&#x27;)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重连方法 刷新页面 连接错误 连接关闭时调用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reconnect</span>(<span class="params">sname</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (lockReconnect) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  lockReconnect = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 没连接上会一直重连，设置延迟避免请求过多</span></span><br><span class="line">  tt &amp;&amp; <span class="built_in">clearTimeout</span>(tt)</span><br><span class="line">  tt = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(&#x27;执行断线重连...&#x27;)</span></span><br><span class="line">    websocket.<span class="title class_">Init</span>(sname)</span><br><span class="line">    lockReconnect = <span class="literal">false</span></span><br><span class="line">  &#125;, <span class="number">4000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在需要使用的页面，编写下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">     <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">          websocket.<span class="title class_">Init</span>(<span class="string">&#x27;mine&#x27;</span>)</span><br><span class="line">          <span class="keyword">var</span> wb = websocket.<span class="title function_">getWebSocket</span>()</span><br><span class="line">          wb.<span class="property">onmessage</span> = <span class="variable language_">this</span>.<span class="property">handleMessage</span></span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="attr">methods</span>: &#123;</span><br><span class="line">          <span class="title function_">handleMessage</span>(<span class="params">e</span>) &#123;</span><br><span class="line">               <span class="comment">// console.log(&#x27;接收消息:&#x27; + e.data)</span></span><br><span class="line">               <span class="keyword">var</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(e.<span class="property">data</span>)</span><br><span class="line">               <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">               <span class="keyword">if</span> (data.<span class="property">msg</span> !== <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">                    <span class="title class_">Message</span>(&#123;</span><br><span class="line">                         <span class="attr">message</span>: data.<span class="property">msg</span>,</span><br><span class="line">                         <span class="attr">type</span>: <span class="string">&#x27;success&#x27;</span></span><br><span class="line">                    &#125;)</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (data.<span class="property">code</span> === <span class="string">&#x27;00&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span> (data.<span class="property">code</span> === <span class="string">&#x27;01&#x27;</span>)&#123;</span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">sha256Attempts</span> = data.<span class="property">data</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// messageHandle(e.data)</span></span><br><span class="line">          &#125;,</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里定义session的key为mine</p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;WebSocket简介&quot;&gt;&lt;a href=&quot;#WebSocket简介&quot; class=&quot;headerlink&quot; title=&quot;WebSocket简介&quot;&gt;&lt;/a&gt;WebSoc</summary>
      
    
    
    
    <category term="后端" scheme="http://cjx_0723.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Vue开发" scheme="http://cjx_0723.gitee.io/tags/Vue%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java" scheme="http://cjx_0723.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>idea多端口实例运行</title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/Java/idea%E5%A4%9A%E7%AB%AF%E5%8F%A3%E5%AE%9E%E4%BE%8B%E8%BF%90%E8%A1%8C/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/Java/idea%E5%A4%9A%E7%AB%AF%E5%8F%A3%E5%AE%9E%E4%BE%8B%E8%BF%90%E8%A1%8C/</id>
    <published>2023-10-30T14:04:29.034Z</published>
    <updated>2023-10-30T14:04:29.034Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="1-问题场景"><a href="#1-问题场景" class="headerlink" title="1 问题场景"></a>1 问题场景</h2><p>我们在进行新项目开发的时候， 可能做完一个新的模块功能并自测通过之后， 我们希望测试人员能帮我跑一些<a href="https://so.csdn.net/so/search?q=%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B&spm=1001.2101.3001.7020">单元测试用例</a>来进行测试验证， 但是我们又需要在此基础上技术开发新的功能， 这是我们就需要在我们的开发PC上同时运行多实例来保证开发及内部测试的需求，下面就说说怎么在IDEA上实现这个同项目多实例运行</p><h2 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2 环境准备"></a>2 环境准备</h2><ul><li>JDK 1.8</li><li>IDEA 2021.3.2</li></ul><h2 id="3-配置过程"><a href="#3-配置过程" class="headerlink" title="3 配置过程"></a>3 配置过程</h2><h3 id="3-1-运行实例配置"><a href="#3-1-运行实例配置" class="headerlink" title="3.1 运行实例配置"></a>3.1 运行实例配置</h3><p>修改当前项目的启动配置<br><img src="https://img-blog.csdnimg.cn/2c206beeb9a44f95a9159e5f1ae67b8e.png" alt="在这里插入图片描述"><br>设置项目实例名称<br><img src="https://img-blog.csdnimg.cn/cdb0b9b98b43415ba841a5bf38c8816b.png" alt="在这里插入图片描述"><br>开启多实例配置<br><img src="https://img-blog.csdnimg.cn/98db3121e54440b383f9df973682d003.png" alt="在这里插入图片描述"><br>设置当前实例的运行端口<br><img src="https://img-blog.csdnimg.cn/bca5caab4cfe4d86a354c33cc1b02996.png" alt="在这里插入图片描述"><br>复制当前实例<br><img src="https://img-blog.csdnimg.cn/aea48a907e0a49e8abc0a82126a36219.png" alt="在这里插入图片描述"><br>修改复制实例的名称及运行端口<br><img src="https://img-blog.csdnimg.cn/1b1b263407824ff2a74c0584aec05e50.png" alt="在这里插入图片描述"></p><h3 id="3-2-设置运行组"><a href="#3-2-设置运行组" class="headerlink" title="3.2 设置运行组"></a>3.2 设置运行组</h3><p>新建一个运行组<br><img src="https://img-blog.csdnimg.cn/3ee472dd63014acc9fc2e59cc37753aa.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/674cbd4e2a7144bb9345bfdb289b8447.png" alt="在这里插入图片描述"><br>修改运行组名称和运行组中的启动实例<br><img src="https://img-blog.csdnimg.cn/083c2929546a43619890167c0f0acbd1.png" alt="在这里插入图片描述"></p><h3 id="3-3-运行组启动测试"><a href="#3-3-运行组启动测试" class="headerlink" title="3.3 运行组启动测试"></a>3.3 运行组启动测试</h3><p>通过以上操作，基本就配置好了， 这里我们来运行一下， 看看两个服务是否都可以正常运行起来。<br><img src="https://img-blog.csdnimg.cn/f173f2643dba42e9b4b8892915105a42.png" alt="在这里插入图片描述"><br>AppRun-8009成功启动<br><img src="https://img-blog.csdnimg.cn/11c9748207c843dd955e8f670ca2cbab.png" alt="在这里插入图片描述"><br>AppRun-8010成功启动<br><img src="https://img-blog.csdnimg.cn/594e0c15c25141a8bd51fed0f7c11175.png" alt="在这里插入图片描述"></p><p>OK, 配置结束， 之后让测试在8010端口进行测试， 我们可以在8009端口继续进行新的业务模块功能开发，匹配不会互相影响。当然正常的我们应该打包到测试环境提供一个稳定的环境让测试人员进行测试，咱们这只是内部转测试，还没到集成阶段， 只是能尽早让测试人员介入到项目中的一种解决方案，每个公司可能对于<a href="https://so.csdn.net/so/search?q=%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86&spm=1001.2101.3001.7020">项目管理</a>的要求都不一样，根据实际情况调整处理就好了。</p><h2 id="4-多环境运行配置"><a href="#4-多环境运行配置" class="headerlink" title="4 多环境运行配置"></a>4 多环境运行配置</h2><p>在项目开发中，难免会遇上需要配置多个运行环境，例如开发环境、测试环境、上线环境等等，如果需要IDEA能够在不同端口运行不同的环境，则需要进行以下配置，这里我的环境：</p><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230513221053596.png" alt="image-20230513221053596"></p><p>在运行实例配置中，只需要指定该实例所运行的环境即可：</p><p><img src="https://typora-md-bucket.oss-cn-beijing.aliyuncs.com/image-20230513221202978.png" alt="image-20230513221202978"></p>]]></content>
    
    
    <summary type="html">idea多端口运行是我一直以来的痛，因为idea默认运行实例不支持多端口运行，这也让我踩了很多的坑</summary>
    
    
    
    <category term="后端" scheme="http://cjx_0723.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://cjx_0723.gitee.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot参数接收</title>
    <link href="http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/Java/SpringBoot%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6/"/>
    <id>http://cjx_0723.gitee.io/2023/10/30/%E5%90%8E%E7%AB%AF/Java/SpringBoot%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6/</id>
    <published>2023-10-30T14:04:29.033Z</published>
    <updated>2023-10-30T14:04:29.033Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h1><p>主要用于将请求参数区域的数据映射到控制层方法的参数上，在 GET 与 POST 方法中都适用，两种请求方法对应前端两种不同的请求方式，下面是@RequestParam一种出现方式</p><p><img src="https://img-blog.csdnimg.cn/2296b983ed7a4bd689c61bcb076dce3a.png" alt="在这里插入图片描述"></p><p>我们需要知道@RequestParam注解主要有哪些参数</p><ul><li><strong>value</strong>：请求中传入参数的名称，如果不设置后台接口的value值，则会默认为该变量名。比如上图中第一个参数如果不设置value&#x3D;“page”,则前端传入的参数名必须为pageNum,否则在后台接口中pageNum将接收不到对应的数据</li><li><strong>required</strong>：该参数是否为必传项。<strong>默认是true</strong>，表示请求中一定要传入对应的参数，<strong>否则会报404错误</strong>，如果设置为false时，当请求中没有此参数，<strong>将会默认为null,而对于基本数据类型的变量，则必须有值，这时会抛出空指针异常</strong>。如果允许空值，则接口中变量需要使用包装类来声明。</li><li><strong>defaultValue</strong>：参数的默认值，如果请求中没有同名的参数时，该变量默认为此值。</li></ul><h2 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h2><h3 id="问号传参"><a href="#问号传参" class="headerlink" title="问号传参"></a>问号传参</h3><ul><li>前端代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8081/boot/one?name=xxx&amp;age=22&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><ul><li>后端接收</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * axios问号传参</span></span><br><span class="line"><span class="comment"> * 无Content-Type</span></span><br><span class="line"><span class="comment"> * Payload: Query String Parameters name: xxx age: 22</span></span><br><span class="line"><span class="comment"> * 没有注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/boot/get1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getParamByQ</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span> &amp;&amp; age != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(name + age, <span class="string">&quot;请求成功&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">null</span>, <span class="string">&quot;请求失败&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反斜杠传参"><a href="#反斜杠传参" class="headerlink" title="反斜杠传参"></a>反斜杠传参</h3><ul><li>前端代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8081/boot/get2/xxx/22&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><ul><li>后端代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反斜杠传参</span></span><br><span class="line"><span class="comment"> * 无Content-Type</span></span><br><span class="line"><span class="comment"> * 参数在请求的url中</span></span><br><span class="line"><span class="comment"> * 注解: <span class="doctag">@PathVariable</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/boot/get2/&#123;name&#125;/&#123;age&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getParamByX</span><span class="params">(<span class="meta">@PathVariable</span> String name, <span class="meta">@PathVariable</span> Integer age)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span> &amp;&amp; age != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(name + age, <span class="string">&quot;请求成功&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">null</span>, <span class="string">&quot;请求失败&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h2><h3 id="x-www-form-urlencoded方式"><a href="#x-www-form-urlencoded方式" class="headerlink" title="x-www-form-urlencoded方式"></a>x-www-form-urlencoded方式</h3><ul><li>前端代码<br>需要引入Qs模块，前端控制台执行<code>npm install Qs</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&quot;http://localhost:8081/boot/post1&quot;</span>, <span class="title class_">Qs</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;hqz&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;), &#123;</span><br><span class="line">     <span class="attr">headers</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>后端代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * post传表单方式</span></span><br><span class="line"><span class="comment"> * url: 不变</span></span><br><span class="line"><span class="comment"> * Content-Type: application/x-www-form-urlencoded</span></span><br><span class="line"><span class="comment"> * Payload: Form Data name: hqz age: 22</span></span><br><span class="line"><span class="comment"> * 注解: <span class="doctag">@RequestParam</span>(value = &quot;name&quot;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(value = &quot;/boot/post1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getDataByForm</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;)</span> String name, <span class="meta">@RequestParam(value = &quot;age&quot;)</span> Integer age)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">null</span> &amp;&amp; age != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(name + age, <span class="string">&quot;请求成功&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">null</span>, <span class="string">&quot;请求失败&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FormData方式"><a href="#FormData方式" class="headerlink" title="FormData方式"></a>FormData方式</h3><ul><li>前端代码<br>前端需要构造一个FormData类</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fd = <span class="keyword">new</span> <span class="title class_">FormData</span>()</span><br><span class="line">fd.<span class="title function_">append</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">fd.<span class="title function_">append</span>(<span class="string">&quot;age&quot;</span>, <span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">post</span>(<span class="string">&quot;http://localhost:8081/boot/post2&quot;</span>, fd, &#123;</span><br><span class="line">     <span class="attr">headers</span>: &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span>&#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>后端代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * post传FormData</span></span><br><span class="line"><span class="comment"> * url: 不变</span></span><br><span class="line"><span class="comment"> * Content-Type: multipart/form-data</span></span><br><span class="line"><span class="comment"> * Payload: Form Data name: xxx age: 22</span></span><br><span class="line"><span class="comment"> * 注解: <span class="doctag">@RequestParam</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(value = &quot;/boot/post2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getDataByFormData</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;)</span> String name, <span class="meta">@RequestParam(value = &quot;age&quot;)</span> Integer age)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (name != <span class="literal">null</span> &amp;&amp; age != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(name + age, <span class="string">&quot;请求成功&quot;</span>, <span class="number">100</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">null</span>, <span class="string">&quot;请求失败&quot;</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">总结SpringBoot参数接收的方法</summary>
    
    
    
    <category term="后端" scheme="http://cjx_0723.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Java" scheme="http://cjx_0723.gitee.io/tags/Java/"/>
    
  </entry>
  
</feed>
